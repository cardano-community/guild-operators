#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2086,SC2230,SC2009,SC2206,SC2062,SC2059

######################################
# User Variables - Change as desired #
# Leave as is if unsure              #
######################################

#CCLI="${HOME}/.cabal/bin/cardano-cli"                  # Override automatic detection of path to cardano-cli executable
#CNCLI="${HOME}/.cargo/bin/cncli"                       # Override automatic detection of path to cncli executable (https://github.com/AndrewWestberg/cncli)
#CNODE_HOME="/opt/cardano/cnode"                        # Override default CNODE_HOME path (defaults to /opt/cardano/cnode)
CNODE_PORT=6000                                         # Set node port
#CONFIG="${CNODE_HOME}/files/config.json"               # Override automatic detection of node config path
#SOCKET="${CNODE_HOME}/sockets/node0.socket"            # Override automatic detection of path to socket
#TOPOLOGY="${CNODE_HOME}/files/topology.json"           # Override default topology.json path
#LOG_DIR="${CNODE_HOME}/logs"                           # Folder where your logs will be sent to (must pre-exist)
#DB_DIR="${CNODE_HOME}/db"                              # Folder to store the cardano-node blockchain db
#TMP_DIR="/tmp/cnode"                                   # Folder to hold temporary files in the various scripts, each script might create additional subfolders
#EKG_HOST=127.0.0.1                                     # Set node EKG host IP
#EKG_PORT=12788                                         # Override automatic detection of node EKG port
#PROM_HOST=127.0.0.1                                    # Set node Prometheus host IP
#PROM_PORT=12798                                        # Override automatic detection of node Prometheus port
#EKG_TIMEOUT=3                                          # Maximum time in seconds that you allow EKG request to take before aborting (node metrics)
#CURL_TIMEOUT=10                                        # Maximum time in seconds that you allow curl file download to take before aborting (GitHub update process)
#BLOCKLOG_DIR="${CNODE_HOME}/guild-db/blocklog"         # Override default directory used to store block data for core node
#BLOCKLOG_TZ="UTC"                                      # TimeZone to use when displaying blocklog - https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
#SHELLEY_TRANS_EPOCH=208                                # Override automatic detection of shelley epoch start, e.g 208 for mainnet
#TG_BOT_TOKEN=""                                        # Uncomment and set to enable telegramSend function. To create your own BOT-token and Chat-Id follow guide at:
#TG_CHAT_ID=""                                          # https://cardano-community.github.io/guild-operators/#/Scripts/sendalerts
#USE_EKG="N"                                            # Use EKG metrics from the node instead of Promethus. Promethus metrics(default) should yield slightly better performance
#TIMEOUT_LEDGER_STATE=300                               # Timeout in seconds for querying and dumping ledger-state
#IP_VERSION=4                                           # The IP version to use for push and fetch, valid options: 4 | 6 | mix (Default: 4)

#WALLET_FOLDER="${CNODE_HOME}/priv/wallet"              # Root folder for Wallets
#POOL_FOLDER="${CNODE_HOME}/priv/pool"                  # Root folder for Pools
                                                        # Each wallet and pool has a friendly name and subfolder containing all related keys, certificates, ...
#POOL_NAME=""                                           # Set the pool's name to run node as a core node (the name, NOT the ticker, ie folder name)

#WALLET_PAY_VK_FILENAME="payment.vkey"                  # Standardized names for all wallet related files
#WALLET_PAY_SK_FILENAME="payment.skey"
#WALLET_HW_PAY_SK_FILENAME="payment.hwsfile"
#WALLET_PAY_ADDR_FILENAME="payment.addr"
#WALLET_BASE_ADDR_FILENAME="base.addr"
#WALLET_STAKE_VK_FILENAME="stake.vkey"
#WALLET_STAKE_SK_FILENAME="stake.skey"
#WALLET_HW_STAKE_SK_FILENAME="stake.hwsfile"
#WALLET_STAKE_ADDR_FILENAME="reward.addr"
#WALLET_STAKE_CERT_FILENAME="stake.cert"
#WALLET_STAKE_DEREG_FILENAME="stake.dereg"
#WALLET_DELEGCERT_FILENAME="delegation.cert"

#POOL_ID_FILENAME="pool.id"                             # Standardized names for all pool related files
#POOL_HOTKEY_VK_FILENAME="hot.vkey"
#POOL_HOTKEY_SK_FILENAME="hot.skey"
#POOL_COLDKEY_VK_FILENAME="cold.vkey"
#POOL_COLDKEY_SK_FILENAME="cold.skey"
#POOL_OPCERT_COUNTER_FILENAME="cold.counter"
#POOL_OPCERT_FILENAME="op.cert"
#POOL_VRF_VK_FILENAME="vrf.vkey"
#POOL_VRF_SK_FILENAME="vrf.skey"
#POOL_CONFIG_FILENAME="pool.config"
#POOL_REGCERT_FILENAME="pool.cert"
#POOL_CURRENT_KES_START="kes.start"
#POOL_DEREGCERT_FILENAME="pool.dereg"

#ASSET_FOLDER="${CNODE_HOME}/priv/asset"                # Root folder for Multi-Assets containing minted assets and subfolders for Policy IDs
#ASSET_POLICY_VK_FILENAME="policy.vkey"                 # Standardized names for all multi-asset related files
#ASSET_POLICY_SK_FILENAME="policy.skey"
#ASSET_POLICY_SCRIPT_FILENAME="policy.script"           # File extension '.script' mandatory
#ASSET_POLICY_ID_FILENAME="policy.id"

######################################
# Do NOT modify code below           #
######################################

versionCheck() { printf '%s\n%s' "${1//v/}" "${2//v/}" | sort -C -V; } #$1=minimal_needed_version, $2=current_node_version

OFFLINE_MODE='N'
[[ $1 = "offline" ]] && OFFLINE_MODE='Y'
[[ $(basename $0 2>/dev/null) = "cnode.sh" ]] && OFFLINE_MODE='Y' # for backwards compatibility
[[ $(basename $0 2>/dev/null) = "topologyUpdater.sh" ]] && OFFLINE_MODE='Y' # for backwards compatibility

export LC_ALL=C.UTF-8

# special mapping of coreutils gdate to date for MacOS
if [[ $(uname) == Darwin ]]; then
   date () { gdate "$@"; }
fi

[[ -z ${CURL_TIMEOUT} ]] && CURL_TIMEOUT=10

# 
telegramSend() {
  if [[ -z "${TG_BOT_TOKEN}" ]] || [[ -z "${TG_CHAT_ID}" ]]; then
    echo "Warn: to use the telegramSend function you must first set the bot and chat id in the env file"
  else
    TG_URL="https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage?parse_mode=Markdown"
    TGAUE=$(curl -s -X POST $TG_URL -d chat_id=${TG_CHAT_ID} -d text="${HOSTNAME} $1");
  fi
}

[[ -z "${CCLI}" ]] && CCLI=$(command -v cardano-cli)
if [[ -z "${CCLI}" ]]; then
  if [[ -f "${HOME}/.cabal/bin/cardano-cli" ]]; then
    # Assumption being made that cardano-cli and cardano-node are both present, if not - prereqs and build instructions were not followed
    export PATH="${HOME}/.cabal/bin":$PATH
    CCLI=$(command -v cardano-cli)
  else
    echo "You do not have a cardano-cli binary available in \$PATH."
    return 1
  fi
else
  CCLI_PARENT="$(dirname ${CCLI})"
  export PATH="${CCLI_PARENT}":$PATH
fi

if [[ -z "${CNCLI}" ]]; then
  CNCLI=$(command -v cncli) || CNCLI="${HOME}/.cargo/bin/cncli"
fi

[[ -z "${CNODE_HOME}" ]] && CNODE_HOME=/opt/cardano/cnode

if [[ -z "${SOCKET}" ]]; then
  if [[ "$(ps -ef | grep "[c]ardano-node.*.port ${CNODE_PORT}")" =~ --socket-path[[:space:]]([^[:space:]]+) ]]; then
    export CARDANO_NODE_SOCKET_PATH="${BASH_REMATCH[1]}"
  elif [[ ${OFFLINE_MODE} = "Y" ]]; then
    export CARDANO_NODE_SOCKET_PATH="${CNODE_HOME}/sockets/node0.socket"
  else
    echo "Node socket not set in env file and automatic detection failed! [source: $(basename $0 2>/dev/null)]"
    return 1
  fi
else
  export CARDANO_NODE_SOCKET_PATH="${SOCKET}"
fi
export SOCKET="${CARDANO_NODE_SOCKET_PATH}" # For compatibility with those who havn't yet upgraded cnode.sh

if [[ -z "${CONFIG}" ]]; then
  if [[ "$(ps -ef | grep "[c]ardano-node.*.port ${CNODE_PORT}")" =~ --config[[:space:]]([^[:space:]]+) ]]; then
    CONFIG=${BASH_REMATCH[1]}
  elif [[ -f "${CNODE_HOME}/files/config.json" ]]; then
    CONFIG="${CNODE_HOME}/files/config.json"
  else
    echo "Node config not set in env file and automatic detection failed!"
    return 1
  fi
fi

if command -v "ss" &>/dev/null; then
  use_lsof='N'
elif command -v "lsof" &>/dev/null; then
  use_lsof='Y'
else
  echo -e "'ss' and fallback 'lsof' commands are missing, please install using latest prereqs.sh script or with your packet manager of choice.\nhttps://command-not-found.com/ss can be used to check package name to install.\n"
  return 1
fi

if ! command -v "jq" &>/dev/null; then
  echo -e "'jq' command is missing, please install using latest prereqs.sh script of with your packet manager of choice.\nhttps://command-not-found.com/ss can be used to check package name to install.\n"
  return 1
fi

if ! jq -r . "${CONFIG}" >/dev/null 2>&1; then
  echo "Could not parse ${CONFIG} file in JSON format, please double-check the syntax of your config, or simply download it from guild-operators repository!"
  return 1
elif [[ "$(jq -r .TraceChainDb ${CONFIG})" != "true" ]]; then
  echo "The ${CONFIG} file suggests that you have set TraceChainDb parameter to false. Please change it to true, as it is required to extract statistics from node."
  return 1
elif jq -e .options.mapBackends.\"cardano.node.BlockFetchDecision.peers\" "${CONFIG}" &>/dev/null; then
  echo "It seems your ${CONFIG} file was not upgraded from version before cardano-node 1.25.1. Please download it from guild-operators repository!"
  return 1
fi

[[ -z ${EKG_TIMEOUT} ]] && EKG_TIMEOUT=3
[[ -z ${EKG_HOST} ]] && EKG_HOST=127.0.0.1
if [[ ${EKG_HOST} =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
  IFS='.' read -ra EKG_OCTETS <<< ${EKG_HOST}
  if ! [[ ${EKG_OCTETS[0]} -le 255 && ${EKG_OCTETS[1]} -le 255 && ${EKG_OCTETS[2]} -le 255 && ${EKG_OCTETS[3]} -le 255 ]]; then
    echo "Not a valid IP range set for EKG host, please check env file for value of EKG_HOST (currently it is ${EKG_HOST} )!"
    return 1
  fi
else
  echo "Not a valid IP format set for EKG host, please check env file!"
  return 1
fi

if [[ -z ${EKG_PORT} ]]; then
  if ! EKG_PORT=$(jq -er '.hasEKG | if .|type=="array" then .[1] else . end' "${CONFIG}" 2>/dev/null); then
    if [[ ${OFFLINE_MODE} = "N" ]]; then
      echo "Could not get 'hasEKG' port in ${CONFIG}"
      return 1
    fi
  fi
elif [[ ! ${EKG_PORT} =~ ^[0-9]+$ ]]; then
  echo "Please set a valid EKG port number in env file! Current value is ${EKG_PORT} !"
  return 1
fi

if [[ -z ${PROM_HOST} ]]; then PROM_HOST=$(jq -er '.hasPrometheus[0]' "${CONFIG}" 2>/dev/null) || PROM_HOST=127.0.0.1; fi

if [[ ${PROM_HOST} =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
  IFS='.' read -ra PROM_OCTETS <<< ${PROM_HOST}
  if ! [[ ${PROM_OCTETS[0]} -le 255 && ${PROM_OCTETS[1]} -le 255 && ${PROM_OCTETS[2]} -le 255 && ${PROM_OCTETS[3]} -le 255 ]]; then
    echo "Not a valid IP range set for Prometheus host, please check env file for value of PROM_HOST (currently it is set to ${PROM_HOST} )!"
    return 1
  fi
else
  echo "Not a valid IP format set for Prometheus host, please check env file!"
  return 1
fi
if [[ -z ${PROM_PORT} ]]; then
  if ! PROM_PORT=$(jq -er '.hasPrometheus[1]' "${CONFIG}" 2>/dev/null); then
    if [[ ${OFFLINE_MODE} = "N" ]]; then
      echo "Could not get 'hasPrometheus' port in ${CONFIG}"
      return 1
    fi
  fi
elif [[ ! ${PROM_PORT} =~ ^[0-9]+$ ]]; then
  echo "Please set a valid Prometheus port number in env file! Current value is ${PROM_PORT} !"
  return 1
fi

if ! GENESIS_JSON=$(jq -er '.ShelleyGenesisFile' "${CONFIG}" 2>/dev/null); then
  if [[ ${OFFLINE_MODE} = "Y" ]]; then
    if [[ -f "${CNODE_HOME}/files/genesis.json" ]]; then
      GENESIS_JSON="${CNODE_HOME}/files/genesis.json"
    else
      echo "Could not find shelley genesis file in default location or 'ShelleyGenesisFile' in ${CONFIG}"
      return 1
    fi
  else
    echo "Could not get 'ShelleyGenesisFile' in ${CONFIG}"
    return 1
  fi
else
  # if relative path is used, assume same parent dir as config
  [[ ! ${GENESIS_JSON} =~ ^/ ]] && GENESIS_JSON="$(dirname "${CONFIG}")/${GENESIS_JSON}"
  [[ ! -f "${GENESIS_JSON}" ]] && echo "Shelley genesis file not found: ${GENESIS_JSON}" && return 1
fi

if ! BYRON_GENESIS_JSON=$(jq -er '.ByronGenesisFile' "${CONFIG}" 2>/dev/null); then
  if [[ ${OFFLINE_MODE} = "Y" ]]; then
    if [[ -f "${CNODE_HOME}/files/genesis.json" ]]; then
      GENESIS_JSON="${CNODE_HOME}/files/genesis.json"
    else
      echo "Could not find byron genesis file in default location or 'ByronGenesisFile' in ${CONFIG}"
      return 1
    fi
  else
    echo "Could not get 'ByronGenesisFile' specified in ${CONFIG}"
    return 1
  fi
else
  # if relative path is used, assume same parent dir as config
  [[ ! ${BYRON_GENESIS_JSON} =~ ^/ ]] && BYRON_GENESIS_JSON="$(dirname "${CONFIG}")/${BYRON_GENESIS_JSON}"
  [[ ! -f "${BYRON_GENESIS_JSON}" ]] && echo "Byron genesis file not found: ${BYRON_GENESIS_JSON}" && return 1
fi

[[ -z ${BLOCKLOG_DIR} ]] && BLOCKLOG_DIR="${CNODE_HOME}/guild-db/blocklog"
BLOCKLOG_DB="${BLOCKLOG_DIR}/blocklog.db"
[[ -z ${BLOCKLOG_TZ} ]] && BLOCKLOG_TZ="UTC"
[[ -z ${CNODE_PORT} ]] && CNODE_PORT=6000
[[ -z "${IP_VERSION}" ]] && IP_VERSION=4
IP_VERSION=$(tr '[:upper:]' '[:lower:]' <<< "${IP_VERSION}")

CNODE_PID=$(pgrep -fn "[c]ardano-node.*.--port ${CNODE_PORT}")

if [[ -n "${CNODE_PID}" ]]; then
  if [[ "${USE_EKG}" == "N" ]]; then
    if { [[ "${use_lsof}" != 'Y' && -z "$(ss -lnpt | grep "pid=${CNODE_PID}," | awk -v port=":${PROM_PORT}" '$4 ~ port {print $4}')" ]]; } || { [[ "${use_lsof}" == 'Y' && -z "$(lsof -Pnl -i4 +M | grep LISTEN | awk -v pid="${CNODE_PID}" -v port=":${PROM_PORT}" '$2 == pid && $9 ~ port {print $9}')" ]]; }; then
      echo "ERROR: You specified ${PROM_PORT} as your Prometheus port, but it looks like the cardano-node (PID: ${CNODE_PID} ) is not listening on this port. Please update the config or kill the conflicting process first."
      return 1
    fi
  else
    if { [[ "${use_lsof}" != 'Y' && -z "$(ss -lnpt | grep "pid=${CNODE_PID}," | awk -v port=":${EKG_PORT}" '$4 ~ port {print $4}')" ]]; } || { [[ "${use_lsof}" == 'Y' && -z "$(lsof -Pnl -i4 +M | grep LISTEN | awk -v pid="${CNODE_PID}" -v port=":${EKG_PORT}" '$2 == pid && $9 ~ port {print $9}')" ]]; }; then
      echo "ERROR: You specified ${EKG_PORT} as your EKG port, but it looks like the cardano-node (PID: ${CNODE_PID} ) is not listening on this port. Please update the config or kill the conflicting process first."
      return 1
    fi
  fi
fi

[[ -z ${TOPOLOGY} ]] && TOPOLOGY="${CNODE_HOME}/files/topology.json"
[[ -n ${CNODE_TOPOLOGY} ]] && TOPOLOGY="${CNODE_TOPOLOGY}" # compatibility with older topologyUpdater
[[ -z ${LOG_DIR} ]] && LOG_DIR="${CNODE_HOME}/logs"
[[ -n ${CNODE_LOG_DIR} ]] && LOG_DIR="${CNODE_LOG_DIR}" # compatibility with older topologyUpdater
[[ -z ${DB_DIR} ]] && DB_DIR="${CNODE_HOME}/db"
[[ -z ${TMP_DIR} ]] && TMP_DIR="/tmp/$(basename "${CNODE_HOME}")"
if ! mkdir -p "${TMP_DIR}" 2>/dev/null; then echo "ERROR: Failed to create directory for temporary files, please set TMP_DIR to a valid folder in 'env', current folder: ${TMP_DIR}" && exit 1; fi
[[ -z ${TIMEOUT_LEDGER_STATE} ]] && TIMEOUT_LEDGER_STATE=300
[[ -z ${WALLET_FOLDER} ]] && WALLET_FOLDER="${CNODE_HOME}/priv/wallet"
[[ -z ${POOL_FOLDER} ]] && POOL_FOLDER="${CNODE_HOME}/priv/pool"
[[ -z ${POOL_NAME} ]] && POOL_NAME="CHANGE_ME"
[[ -z ${POOL_DIR} ]] && POOL_DIR="${POOL_FOLDER}/${POOL_NAME}"
[[ -z ${WALLET_PAY_VK_FILENAME} ]] && WALLET_PAY_VK_FILENAME="payment.vkey"
[[ -z ${WALLET_PAY_SK_FILENAME} ]] && WALLET_PAY_SK_FILENAME="payment.skey"
[[ -z ${WALLET_HW_PAY_SK_FILENAME} ]] && WALLET_HW_PAY_SK_FILENAME="payment.hwsfile"
[[ -z ${WALLET_PAY_ADDR_FILENAME} ]] && WALLET_PAY_ADDR_FILENAME="payment.addr"
[[ -z ${WALLET_BASE_ADDR_FILENAME} ]] && WALLET_BASE_ADDR_FILENAME="base.addr"
[[ -z ${WALLET_STAKE_VK_FILENAME} ]] && WALLET_STAKE_VK_FILENAME="stake.vkey"
[[ -z ${WALLET_STAKE_SK_FILENAME} ]] && WALLET_STAKE_SK_FILENAME="stake.skey"
[[ -z ${WALLET_HW_STAKE_SK_FILENAME} ]] && WALLET_HW_STAKE_SK_FILENAME="stake.hwsfile"
[[ -z ${WALLET_STAKE_ADDR_FILENAME} ]] && WALLET_STAKE_ADDR_FILENAME="reward.addr"
[[ -z ${WALLET_STAKE_CERT_FILENAME} ]] && WALLET_STAKE_CERT_FILENAME="stake.cert"
[[ -z ${WALLET_STAKE_DEREG_FILENAME} ]] && WALLET_STAKE_DEREG_FILENAME="stake.dereg"
[[ -z ${WALLET_DELEGCERT_FILENAME} ]] && WALLET_DELEGCERT_FILENAME="delegation.cert"
[[ -z ${POOL_ID_FILENAME} ]] && POOL_ID_FILENAME="pool.id"
[[ -z ${POOL_HOTKEY_VK_FILENAME} ]] && POOL_HOTKEY_VK_FILENAME="hot.vkey"
[[ -z ${POOL_HOTKEY_SK_FILENAME} ]] && POOL_HOTKEY_SK_FILENAME="hot.skey"
[[ -z ${POOL_COLDKEY_VK_FILENAME} ]] && POOL_COLDKEY_VK_FILENAME="cold.vkey"
[[ -z ${POOL_COLDKEY_SK_FILENAME} ]] && POOL_COLDKEY_SK_FILENAME="cold.skey"
[[ -z ${POOL_OPCERT_COUNTER_FILENAME} ]] && POOL_OPCERT_COUNTER_FILENAME="cold.counter"
[[ -z ${POOL_OPCERT_FILENAME} ]] && POOL_OPCERT_FILENAME="op.cert"
[[ -z ${POOL_VRF_VK_FILENAME} ]] && POOL_VRF_VK_FILENAME="vrf.vkey"
[[ -z ${POOL_VRF_SK_FILENAME} ]] && POOL_VRF_SK_FILENAME="vrf.skey"
[[ -z ${POOL_CONFIG_FILENAME} ]] && POOL_CONFIG_FILENAME="pool.config"
[[ -z ${POOL_REGCERT_FILENAME} ]] && POOL_REGCERT_FILENAME="pool.cert"
[[ -z ${POOL_CURRENT_KES_START} ]] && POOL_CURRENT_KES_START="kes.start"
[[ -z ${POOL_DEREGCERT_FILENAME} ]] && POOL_DEREGCERT_FILENAME="pool.dereg"
[[ -z ${ASSET_FOLDER} ]] && ASSET_FOLDER="${CNODE_HOME}/priv/asset"
[[ -z ${ASSET_POLICY_VK_FILENAME} ]] && ASSET_POLICY_VK_FILENAME="policy.vkey"
[[ -z ${ASSET_POLICY_SK_FILENAME} ]] && ASSET_POLICY_SK_FILENAME="policy.skey"
[[ -z ${ASSET_POLICY_SCRIPT_FILENAME} ]] && ASSET_POLICY_SCRIPT_FILENAME="policy.script"
[[ -z ${ASSET_POLICY_ID_FILENAME} ]] && ASSET_POLICY_ID_FILENAME="policy.id"

node_version="$(${CCLI} version | head -1 | cut -d' ' -f2)"
if ! versionCheck "1.26.0" "${node_version}"; then
  echo -e "\nGuild scripts has now been upgraded to support cardano-node 1.26.0 or higher (${node_version} found).\nPlease update cardano-node (note that you should ideally update your config too) or use tagged branches for older node version.\n\n"
  return 1
fi

PROTOCOL=$(jq -r .Protocol "${CONFIG}")
NETWORKID=$(jq -r .networkId ${GENESIS_JSON})
MAGIC=$(jq -r .protocolMagicId < ${GENESIS_JSON})
NWMAGIC=$(jq -r .networkMagic < ${GENESIS_JSON})
[[ ${NETWORKID} = "Mainnet" ]] && HASH_IDENTIFIER="--mainnet" || HASH_IDENTIFIER="--testnet-magic ${NWMAGIC}"
case ${NWMAGIC} in
  764824073) NETWORK_NAME="Mainnet"; [[ -z ${SHELLEY_TRANS_EPOCH} ]] && SHELLEY_TRANS_EPOCH=208; NETWORK_IDENTIFIER="--mainnet" ;;
  1097911063) NETWORK_NAME="Testnet"; [[ -z ${SHELLEY_TRANS_EPOCH} ]] && SHELLEY_TRANS_EPOCH=74; NETWORK_IDENTIFIER="--testnet-magic ${NWMAGIC}" ;;
  633343913) NETWORK_NAME="Staging"; [[ -z ${SHELLEY_TRANS_EPOCH} ]] && SHELLEY_TRANS_EPOCH=208; NETWORK_IDENTIFIER="--testnet-magic ${NWMAGIC}" ;;
  141) NETWORK_NAME="Guild"; [[ -z ${SHELLEY_TRANS_EPOCH} ]] && SHELLEY_TRANS_EPOCH=1; NETWORK_IDENTIFIER="--testnet-magic ${NWMAGIC}" ;;
  *) NETWORK_NAME="Custom"; [[ -z ${SHELLEY_TRANS_EPOCH} ]] && SHELLEY_TRANS_EPOCH=-1; NETWORK_IDENTIFIER="--testnet-magic ${NWMAGIC}" ;;
esac

SHELLEY_GENESIS_START_SEC=$(date --date="$(jq -r .systemStart "${GENESIS_JSON}")" +%s)
EPOCH_LENGTH=$(jq -r .epochLength "${GENESIS_JSON}")
SLOT_LENGTH=$(jq -r .slotLength "${GENESIS_JSON}")
ACTIVE_SLOTS_COEFF=$(jq -r .activeSlotsCoeff "${GENESIS_JSON}")
SLOTS_PER_KES_PERIOD=$(jq -r .slotsPerKESPeriod "${GENESIS_JSON}")
MAX_KES_EVOLUTIONS=$(jq -r .maxKESEvolutions "${GENESIS_JSON}")
BYRON_GENESIS_START_SEC=$(jq -r .startTime "${BYRON_GENESIS_JSON}")
BYRON_K=$(jq -r .protocolConsts.k "${BYRON_GENESIS_JSON}")
BYRON_SLOT_LENGTH=$(( $(jq -r .blockVersionData.slotDuration "${BYRON_GENESIS_JSON}") ))
BYRON_EPOCH_LENGTH=$(( 10 * BYRON_K ))

FG_BLACK='\e[30m'
FG_RED='\e[31m'
FG_GREEN='\e[32m'
FG_YELLOW='\e[33m'
FG_BLUE='\e[34m'
FG_MAGENTA='\e[35m'
FG_CYAN='\e[36m'
FG_LGRAY='\e[37m'
FG_DGRAY='\e[90m'
FG_LBLUE='\e[94m'
FG_WHITE='\e[97m'
STANDOUT='\e[7m'
BOLD='\e[1m'
NC='\e[0m'

# Description : Query user for yes or no answer
getAnswer() {
  printf "$* (yes/no): " >&2; read -r answer
  while : ; do
    case $answer in
      [Yy]*) return 0 ;;
      [Nn]*) return 1 ;;
      *) printf "%s" "Please enter 'yes' or 'no' to continue: " >&2; read -r answer
    esac
  done
}

# Description : Wait for any key press before proceeding and clear screen
waitToProceed() {
  printf "\npress any key to proceed..."
  read -r -n 1 -s wait
  clear
}

# Description : Helper function to validate that input is a number
#             : $1 = number
isNumber() {
  [[ -z $1 ]] && return 1
  [[ $1 =~ ^[0-9]+$ ]] && return 0 || return 1
}

# Description : Helper function to validate IPv4 address
#             : $1 = IP
isValidIPv4() {
  local ip=$1
  [[ -z ${ip} ]] && return 1
  if [[ ${ip} =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ || ${ip} =~ ^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$ ]]; then 
    return 0
  fi
  return 1
}

# Description : Helper function to validate IPv6 address, works for normal IPv6 addresses, not dual incl IPv4
#             : $1 = IP
isValidIPv6() {
  local ip=$1
  [[ -z ${ip} ]] && return 1
  ipv6_regex="^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$"
  [[ ${ip} =~ ${ipv6_regex} ]] && return 0
  return 1
}

# Description : Helper function to validate if IP address is in a private range
#             : $1 = IP
isPrivateIP() {
  local ip=$1
  [[ -z ${ip} ]] && return 1
  private_ip_regex="^(127\.|0?10\.|172\.0?1[6-9]\.|172\.0?2[0-9]\.|172\.0?3[0-2]\.|192\.168\.|169\.254\.|::1|[fF][cCdD][0-9a-fA-F]{2}:|[fF][eE][89aAbB][0-9a-fA-F]:)"
  [[ ${ip} =~ ${private_ip_regex} ]] && return 0
  return 1
}

# Description : Query cardano-node for current metrics
[[ -z ${USE_EKG} ]] && USE_EKG='N'
getNodeMetrics() {
  if [[ ${USE_EKG} = 'Y' ]]; then
    node_metrics=$(curl -s -m ${EKG_TIMEOUT} -H 'Accept: application/json' "http://${EKG_HOST}:${EKG_PORT}/" 2>/dev/null)
    node_metrics_tsv=$(jq -r '[
    .cardano.node.metrics.blockNum.int.val //0,
    .cardano.node.metrics.epoch.int.val //0,
    .cardano.node.metrics.slotInEpoch.int.val //0,
    .cardano.node.metrics.slotNum.int.val //0,
    .cardano.node.metrics.density.real.val //"-",
    .cardano.node.metrics.txsProcessedNum.int.val //0,
    .cardano.node.metrics.txsInMempool.int.val //0,
    .cardano.node.metrics.mempoolBytes.int.val //0,
    .cardano.node.metrics.currentKESPeriod.int.val //0,
    .cardano.node.metrics.remainingKESPeriods.int.val //0,
    .cardano.node.metrics.Forge["node-is-leader"].int.val //0,
    .cardano.node.metrics.Forge.adopted.int.val //0,
    .cardano.node.metrics.Forge["didnt-adopt"].int.val //0,
    .cardano.node.metrics.Forge["forge-about-to-lead"].int.val //0,
    .cardano.node.metrics.nodeStartTime.int.val //0
    ] | @tsv' <<< "${node_metrics}")
    read -ra node_metrics_arr <<< ${node_metrics_tsv}
    blocknum=${node_metrics_arr[0]}; epochnum=${node_metrics_arr[1]}; slot_in_epoch=${node_metrics_arr[2]}; slotnum=${node_metrics_arr[3]}
    [[ ${node_metrics_arr[4]} != '-' ]] && density=$(bc <<< "scale=3;$(printf '%3.5f' "${node_metrics_arr[4]}")*100/1") || density=0.0
    tx_processed=${node_metrics_arr[5]}; mempool_tx=${node_metrics_arr[6]}; mempool_bytes=${node_metrics_arr[7]}
    kesperiod=${node_metrics_arr[8]}; remaining_kes_periods=${node_metrics_arr[9]}
    isleader=${node_metrics_arr[10]}; adopted=${node_metrics_arr[11]}; didntadopt=${node_metrics_arr[12]}; about_to_lead=${node_metrics_arr[13]}
    uptimes=$(( $(date +%s) - node_metrics_arr[14] ))
  else
    node_metrics=$(curl -s -m ${EKG_TIMEOUT} "http://${PROM_HOST}:${PROM_PORT}/metrics" 2>/dev/null)
    [[ ${node_metrics} =~ cardano_node_metrics_nodeStartTime_int[[:space:]]([^[:space:]]*) ]] && uptimes=$(( $(date +%s) - BASH_REMATCH[1] )) || uptimes=0
    [[ ${node_metrics} =~ cardano_node_metrics_blockNum_int[[:space:]]([^[:space:]]*) ]] && blocknum=${BASH_REMATCH[1]} || blocknum=0
    [[ ${node_metrics} =~ cardano_node_metrics_epoch_int[[:space:]]([^[:space:]]*) ]] && epochnum=${BASH_REMATCH[1]} || epochnum=0
    [[ ${node_metrics} =~ cardano_node_metrics_slotInEpoch_int[[:space:]]([^[:space:]]*) ]] && slot_in_epoch=${BASH_REMATCH[1]} || slot_in_epoch=0
    [[ ${node_metrics} =~ cardano_node_metrics_slotNum_int[[:space:]]([^[:space:]]*) ]] && slotnum=${BASH_REMATCH[1]} || slotnum=0
    [[ ${node_metrics} =~ cardano_node_metrics_density_real[[:space:]]([^[:space:]]*) ]] && density=$(bc <<< "scale=3;$(printf '%3.5f' "${BASH_REMATCH[1]}")*100/1") || density=0.0
    [[ ${node_metrics} =~ cardano_node_metrics_txsProcessedNum_int[[:space:]]([^[:space:]]*) ]] && tx_processed=${BASH_REMATCH[1]} || tx_processed=0
    [[ ${node_metrics} =~ cardano_node_metrics_txsInMempool_int[[:space:]]([^[:space:]]*) ]] && mempool_tx=${BASH_REMATCH[1]} || mempool_tx=0
    [[ ${node_metrics} =~ cardano_node_metrics_mempoolBytes_int[[:space:]]([^[:space:]]*) ]] && mempool_bytes=${BASH_REMATCH[1]} || mempool_bytes=0
    [[ ${node_metrics} =~ cardano_node_metrics_currentKESPeriod_int[[:space:]]([^[:space:]]*) ]] && kesperiod=${BASH_REMATCH[1]} || kesperiod=0
    [[ ${node_metrics} =~ cardano_node_metrics_remainingKESPeriods_int[[:space:]]([^[:space:]]*) ]] && remaining_kes_periods=${BASH_REMATCH[1]} || remaining_kes_periods=0
    [[ ${node_metrics} =~ cardano_node_metrics_Forge_node_is_leader_int[[:space:]]([^[:space:]]*) ]] && isleader=${BASH_REMATCH[1]} || isleader=0
    [[ ${node_metrics} =~ cardano_node_metrics_Forge_adopted_int[[:space:]]([^[:space:]]*) ]] && adopted=${BASH_REMATCH[1]} || adopted=0
    [[ ${node_metrics} =~ cardano_node_metrics_Forge_didnt_adopt_int[[:space:]]([^[:space:]]*) ]] && didntadopt=${BASH_REMATCH[1]} || didntadopt=0
    [[ ${node_metrics} =~ cardano_node_metrics_Forge_forge_about_to_lead_int[[:space:]]([^[:space:]]*) ]] && about_to_lead=${BASH_REMATCH[1]} || about_to_lead=0
  fi
}

# Description : Get shelley transition epoch for non-predefined networks
getShelleyTransitionEpoch() {
  [[ ${SHELLEY_TRANS_EPOCH} -ge 0 ]] && return 0
  calc_slot=0
  byron_epochs=${epochnum}
  shelley_epochs=0
  while [[ ${byron_epochs} -ge 0 ]]; do
    calc_slot=$(( (byron_epochs * BYRON_EPOCH_LENGTH) + (shelley_epochs * EPOCH_LENGTH) + slot_in_epoch ))
    [[ ${calc_slot} -eq ${slotnum} ]] && break
    ((byron_epochs--))
    ((shelley_epochs++))
  done
  if [[ ${calc_slot} -ne ${slotnum} || ${shelley_epochs} -eq 0 ]]; then
    SHELLEY_TRANS_EPOCH=-1
    return 1
  else
    SHELLEY_TRANS_EPOCH=${byron_epochs}
    return 0
  fi
}
[[ ${OFFLINE_MODE} = "N" && ${SHELLEY_TRANS_EPOCH} -eq -1 ]] && getNodeMetrics && getShelleyTransitionEpoch

# Description : Offline calculation of current epoch based on genesis file
getEpoch() {
  current_time_sec=$(printf '%(%s)T\n' -1)
  [[ ${SHELLEY_TRANS_EPOCH} -eq -1 ]] && echo 0 && return
  byron_end_time=$(( BYRON_GENESIS_START_SEC + ((SHELLEY_TRANS_EPOCH * BYRON_EPOCH_LENGTH * BYRON_SLOT_LENGTH) / 1000) ))
  echo $(( SHELLEY_TRANS_EPOCH + ( (current_time_sec - byron_end_time) / SLOT_LENGTH / EPOCH_LENGTH ) ))
}

# Description : Offline calculation of current epoch based on provided slot number
getEpochFromSlot() {
  echo $(( SHELLEY_TRANS_EPOCH + (($1 - (SHELLEY_TRANS_EPOCH * BYRON_EPOCH_LENGTH)) / EPOCH_LENGTH) ))
}

# Description : Offline calculation of current slot in epoch based on provided slot number and epoch
getSlotInEpochFromSlot() {
  echo $(( $1 - ((SHELLEY_TRANS_EPOCH * BYRON_EPOCH_LENGTH) + (($2 - SHELLEY_TRANS_EPOCH) * EPOCH_LENGTH)) ))
}

# Description : Offline calculation of date based on provided slot number
#             : $1 = slot, $2 = (optional) printf date format
getDateFromSlot() {
  byron_slots=$(( SHELLEY_TRANS_EPOCH * BYRON_EPOCH_LENGTH ))
  [[ -n $2 ]] && date_fmt="$2" || date_fmt='%(%FT%T%z)T'
  printf -v date_from_slot "${date_fmt}" $(( ((byron_slots * BYRON_SLOT_LENGTH) / 1000) + (($1-byron_slots) * SLOT_LENGTH) + SHELLEY_GENESIS_START_SEC ))
  [[ -n $2 ]] && echo "${date_from_slot}" || echo "${date_from_slot%??}:${date_from_slot: -2}"
}

# Description : Offline calculation of time in seconds until next epoch
timeUntilNextEpoch() {
  current_time_sec=$(printf '%(%s)T\n' -1)
  [[ ${SHELLEY_TRANS_EPOCH} -eq -1 ]] && echo 0 && return
  echo $(( ((SHELLEY_TRANS_EPOCH * BYRON_SLOT_LENGTH * BYRON_EPOCH_LENGTH) / 1000) + (($(getEpoch) + 1 - SHELLEY_TRANS_EPOCH) * SLOT_LENGTH * EPOCH_LENGTH) - current_time_sec + BYRON_GENESIS_START_SEC ))
}

# Description : Calculation of days, hours, minutes and seconds from time in seconds
timeLeft() {
  local T=$1
  local D=$((T/60/60/24))
  local H=$((T/60/60%24))
  local M=$((T/60%60))
  local S=$((T%60))
  (( D > 0 )) && printf '%dd ' $D
  printf '%02d:%02d:%02d' $H $M $S
}

# Description : Get calculated slot number tip
getSlotTipRef() {
  current_time_sec=$(printf '%(%s)T\n' -1)
  [[ ${SHELLEY_TRANS_EPOCH} -eq -1 ]] && echo 0 && return
  byron_slots=$(( SHELLEY_TRANS_EPOCH * BYRON_EPOCH_LENGTH ))
  byron_end_time=$(( BYRON_GENESIS_START_SEC + ((SHELLEY_TRANS_EPOCH * BYRON_EPOCH_LENGTH * BYRON_SLOT_LENGTH) / 1000) ))
  if [[ ${current_time_sec} -lt ${byron_end_time} ]]; then # In Byron phase
    echo $(( ((current_time_sec - BYRON_GENESIS_START_SEC)*1000) / BYRON_SLOT_LENGTH ))
  else # In Shelley phase
    echo $(( byron_slots + (( current_time_sec - byron_end_time ) / SLOT_LENGTH ) ))
  fi
}

# Command     : getCurrentKESperiod
# Description : Offline calculation of current KES period based on reference tip
getCurrentKESperiod() {
  tip_ref=$(getSlotTipRef)
  echo $(( tip_ref / SLOTS_PER_KES_PERIOD ))
}

# Description : Calculate expected interval between blocks
slotInterval() {
  if [[ -z ${DECENTRALISATION} || $(echo "${DECENTRALISATION} < 0.5" | bc) -eq 1 ]]; then d=0.5; else d=${DECENTRALISATION}; fi
  echo "(${SLOT_LENGTH} / ${ACTIVE_SLOTS_COEFF} / ${d}) + 0.5" | bc -l | awk '{printf "%.0f\n", $1}'
}

# Description : Identify current era and set variables accordingly
getEraIdentifier() {
    if ${CCLI} query protocol-parameters --byron-era ${NETWORK_IDENTIFIER} &>/dev/null; then ERA_IDENTIFIER="--byron-era"
  elif ${CCLI} query protocol-parameters --shelley-era ${NETWORK_IDENTIFIER} &>/dev/null; then ERA_IDENTIFIER="--shelley-era"
  elif ${CCLI} query protocol-parameters --allegra-era ${NETWORK_IDENTIFIER} &>/dev/null; then ERA_IDENTIFIER="--allegra-era"
  elif ${CCLI} query protocol-parameters --mary-era ${NETWORK_IDENTIFIER} &>/dev/null; then ERA_IDENTIFIER="--mary-era"
  else 
    ERA_IDENTIFIER=""
    [[ ${OFFLINE_MODE} = "N" ]] && return 1
  fi
  return 0
}

# Return code 2 is used for scripts that want to source env but not fail due to a starting node

if [[ ${OFFLINE_MODE} = "N" && ! -S ${CARDANO_NODE_SOCKET_PATH} ]]; then
  echo -e "${FG_RED}Looks like cardano-node is running with socket-path as ${FG_LBLUE}${CARDANO_NODE_SOCKET_PATH}${FG_RED}, but the actual socket file does not exist."
  echo -e "This could occur if the node hasnt completed startup or if a second instance of node startup was attempted!"
  echo -e "If this does not resolve automatically in a few minutes, you might want to restart your node and try again.${NC}"
  return 2
fi

if ! PROT_PARAMS="$(${CCLI} query protocol-parameters ${NETWORK_IDENTIFIER} 2>&1)"; then echo -e "${FG_RED}Failed to query protocol-parameters from node, not yet fully started?${NC}" && return 2; fi

if ! DECENTRALISATION=$(jq -er .decentralization <<< ${PROT_PARAMS} 2>/dev/null); then DECENTRALISATION=0.5; fi

return 0
