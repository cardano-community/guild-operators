#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2086,SC2230,SC2206,SC2140,SC2059,SC2154

######################################
# Do NOT modify code below           #
######################################

############################################################
# Variables to keep counter for versions                   #
############################################################
# The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
# and this adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
# Major: Any considerable change in the code base, big feature, workflow or breaking change from previous version
CNTOOLS_MAJOR_VERSION=13
# Minor: Changes and features of minor character that can be applied without breaking existing functionality or workflow
CNTOOLS_MINOR_VERSION=3
# Patch: Backwards compatible bug fixes. No additional functionality or major changes
CNTOOLS_PATCH_VERSION=2

CNTOOLS_VERSION="${CNTOOLS_MAJOR_VERSION}.${CNTOOLS_MINOR_VERSION}.${CNTOOLS_PATCH_VERSION}"
DUMMYFEE=20000

############################################################
# Default config values                                    #
# overriden by values set in cntools.sh                    #
############################################################
TMP_DIR="${TMP_DIR}/cntools"
if ! mkdir -p "${TMP_DIR}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create directory for temporary files: ${TMP_DIR}"; fi
if ! mkdir -p "${WALLET_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create wallet directory: ${WALLET_FOLDER}"; fi
if ! mkdir -p "${POOL_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create pool directory: ${POOL_FOLDER}"; fi
if ! mkdir -p "${ASSET_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create asset directory: ${POOL_ASSET}"; fi
[[ -z ${CNTOOLS_MODE} ]] && CNTOOLS_MODE=LOCAL || CNTOOLS_MODE=${CNTOOLS_MODE^^}
if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
  CNTOOLS_MODE_COLOR="${FG_BLUE}"
elif [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
  CNTOOLS_MODE_COLOR="${FG_GREEN}"
else
  CNTOOLS_MODE_COLOR="${FG_GRAY}"
fi
printf -v launch_modes_info "${FG_BLUE}INFO${NC}: Available launch modes, re-run CNTools in
  ${CNTOOLS_MODE_COLOR}LOCAL${NC} mode (-n): Default mode with a local node connection.
  ${CNTOOLS_MODE_COLOR}LIGHT${NC} mode (-l): Utilizing Koios query layer with full functionallity for supported networks.
  ${CNTOOLS_MODE_COLOR}OFFLINE${NC} mode (-o): A limited set of functionallity without external communication useful for air-gapped mode."
[[ -z ${TIMEOUT_NO_OF_SLOTS} ]] && TIMEOUT_NO_OF_SLOTS=600
[[ -z ${TX_TTL} ]] && TX_TTL=3600
[[ -z ${WALLET_SELECTION_FILTER_LIMIT} ]] && WALLET_SELECTION_FILTER_LIMIT=10
[[ -z ${KES_ALERT_PERIOD} ]] && KES_ALERT_PERIOD=172800 # default 2 days
[[ -z ${KES_WARNING_PERIOD} ]] && KES_WARNING_PERIOD=604800 # default 7 days
[[ $(uname) == Darwin ]] && ENABLE_CHATTR=false
[[ -z ${ENABLE_CHATTR} ]] && ENABLE_CHATTR=true
[[ -z ${ENABLE_DIALOG} ]] && ENABLE_DIALOG=false
[[ ${ENABLE_ADVANCED} = "true" ]] && ADVANCED_MODE="true"
[[ -z ${CHECK_KES} ]] && CHECK_KES=true
[[ -z ${CATALYST_API} ]] && CATALYST_API=https://api.projectcatalyst.io/api/v1
[[ -z ${EXPLORER_TX} ]] && EXPLORER_TX=https://adastat.net/transactions/__tx_id__
[[ -z ${CNTOOLS_LOG} ]] && CNTOOLS_LOG="${LOG_DIR}/cntools-history.log"
[[ -z ${CURRENCY} ]] && CURRENCY="off" || CURRENCY=${CURRENCY,,}
[[ ${CURRENCY} = off || ${NETWORK_NAME} != Mainnet ]] && unset CURRENCY_URL || CURRENCY_URL="https://api.coingecko.com/api/v3/simple/price?ids=cardano&vs_currencies=${CURRENCY}&include_24hr_change=true"

############################################################
# library sourced by cntools with common taskes to perform #
############################################################

# Assumes that env has been sourced by calling script

# Command     : logln [log level] [message]
# Description : write message to log file with log level specified
logln() {
  local log_level=$1
  shift
  [[ -z $1 ]] && return
  echo -e "$@" | while read -r log_line; do
    log_line=$(sed -E 's/\x1b(\[[0-9;]*[a-zA-Z]|[0-9])//g' <<< ${log_line##*( )})
    [[ -z ${log_line} ]] && continue
    printf '%s %-8s %s\n' "$(date "+%F %T %Z")" "[${log_level}]" "${log_line}" >> "${CNTOOLS_LOG}"
  done
}

# Command     : println [log level] [newline] [message]
# Description : print and log(if enabled) message
# Parameters  : log level  >  log level (default: INFO)
#                             OFF    : logging disabled, output only to tty
#                             LOG    : logged as DEBUG but not printed to tty
#                             DEBUG  : verbose output, logged and printed to tty
#                             INFO   : normal output printed to tty and logged
#                             ACTION : e.g cardano-cli executions etc, logged but not printed to tty
#                             ERROR  : stderr output and error messages
#             : newline    >  Add a newline at the end for tty output (default true) 
#             : message    >  The message to print/log
println() {  
  local log_level=$1
  shift
  local newline="\n"
  if [[ $1 = false && $# -gt 2 ]]; then unset newline; shift; elif [[ $1 = true && $# -gt 2 ]]; then shift; fi
  local msg_list=()
  for msg in "$@"; do
    [[ -z ${msg} ]] && continue
    msg_list+=( "${msg}" )
  done
  case $log_level in
    OFF) printf "%b${newline}" "${msg_list[@]}" ;;
    LOG) logln "DEBUG" "${msg_list[@]}" ;;
    DEBUG) printf "%b${newline}" "${msg_list[@]}"; logln "DEBUG" "${msg_list[@]}" ;;
    INFO) printf "%b${newline}" "${msg_list[@]}"; logln "INFO" "${msg_list[@]}" ;;
    ACTION) logln "ACTION" "${msg_list[@]}" ;;
    ERROR) printf "%b${newline}" "${msg_list[@]}"; logln "ERROR" "${msg_list[@]}" ;;
    *) println INFO "${log_level}" "${msg_list[@]}" ;;
  esac
}

# Command     : getAnswerAnyCust [variable name] [log] [question]
# Description : wrapper function for getAnswerAny() in env to read input from stdin 
#               and save response into provided variable name while also logging response
# Parameters  : variable name  >  the name of the variable to save users response into
#             : log            >  [true|false] log question (default: true)
#             : question       >  what to ask user to input
getAnswerAnyCust() {
  var_name=$1
  shift
  local log_question=true
  if [[ $1 =~ true|false ]]; then
    [[ $1 = false ]] && log_question=false
    shift
  fi
  getAnswerAny "${var_name}" "$*"
  [[ ${log_question} = true ]] && println LOG "$*: ${!var_name}"
}

# Command     : archiveLog
# Description : archive old log file and clean archive folder keeping last 10 log files
archiveLog() {
  [[ -z ${CNTOOLS_LOG} ]] && return
  log_archive="$(dirname "${CNTOOLS_LOG}")/archive"
  log_file="$(basename "${CNTOOLS_LOG}")"
  mkdir -p "${log_archive}"
  [[ -f ${CNTOOLS_LOG} ]] && mv -f "${CNTOOLS_LOG}" "${log_archive}/${log_file}_$(date +%s)"
  find "${log_archive}" -maxdepth 1 -type f -name "${log_file}*" -printf '%Ts\t%p\n' | sort -n | head -n -10 | cut -f 2- | xargs rm -rf
}

# Command     : protectionPreRequisites
# Description : Check if needed protection prerequisites is available, else print error
protectionPreRequisites() {
  ! cmdAvailable "gpg" && return 1

  if ! cmdAvailable "chattr" &>/dev/null; then
    [[ ${ENABLE_CHATTR} = true ]] && echo -e "chattr command not available but enabled in config, please install or disable in cntools.sh and re-run CNTools" && return 1
  elif [[ ${ENABLE_CHATTR} = true ]]; then # chattr available and enabled, make sure sudo access to chattr is enabled
    touch "${TMP_DIR}"/test
    echo -e "Testing chattr access permission, enter user password if requested..."
    if ! sudo chattr -i "${TMP_DIR}"/test; then
      rm -f "${TMP_DIR}"/test
      echo -e "\n${FG_YELLOW}WARN${NC}: Elevated privileges needed for chattr command used to write protect wallet and pool keys"
      echo -e "Add required sudo permissions or run the following command to add passwordless sudo access to chattr command for '$(whoami)' user"
      echo -e "echo \"$(whoami) ALL=NOPASSWD: $(command -v chattr)\" | sudo tee /etc/sudoers.d/cntools"
      return 1
    fi
    rm -f "${TMP_DIR}"/test
  fi
  return 0
}

# Command     : download_catalyst_toolbox
# Description : Downloads Catalyst Toolbox
download_catalyst_toolbox() {
  cmdAvailable "catalyst-toolbox" &>/dev/null && return 0
  println DEBUG "Downloading prerequisite tool: catalyst-toolbox"
  local ARCH; ARCH=$(uname -a)
  if [[ ${ARCH,,} != *x86_64*linux* ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Only x86_64 architecture on Linux supported, please manually build for your system from:\nhttps://github.com/input-output-hk/catalyst-core"
    waitToProceed && return 1
  fi
  rm -rf /tmp/catalyst-toolbox-bin && mkdir /tmp/catalyst-toolbox-bin
  pushd /tmp/catalyst-toolbox-bin >/dev/null || return 1
  if curl -sL -f -m ${CURL_TIMEOUT} -o "${HOME}"/.local/bin/catalyst-toolbox "https://share.koios.rest/api/public/dl/xFdZDfM4%2Fbin%2Fcatalyst-toolbox"; then
    chmod +x "${HOME}"/.local/bin/catalyst-toolbox
    local catalyst_toolbox_version; catalyst_toolbox_version=$(catalyst-toolbox --full-version)
    println DEBUG "  ${catalyst_toolbox_version%% - *} ${FG_GREEN}installed!${NC}"
  else
    println ERROR "\n${FG_RED}ERROR${NC}: Download of Catalyst Toolbox from Koios share failed! Please retry or build it manually from:\nhttps://github.com/input-output-hk/catalyst-core"
    waitToProceed && return 1
  fi
  return 0
}

# Command     : generateCatalystBech32 [wallet name]
# Description : create and store Catalyst signing key in bech32 format (ed25519extended)
# Parameters  : wallet name  >  the name of the wallet
generateCatalystBech32() {
  catalyst_sk_file="${WALLET_FOLDER}/${1}/${WALLET_CATALYST_SK_FILENAME}"
  catalyst_sk_file_bech32="${catalyst_sk_file}-bech32"
  [[ -f "${catalyst_sk_file_bech32}" ]] && return 0
  println ACTION "jq -r .cborHex ${catalyst_sk_file} | cut -c 5-132 | bech32 ed25519e_sk"
  if ! stdout=$(jq -r .cborHex "${catalyst_sk_file}" | cut -c 5-132 | bech32 "ed25519e_sk" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during catalyst signing key bech32 conversion!\n${stdout}"; waitToProceed && return 1
  fi
  echo ${stdout} > "${catalyst_sk_file_bech32}"
}

# Command     : safeDel [path]
# Description : unlock and delete file|dir
# Parameters  : command  >  The command to check
safeDel() {
  path=$1
  [[ ${ENABLE_CHATTR} = true && -f "${path}" && $(lsattr -R "${path}") =~ -i- ]] && sudo chattr -i "${path}"
  if rm -rf "${path}"; then
    println "Deleted: ${path}"
  else
    println ERROR "${FG_RED}ERROR${NC}: delete failed for ${path}"
    return 1
  fi
  return 0
}

updateProtocolParams() {
  _epoch_=$(getEpoch)
  [[ -n ${current_epoch} && ${current_epoch} -eq ${_epoch_} ]] && return
  current_epoch=${_epoch_}
  getProtocolParams
  case $? in
    1) myExit 1 "${FG_YELLOW}WARN${NC}: node socket path wrongly configured or node not running, please verify that socket set in env file match what is used to run the node\n\n${launch_modes_info}" ;;
    2) myExit 1 "${FG_YELLOW}WARN${NC}: failed to query protocol parameters, ensure your node is running with correct genesis (the node needs to be in sync to 1 epoch after the hardfork)\n\nError message: ${PROT_PARAMS}\n\n${launch_modes_info}" ;;
    3) myExit 1 "${FG_YELLOW}WARN${NC}: Unable to query Koios for current epoch parameters\n\n${launch_modes_info}" ;;
  esac
  echo "${PROT_PARAMS}" > "${TMP_DIR}"/protparams.json
}

# Command     : dialogSetup
# Description : set config parameters for dialog formatting
dialogSetup() {
  export DIALOGRC="${TMP_DIR}"/.dialogrc
  [[ ! -f ${DIALOGRC} ]] && cat <<-EOF > "${TMP_DIR}"/.dialogrc
		# Types of values:
		#
		# Number     -  <number>
		# String     -  "string"
		# Boolean    -  <ON|OFF>
		# Attribute  -  (foreground,background,highlight?)
		# Set aspect-ration.
		aspect = 0
		# Set separator (for multiple widgets output).
		separate_widget = ""
		# Set tab-length (for textbox tab-conversion).
		tab_len = 0
		# Make tab-traversal for checklist, etc., include the list.
		visit_items = OFF
		# Shadow dialog boxes? This also turns on color.
		use_shadow = OFF
		# Turn color support ON or OFF
		use_colors = OFF
		# Screen color
		screen_color = (BLACK,BLACK,OFF)
		# Shadow color
		shadow_color = (BLACK,BLACK,ON)
		# Dialog box color
		dialog_color = (BLACK,BLACK,OFF)
		# Dialog box title color
		title_color = (RED,BLACK,ON)
		# Dialog box border color
		border_color = (BLACK,BLACK,OFF)
		# Active button color
		button_active_color = (WHITE,BLACK,ON)
		# Inactive button color
		button_inactive_color = (BLACK,WHITE,OFF)
		# Active button key color
		button_key_active_color = button_active_color
		# Inactive button key color
		button_key_inactive_color = (RED,BLACK,OFF)
		# Active button label color
		button_label_active_color = (YELLOW,BLACK,OFF)
		# Inactive button label color
		button_label_inactive_color = (BLACK,WHITE,ON)
		# Input box color
		inputbox_color = button_inactive_color
		# Input box border color
		inputbox_border_color = button_inactive_color
		# Item color
		item_color = button_inactive_color
		# Selected item color
		item_selected_color = button_active_color
		# Dialog box border2 color
		border2_color = button_inactive_color
		# Input box border2 color
		inputbox_border2_color = button_inactive_color
		EOF
}

# Command     : fileDialog [title] [optional: start path]
# Description : open a file dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: ${TMP_DIR}/)
fileDialog() {
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    getAnswerAnyCust file "$1" && return
  else
    println DEBUG "${1}: "
    waitToProceed "Press any key to open the file explorer [cancel to skip!]"
  fi
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="${TMP_DIR}/"
  dialog --clear --keep-tite --title "$1" --fselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)) 2>"${TMP_DIR}/dialog.out"
  file=$([[ -f "${TMP_DIR}/dialog.out" ]] && cat "${TMP_DIR}/dialog.out" || echo "")
  tput cup $(( ${ROW#*[} -1 )) $(( COL -1 ))
  println DEBUG "${FG_LGRAY}${file}${NC}"
}
# Command     : dirDialog [title] [optional: start dir]
# Description : open a directory dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: ${TMP_DIR}/)
dirDialog() {
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    getAnswerAnyCust dir "$1" && return
  else
    println DEBUG "${1}: "
    waitToProceed "Press any key to open the file explorer [cancel to skip!]"
  fi
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="${TMP_DIR}/"
  dialog --clear --keep-tite --title "$1" --dselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)) 2>"${TMP_DIR}/dialog.out"
  dir=$([[ -f "${TMP_DIR}/dialog.out" ]] && cat "${TMP_DIR}/dialog.out" || echo "")
  tput cup $(( ${ROW#*[} -1 )) $(( COL -1 ))
  println DEBUG "${FG_LGRAY}${dir}${NC}"
}


# Command     : selectOption [opt1] [opt2] ...
# Description : Create a bash menu to select one of the provided options
# Parameters  : optX  >  a list of available options to choose from
ESC=$(printf "\033")
cursor_blink_on()  { printf "${ESC}[?25h"; }
cursor_blink_off() { printf "${ESC}[?25l"; }
cursor_to()        { printf "${ESC}[$1;${2:-1}H"; }
print_option()     { printf "  $1 "; }
print_selected()   { printf " ${ESC}[7m $1 ${ESC}[27m$2"; }
get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
key_input()        { key2=""
                     read -rsn1 key1   # get 1 character
                     if [[ $key1 == "${ESC}" ]]; then
                       read -rsn2 -t 0.3 key2 # read 2 more chars, 1s timeout
                     fi
                       if [[ ${key2} = "[A" ]]; then echo up;
                     elif [[ ${key2} = "[B" ]]; then echo down;
                     elif [[ ${key1} = "${ESC}" && ${key2} = "" ]]; then echo Esc;
                     elif [[ ${key1} = ""   ]]; then echo enter;
                     else echo ${key1}; fi; }
opt_shortcut()     { [[ "$1" =~ ^\[([[:alnum:]]+)\].* ]] && echo ${BASH_REMATCH[1]}; }
opt_firstchar()    { printf "${1:0:1}" | tr '[:upper:]' '[:lower:]'; }
clrbuf()           { read -r -t 0.1 -s; stty echo echok; }
selectOption() {

  # initially print empty new lines (scroll down if at bottom of screen)
  printf "\n" && for opt; do printf "\n"; done

  # determine current screen position for overwriting the options or return -1 on failure
  clrbuf
  local startrow=-1
  for i in {1..10}; do
    local cursor_row;cursor_row=$(get_cursor_row)
    isNumber ${cursor_row} && startrow=$(( cursor_row - $# - 1 )) && break
  done
  [[ ${startrow} -eq -1 ]] && return 255

  cursor_blink_off

  local shortcut_found="no"
  local selected=0
  while true; do
    # print options by overwriting the last lines
    local idx=0
    for opt; do
      opt_part2=""
      if [[ "$opt" =~ ^(.*)[[:space:]](\(.*) ]]; then
        opt_part1="${BASH_REMATCH[1]}"
        opt_part2=" ${BASH_REMATCH[2]}"
      else
        opt_part1="$opt"
      fi
      cursor_to $(( startrow + idx ))
      if [ ${idx} -eq ${selected} ]; then
        print_selected "${opt_part1}" "${opt_part2}"
      else
        print_option "${opt_part1}${opt_part2}"
      fi
      ((idx++))
    done

    [[ "${shortcut_found}" = "yes" ]] && break

    # user key control
    key_pressed=$(key_input)
    case ${key_pressed} in
      enter) break;;
      up)    ((selected--));
             if [ ${selected} -lt 0 ]; then selected=$(($# - 1)); fi;;
      down)  ((selected++));
             if [ ${selected} -ge $# ]; then selected=0; fi;;
      *)     # shortcut available for selected key?
             i=0
             for opt; do
               [[ ${key_pressed} = $(opt_shortcut "${opt}") ]] && selected=${i} && shortcut_found="yes" && break
               ((i++))
             done
             # If no shortcut is found, lets see if it matches the first char of any of the options
             j=0
             for opt; do
               [[ "${shortcut_found}" != "yes" && ${key_pressed} = $(opt_firstchar "${opt}") ]] && selected=${j} && break
               ((j++))
             done
             ;;
    esac
  done

  # clear menu
  cursor_blink_on
  cursor_to $startrow
  tput ed
  
  return $selected
}

# Command     : select_opt [opt1] [opt2] ...
# Description : Helper function to selectOption
# Parameters  : optX  >  a list of available options to choose from
select_opt() {
  local opts=()
  for item in "$@"; do
    [[ -n ${item} ]] && opts+=("${item}")
  done
  selectOption "${opts[@]}"
  local answer=$?
  if [[ ${answer} -eq 255 ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Failed to print menu, default selection used!\n"
    return 0
  fi
  selected_value="${opts[${answer}]}"
  println DEBUG "Selected value: ${selected_value}"
  return $answer
}

# Command     : getDirs [path to folder]
# Description : A helper function to get all subdirs for a directory
# Parameters  : path to folder    >   full path to folder, subdirs of this folder returned
# Return      : populates ${dirs} array
getDirs() {
  if [[ ! -d "$1" ]]; then
    println ERROR "${FG_RED}ERROR${NC}: Missing folder: $1"
    waitToProceed && return 1
  fi
  dirs=()
  while IFS= read -r -d '' dir; do
    dirs+=("$(basename ${dir})")
  done < <(find "${1}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
  return 0
}

# Command     : selectDir [type] [dir1 dir2 ...]
# Description : A helper function to selectOption() specifically for directory selection
# Parameters  : type  >  'wallet' 'pool' 'policy' 'asset'
#             : dirX  >  array of dirs to include in selection, '[Esc] Cancel' option added to all selections
# Return      : populates ${dir_name} variable
selectDir() {
  local type=$1 && shift
  dirs=( "$@" )
  dirs+=("[Esc] Cancel")
  selectOption "${dirs[@]}"
  local answer=$?
  if [[ ${answer} -eq 255 ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Failed to print menu, please try again or report issue!"
    return 1
  fi
  dir_name=${dirs[${answer}]}
  [[ "${dir_name}" = "[Esc] Cancel" ]] && return 2
  println DEBUG "Selected ${type}: ${dir_name}"
}

# Command     : selectWallet [mode] [file1 file2 ... | wallet_name1 wallet_name1 ... ]
# Description : A helper function to select a CNTools wallet
# Parameters  : mode       >  a string containing some of the following: none|encrypted|non-reg|reg|balance|delegate|reward|assets|non-ms|non-gov to be added next to wallet in selection menu
#             : arg array  >  array of files required to exist in wallet folder for it to be selectable **OR** the name of wallet to exclude from selection
# Return      : populates ${wallet_name} variable with wallet selection
selectWallet() {

  mode=$1 && shift

  if [[ ${mode} = "cache" && ${#wallet_dirs_filtered[@]} -gt 0 ]]; then
    selectDir "wallet" "${wallet_dirs_filtered[@]}" || return $? # ${dir_name} populated by selectDir function
    wallet_name="$(echo ${dir_name} | cut -d' ' -f1)"
    return 0
  fi

  wallet_dirs=()

  if ! getDirs "${WALLET_FOLDER}"; then return 1; fi # dirs() array populated with all wallet folders
  if [[ ${CNTOOLS_MODE} != "OFFLINE" && ${mode} != "none" && ${mode} != "non-ms" && ${mode} != "non-gov" ]]; then
    tput sc
    wallet_count=${#dirs[@]}
    if [[ ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then
      if [[ -n ${KOIOS_API} ]]; then
        println OFF "${FG_YELLOW}> Querying Koios API for wallet balance${NC}"
      else
        println OFF "${FG_YELLOW}> Querying node for wallet balance${NC}"
      fi
    else
      println OFF "${FG_YELLOW}> Max wallet count exceeded for balance/filtering (${wallet_count}/${WALLET_SELECTION_FILTER_LIMIT}).\nUpdate 'WALLET_SELECTION_FILTER_LIMIT' setting to increase this limit${NC}"
    fi
  fi

  unset reward_status
  addr_list=()
  reward_addr_list=()
  declare -gA asset_cnt=()
  declare -gA balances=()
  declare -gA pool_delegations=()
  declare -gA rewards_available=()

  for dir in "${dirs[@]}"; do
    for arg in "$@"; do # check if wallet is missing a required file or name matches execution, if so hide it
      [[ ${arg} == *"."* && ! -f "${WALLET_FOLDER}/${dir}/${arg}" ]] && continue 2
      [[ ${arg} != *"."* && ${dir} = "${arg}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${WALLET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        wallet_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        wallet_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
    elif [[ ${mode} = "non-ms" ]]; then
      ms_payment_vk_file="${WALLET_FOLDER}/${dir}/${WALLET_MULTISIG_PREFIX}${WALLET_PAY_VK_FILENAME}"
      ms_stake_vk_file="${WALLET_FOLDER}/${dir}/${WALLET_MULTISIG_PREFIX}${WALLET_STAKE_VK_FILENAME}"
      if [[ -f "${ms_payment_vk_file}" || -f "${ms_stake_vk_file}" ]]; then continue; else wallet_dirs+=("${dir}"); fi
    elif [[ ${mode} = "non-gov" ]]; then
      drep_vk_file="${WALLET_FOLDER}/${dir}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_DREP_VK_FILENAME}"
      cc_cold_vk_file="${WALLET_FOLDER}/${dir}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_CC_COLD_VK_FILENAME}"
      cc_hot_vk_file="${WALLET_FOLDER}/${dir}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_CC_HOT_VK_FILENAME}"
      if [[ -f "${drep_vk_file}" || -f "${cc_cold_vk_file}" || -f "${cc_hot_vk_file}" ]]; then continue; else wallet_dirs+=("${dir}"); fi
    elif [[ ${CNTOOLS_MODE} != "OFFLINE" && ${mode} != "none" && ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then
      if [[ ${mode} = "reg" || ${mode} = "non-reg" ]]; then
        if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
          if [[ ${mode} = "reg" ]]; then
            ! isWalletRegistered ${dir} && continue
          else
            isWalletRegistered ${dir} && continue
          fi
        else
          getRewardAddress ${dir}
          [[ -n ${reward_addr} ]] && reward_addr_list+=(${reward_addr})
        fi
      fi
      if [[ ${mode} = "balance" || ${mode} = "non-reg" || ${mode} = "reg" ]]; then
        getBaseAddress ${dir}
        getPayAddress ${dir}
        [[ -z ${base_addr} || -z ${pay_addr} ]] && wallet_dirs+=("${dir}") && continue # ignore and add wallet without extra details
        addr_list+=(${base_addr} ${pay_addr})
        if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
          getBalance ${base_addr}
          balances["${base_addr}"]=${assets[lovelace]}
          [[ ${#assets[@]} -gt 1 ]] && asset_cnt["${base_addr}"]="$((${#assets[@]}-1))"
          getBalance ${pay_addr}
          balances["${pay_addr}"]=${assets[lovelace]}
          [[ ${#assets[@]} -gt 1 ]] && asset_cnt["${pay_addr}"]="$((${#assets[@]}-1))"
        fi
        wallet_dirs+=("${dir}_balance_")
      elif [[ ${mode} = "delegate" ]]; then
        getBaseAddress ${dir}
        [[ -z ${base_addr} ]] && wallet_dirs+=("${dir}") && continue # ignore and add wallet without extra details
        addr_list+=(${base_addr})
        getRewardAddress ${dir}
        if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
          getBalance ${base_addr}
          balances["${base_addr}"]=${assets[lovelace]}
          if [[ -n ${reward_addr} ]]; then
            delegation_pool_id=$(${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address "${reward_addr}" | jq -r '.[0].delegation // empty')
            [[ -n ${delegation_pool_id} ]] && pool_delegations[${reward_addr}]=${delegation_pool_id}
          fi
        else
           [[ -n ${reward_addr} ]] && reward_addr_list+=(${reward_addr})
        fi
        wallet_dirs+=("${dir}_balance_")
      elif [[ ${mode} = "reward" ]]; then
        if [[ -n ${KOIOS_API} ]]; then
          getRewardAddress ${dir}
          [[ -n ${reward_addr} ]] && reward_addr_list+=(${reward_addr})
        else
          getWalletRewards ${dir}
          [[ ${reward_lovelace} -le 0 ]] && continue
          rewards_available[${reward_addr}]=${reward_lovelace}
        fi
        wallet_dirs+=("${dir}_balance_")
      fi
    else
      wallet_dirs+=("${dir}")
    fi
  done

  if [[ -n ${KOIOS_API} ]]; then
    if [[ ${#addr_list[@]} -gt 0 ]]; then
      getBalanceKoios false
      for key in "${!assets[@]}"; do
        if [[ ${key} = *lovelace ]]; then
          _address=${key%,*}
          balances[${_address}]=${assets[${key}]}
        fi
      done
    fi
    [[ ${#reward_addr_list[@]} -gt 0 ]] && getRewardInfoKoios
  fi

  wallet_dirs_filtered=()

  for dir in "${wallet_dirs[@]}"; do
    if [[ ${dir} = *_balance_ ]]; then
      wallet_dir=${dir%%_balance_}
      unset base_addr
      getBaseAddress ${wallet_dir}
      base_lovelace=${balances[${base_addr}]:-0}
      if [[ ${mode} = "reg" || ${mode} = "non-reg" ]]; then
        getRewardAddress ${wallet_dir}
        if [[ -n ${reward_addr} ]]; then
          if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
            if [[ ${mode} = "reg" ]]; then
              if [[ ! -v reward_status[${reward_addr}] || ${reward_status[${reward_addr}]} != "registered" ]]; then continue; fi
            else
              [[ -v reward_status[${reward_addr}] && ${reward_status[${reward_addr}]} = "registered" ]] && continue
            fi
          fi
        fi
      elif [[ ${mode} = "delegate" ]]; then
        getRewardAddress ${wallet_dir}
        if [[ -n ${reward_addr} ]]; then
          delegation_pool_id=${pool_delegations[${reward_addr}]}
          unset poolName
          if [[ -n ${delegation_pool_id} ]]; then
            while IFS= read -r -d '' pool; do
              getPoolID "$(basename ${pool})"
              if [[ "${pool_id_bech32}" = "${delegation_pool_id}" ]]; then
                poolName=$(basename ${pool}) && break
              fi
            done < <(find "${POOL_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
          fi
          if [[ -n ${poolName} ]]; then
            wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA - ${FG_RED}delegated${NC} to ${FG_GREEN}${poolName}${NC})")
          elif [[ -n ${delegation_pool_id} ]]; then
            wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA - ${FG_RED}delegated${NC} to ${FG_LGRAY}${delegation_pool_id:0:6}...${delegation_pool_id: -6}${NC})")
          else
            wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA)")
          fi
        else
          wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA)")
        fi
        continue
      elif [[ ${mode} = "reward" ]]; then
        getRewardAddress ${wallet_dir}
        if [[ -n ${reward_addr} && -v rewards_available[${reward_addr}] && ${rewards_available[${reward_addr}]} -gt 0 ]]; then
          wallet_dirs_filtered+=("${wallet_dir} (Rewards: ${FG_LBLUE}$(formatLovelace ${rewards_available[${reward_addr}]})${NC} ADA)")
        fi
        continue
      fi
      getPayAddress ${wallet_dir}
      pay_lovelace=${balances[${pay_addr}]:-0}
      [[ -v asset_cnt[${base_addr}] ]] && base_asset_str=" + ${FG_LBLUE}${asset_cnt[${base_addr}]}${NC} additional assets" || unset base_asset_str
      [[ -v asset_cnt[${pay_addr}] ]] && pay_asset_str=" + ${FG_LBLUE}${asset_cnt[${pay_addr}]}${NC} additional assets" || unset pay_asset_str
      if [[ ${base_lovelace} -gt 0 && ${pay_lovelace} -gt 0 ]]; then
        wallet_dirs_filtered+=("${wallet_dir} (Base Funds: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA${base_asset_str} | Payment Funds: ${FG_LBLUE}$(formatLovelace ${pay_lovelace})${NC} ADA${pay_asset_str})")
      elif [[ ${pay_lovelace} -gt 0 ]]; then
        wallet_dirs_filtered+=("${wallet_dir} (Payment Funds: ${FG_LBLUE}$(formatLovelace ${pay_lovelace})${NC} ADA${pay_asset_str})")
      else
        wallet_dirs_filtered+=("${wallet_dir} (Base Funds: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA${base_asset_str})")
      fi
    else
      wallet_dirs_filtered+=("${dir}")
    fi
  done

  if [[ ${CNTOOLS_MODE} != "OFFLINE" && ${mode} != "none" && ${mode} != "non-ms" && ${mode} != "non-gov" && ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then tput rc && tput ed; fi
  if [[ ${#wallet_dirs_filtered[@]} -eq 0 ]]; then
    if [[ ${mode} = "balance" ]]; then
      println INFO "\n${FG_YELLOW}WARN${NC}: No wallets available for selection!"
    elif [[ ${mode} = "delegate" ]]; then
      println INFO "\n${FG_YELLOW}WARN${NC}: No wallets available that can be delegated or used as pool pledge/owner/reward wallet! Required files:\n$(printf '%b\n' "$@")"
    elif [[ ${mode} = "reward" ]]; then
      println INFO "\n${FG_YELLOW}WARN${NC}: No wallets available that have rewards to withdraw or signing keys to do so!"
    elif [[ ${mode} = "reg" ]]; then
      println INFO "\n${FG_YELLOW}WARN${NC}: No wallets available that are registered on chain!"
    elif [[ ${mode} = "non-reg" ]]; then
      println INFO "\n${FG_YELLOW}WARN${NC}: No wallets available that are unregistered!"
    else
      println INFO "\n${FG_YELLOW}WARN${NC}: No wallets available for selection! Required files:\n$(printf '%b\n' "$@")"
    fi
    required_files=()
    already_selected_wallets=()
    for arg in "$@"; do
      [[ ${arg} = *"."* ]] && required_files+=("${arg}")
      [[ ${arg} != *"."* ]] && already_selected_wallets+=("${arg}")
    done
    [[ "${#already_selected_wallets[@]}" -gt 0 ]] && println INFO "Already selected wallets:\n$(printf '  %b\n' "${already_selected_wallets[@]}")"
    [[ "${#required_files[@]}" -gt 0 ]] && println INFO "Required files:\n$(printf '  %b\n' "${required_files[@]}")"
    return 1
  fi

  selectDir "wallet" "${wallet_dirs_filtered[@]}" || return $? # ${dir_name} populated by selectDir function
  wallet_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : selectPool [mode] [file1 file2 ...]
# Description : A helper function to select a CNTools pool
# Parameters  : mode   >  a string containing some of the following: reg|non-reg|encrypted
#             : fileX  >  array of files required to exist in pool folder for it to be selectable
# Return      : populates ${pool_name} variable with pool selection
selectPool() {
  pool_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${POOL_FOLDER}"; then return 1; fi # dirs() array populated with all pool folders
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if pool is missing a required file and if so hide it
      [[ -f "${POOL_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${POOL_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${POOL_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        pool_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        pool_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
      continue
    elif [[ ${mode} = "non-reg" || ${mode} = "reg" ]]; then
      isPoolRegistered "${dir}"
      case $? in
        0) println "ERROR" "KOIOS_API: ${error_msg}" &>/dev/null ;; # log error without printing but show pool
        1) [[ ${mode} = "reg" ]] && continue ;;
        2) [[ ${mode} = "non-reg" ]] && continue ;;
        3) [[ ${mode} = "non-reg" ]] && continue ;;
        4) [[ ${mode} = "reg" ]] && continue ;;
      esac
    fi
    pool_dirs+=("${dir}")
  done
  if [[ ${#pool_dirs[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No pools available that can be selected! Required files:\n$(printf '%b\n' "$@")"
    [[ ${enc_req_files} -gt 0 ]] && println DEBUG "\n${FG_YELLOW}* Encrypted pools found but not listed *${NC}"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && println DEBUG "${FG_YELLOW}encrypted pools found but NOT listed, please decrypt to show${NC}"
  selectDir "pool" "${pool_dirs[@]}" || return $? # ${dir_name} populated by selectDir function
  pool_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : isPoolRegistered [pool_name]
# Description : check if pool is registered on chain
#               existence of POOL_REGCERT_FILENAME checked when KOIOS API is not available
# Parameters  : pool_name   >  the name of the pool to check
# Return      : 0 => error quering KOIOS API (error message saved in ${error_msg})
#               1 => NOT registered
#               2 => registered
#               3 => retiring (only for KOIOS API)
#               4 => retired (only for KOIOS API)
isPoolRegistered() {
  unset error_msg pool_info pool_info_tsv pool_info_arr
  unset p_active_epoch_no p_vrf_key_hash p_margin p_fixed_cost p_pledge p_reward_addr p_owners p_relays p_meta_url p_meta_hash p_meta_json p_pool_status
  unset p_retiring_epoch p_op_cert p_op_cert_counter p_active_stake p_epoch_block_cnt p_live_stake p_live_delegators p_live_saturation
  if [[ ${CNTOOLS_MODE} != "LIGHT" ]]; then
    [[ -f "${POOL_FOLDER}/${1}/${POOL_REGCERT_FILENAME}" ]] && return 2 || (rm -f "${POOL_FOLDER}/${1}/${POOL_CURRENT_KES_START}" && return 1)
  else
    getPoolID "$1"
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "Content-Type: application/json")
    println ACTION "curl -sSL -f -X POST ${HEADERS[*]} -d '{\"_pool_bech32_ids\":[\"${pool_id_bech32}\"]}' ${KOIOS_API}/pool_info"
    ! pool_info=$(curl -sSL -f -X POST "${HEADERS[@]}" -d '{"_pool_bech32_ids":["'${pool_id_bech32}'"]}' "${KOIOS_API}/pool_info" 2>&1) && error_msg=${pool_info} && return 0
    if [[ ${pool_info} = '[]' ]]; then
      # possibly more cleanup needed, like rm -rf "${POOL_FOLDER}/${1}/${POOL_CURRENT_KES_START}" and ${POOL_REGCERT_FILENAME} if retirement was issued outside of CNTools?
      return 1
    fi
    pool_info_tsv=$(jq -r '[
    .[0].active_epoch_no //0,
    .[0].vrf_key_hash //"-",
    .[0].margin //0,
    .[0].fixed_cost //0,
    .[0].pledge //0,
    .[0].reward_addr //"-",
    (.[0].owners|@json),
    (.[0].relays|@json),
    .[0].meta_url //"-",
    .[0].meta_hash //"-",
    (.[0].meta_json|@base64),
    .[0].pool_status //"-",
    .[0].retiring_epoch //"-",
    .[0].op_cert //"-",
    .[0].op_cert_counter //"null",
    .[0].active_stake //0,
    .[0].block_count //0,
    .[0].live_pledge //0,
    .[0].live_stake //0,
    .[0].live_delegators //0,
    .[0].live_saturation //0
    ] | @tsv' <<< "${pool_info}")

    read -ra pool_info_arr <<< ${pool_info_tsv}

    p_active_epoch_no=${pool_info_arr[0]}
    p_vrf_key_hash=${pool_info_arr[1]}
    p_margin=${pool_info_arr[2]}
    p_fixed_cost=${pool_info_arr[3]}
    p_pledge=${pool_info_arr[4]}
    p_reward_addr=${pool_info_arr[5]}
    p_owners=${pool_info_arr[6]}
    p_relays=${pool_info_arr[7]}
    p_meta_url=${pool_info_arr[8]}
    p_meta_hash=${pool_info_arr[9]}
    p_meta_json=$(base64 -d <<< ${pool_info_arr[10]})
    p_pool_status=${pool_info_arr[11]}
    p_retiring_epoch=${pool_info_arr[12]}
    p_op_cert=${pool_info_arr[13]}
    p_op_cert_counter=${pool_info_arr[14]}
    p_active_stake=${pool_info_arr[15]}
    p_block_count=${pool_info_arr[16]}
    p_live_pledge=${pool_info_arr[17]}
    p_live_stake=${pool_info_arr[18]}
    p_live_delegators=${pool_info_arr[19]}
    p_live_saturation=${pool_info_arr[20]}

    [[ ${p_pool_status} = 'registered' ]] && return 2
    [[ ${p_pool_status} = 'retiring' ]] && return 3 || return 4
  fi
}

# Command     : getAssetInfo [policy_id] [asset_name_hex]
# Description : Query Koios for asset information.
# Return      : 0: data saved in asset_<koios_field>
#               1: on error ($error_msg contains error message)
#               2: offline/disabled/no result
getAssetInfo() {
  unset
  if [[ ${CNTOOLS_MODE} != "LIGHT" || $# -lt 1 ]]; then
    return 2
  else
    println ACTION "curl -sSL -f ${KOIOS_API_HEADERS[*]} -d _asset_policy=$1 -d _asset_name=$2  ${KOIOS_API}/asset_info"
    ! asset_info=$(curl -sSL -f "${KOIOS_API_HEADERS[@]}" -d _asset_policy=$1 -d _asset_name=$2 "${KOIOS_API}/asset_info" 2>&1) && error_msg="${asset_info}" && return 1
    if [[ ${asset_info} = '[]' ]]; then
      return 2
    fi
    asset_info_tsv=$(jq -r '[
    (.[0].asset_name_ascii //"-" | @base64),
    .[0].fingerprint //"-",
    .[0].minting_tx_hash //"-",
    .[0].total_supply //0,
    .[0].mint_cnt //0,
    .[0].burn_cnt //0,
    .[0].creation_time //0,
    (.[0].minting_tx_metadata //"-" | @base64),
    (.[0].token_registry_metadata //"-" | @base64)
    ] | @tsv' <<< "${asset_info}")

    read -ra asset_info_arr <<< ${asset_info_tsv}

    a_asset_name_ascii=$(base64 -d <<< ${asset_info_arr[0]})
    a_fingerprint=${asset_info_arr[1]}
    a_minting_tx_hash=${asset_info_arr[2]}
    a_total_supply=${asset_info_arr[3]}
    a_mint_cnt=${asset_info_arr[4]}
    a_burn_cnt=${asset_info_arr[5]}
    a_creation_time=${asset_info_arr[6]}
    a_minting_tx_metadata=$(base64 -d <<< ${asset_info_arr[7]})
    a_token_registry_metadata=$(base64 -d <<< ${asset_info_arr[8]})
  fi
}

# Command     : selectPolicy [mode] [file1 file2 ...]
# Description : A helper function to select a Multi-Asset policy
# Parameters  : fileX  >  array of files required to exist in policy folder for it to be selectable
# Return      : populates ${policy_name} variable with selected policy
selectPolicy() {
  policy_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${ASSET_FOLDER}"; then return 1; fi
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if policy folder contain required files
      [[ -f "${ASSET_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${ASSET_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        policy_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        policy_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
      continue
    fi
    policy_dirs+=("${dir}")
  done
  if [[ ${#policy_dirs[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No policies available that can be selected! Required files:\n$(printf '%b\n' "$@")"
    [[ ${enc_req_files} -gt 0 ]] && println DEBUG "\n${FG_YELLOW}* Encrypted policies found but not listed *${NC}"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && println DEBUG "${FG_YELLOW}encrypted policies found but NOT listed, please decrypt to show${NC}"
  selectDir "policy" "${policy_dirs[@]}" || return $? # ${dir_name} populated by selectDir function
  policy_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : selectAsset
# Description : A helper function to select a Multi-Asset minted on device
# Return      : populates ${policy_dir}, ${asset_name} & ${asset_file} variables
selectAsset() {
  asset_list=() # <policy_id>.<asset_name>
  if ! getDirs "${ASSET_FOLDER}"; then return 1; fi
  for dir in "${dirs[@]}"; do
    if [[ $(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.asset' -print0 | wc -c) -gt 0 ]]; then
      while IFS= read -r -d '' asset; do
        asset_file=${asset##*/}
        asset_list+=("${dir}/${asset_file%%.*}")
      done < <(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.asset' -print0 | sort -z)
    fi
  done
  if [[ ${#asset_list[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No assets found on disk!"
    return 1
  fi
  selectDir "asset" "${asset_list[@]}" || return $? # ${dir_name} populated by selected value
  policy_dir="${dir_name%%/*}"
  asset_name="${dir_name##*/}"
  asset_file="${ASSET_FOLDER}/${policy_dir}/${asset_name}.asset"
}

# Command     : getPasswordCust [optional: confirm]
# Description : Get password from user on STDIN
# Parameters  : confirm  >  [optional] force user to provide password twice for confirmation
# Return      : populates ${password} variable, make sure to unset variable when done
getPasswordCust() {
  getPassword 8 $1
  return_code=$?
  return ${return_code}
}

# Command     : encryptFile [file] [password]
# Description : Encrypt file with GPG
# Parameters  : file      >  Path for file to encrypt, will get a new .gpg file extention added to filename
#             : password  >  Password to encrypt file with
encryptFile() {
  echo "${2}" | gpg --symmetric --yes --batch --cipher-algo AES256 --passphrase-fd 0 --output "${1}.gpg" "${1}" &>/dev/null && \
  safeDel "${1}" >/dev/null || {
    println ERROR "${FG_RED}ERROR${NC}: failed to encrypt ${1}"
    return 1
  }
  println DEBUG "${1} successfully encrypted"
}


# Command     : decryptFile [file] [password]
# Description : Decrypt file with GPG
# Parameters  : file      >  Path for file to decrypt, file extension .gpg required
#             : password  >  Password to decrypt file with
decryptFile() {
  echo "${2}" | gpg --decrypt --batch --yes --passphrase-fd 0 --output "${1%.*}" "${1}" &>/dev/null && \
  rm -f "${1}" || {
    println ERROR "${FG_RED}ERROR${NC}: failed to decrypt ${1}"
    return 1
  }
  println DEBUG "${1} successfully decrypted"
}

# Command     : unlockFile [file]
# Description : Unlock/remove write protection from file
# Parameters  : file      >  Path for file to unlock
unlockFile() {
  if [[ ${ENABLE_CHATTR} = true && $(lsattr -R "$1") =~ -i- ]]; then
    sudo chattr -i "${1}"
  fi
  chmod 600 "${1}"
}

# Command     : lockFile [file]
# Description : Lock/write protect file with chattr if enabled and Linux file permissions
# Parameters  : file      >  Path for file to lock
lockFile() {
  chmod 400 "$1"
  if [[ ${ENABLE_CHATTR} = true && ! $(lsattr -R "$1") =~ -i- ]]; then
    sudo chattr +i "$1"
  fi
}

# Command     : verifyTx [address]
# Description : Verify that the transaction was successfully registered by checking address balance against $newBalance
# Parameters  : address  >  the address to compare with
verifyTx() {
  [[ -z ${tx_id} ]] && println "\n${FG_RED}ERROR${NC}: transaction id not set, unable to verify transaction!" && return 1
  println DEBUG "Waiting for transaction to be seen on chain"
  if [[ ${NWMAGIC} == "764824073" ]]; then
    println DEBUG "Explore in detail: ${EXPLORER_TX//__tx_id__/${tx_id}}"
  else
    println DEBUG "Transaction ID: ${tx_id}"
  fi
  println DEBUG "${FG_BLUE}INFO${NC}: press any key to cancel and return (won't stop transaction)"
  while :; do
    read -r -n 1 -s -t 5 abort
    if [[ $? -eq 0 ]]; then
      println "\n${FG_YELLOW}WARN${NC}: aborted!! transaction still in queue!"
      return 1
    fi
    if [[ -n ${KOIOS_API} ]]; then
      HEADERS=("${KOIOS_API_HEADERS[@]}" -H "Content-Type: application/json" -H "accept: text/csv")
      println ACTION "curl -sSL -f -X POST ${HEADERS[*]} -d '{\"_tx_hashes\":[\"${tx_id}\"]' ${KOIOS_API}/tx_status?select=num_confirmations"
      ! num_confirmations=$(curl -sSL -f -X POST "${HEADERS[@]}" -d '{"_tx_hashes":["'${tx_id}'"]}' "${KOIOS_API}/tx_status?select=num_confirmations" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${num_confirmations}\n" && return 1 # print error and return
      result=$(tail -n +2 <<< ${num_confirmations})
    else
      println ACTION "${CCLI} ${NETWORK_ERA} query utxo --tx-in ${tx_id}#0 ${NETWORK_IDENTIFIER}| tail -n +3"
      result=$(${CCLI} ${NETWORK_ERA} query utxo --tx-in "${tx_id}#0" ${NETWORK_IDENTIFIER}| tail -n +3)
    fi
    [[ -n "${result}" ]] && { println DEBUG "\nTx put on chain !!"; break; } || printf .
  done
}

# Command     : getPayAddress [wallet name]
# Description : create and save payment address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${pay_addr}
getPayAddress() {
  unset pay_addr
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_script_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}"
  payment_addr_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_ADDR_FILENAME}"
  [[ -f ${payment_addr_file} ]] && pay_addr=$(cat "${payment_addr_file}") && return 0
  if [[ -f "${payment_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file ${payment_vk_file} --out-file ${payment_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      pay_addr=$(cat "${payment_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during payment address creation!\n${stdout}"
    fi
  elif [[ -f "${payment_script_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-script-file ${payment_script_file} --out-file ${payment_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-script-file "${payment_script_file}" --out-file "${payment_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      pay_addr=$(cat "${payment_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during payment script address creation!\n${stdout}"
    fi
  fi
  return 1
}

# Command     : getGovKeyInfo [wallet name]
# Description : generate DRep ID and committee key hash
getGovKeyInfo() {
  unset drep_id drep_id_cip129 drep_hash hash_type cc_cold_hash cc_cold_id cc_cold_id_cip129 cc_hot_hash cc_hot_id cc_hot_id_cip129 ms_drep_id ms_drep_hash
  drep_vk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_DREP_VK_FILENAME}"
  drep_sk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_DREP_SK_FILENAME}"
  drep_script_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_DREP_SCRIPT_FILENAME}"
  drep_id_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_DREP_ID_FILENAME}"
  cc_cold_vk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_CC_COLD_VK_FILENAME}"
  cc_cold_sk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_CC_COLD_SK_FILENAME}"
  cc_cold_id_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_CC_COLD_ID_FILENAME}"
  cc_hot_vk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_CC_HOT_VK_FILENAME}"
  cc_hot_sk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_CC_HOT_SK_FILENAME}"
  cc_hot_id_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_CC_HOT_ID_FILENAME}"
  ms_drep_vk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_DREP_VK_FILENAME}"
  ms_drep_sk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_DREP_SK_FILENAME}"
  ms_drep_id_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_DREP_ID_FILENAME}"
  if [[ -f "${drep_vk_file}" && $(jq -r '.description' "${drep_vk_file}") = *"Hardware"* ]]; then # Hardware wallet
    drep_sk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_HW_DREP_SK_FILENAME}"
    cc_cold_sk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_HW_CC_COLD_SK_FILENAME}"
    cc_hot_sk_file="${WALLET_FOLDER}/${1}/${WALLET_GOV_HW_CC_HOT_SK_FILENAME}"
    ms_drep_sk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_HW_DREP_SK_FILENAME}"
  fi
  [[ -f ${drep_id_file} ]] && drep_id=$(cat "${drep_id_file}")
  [[ -f ${cc_cold_id_file} ]] && cc_cold_id=$(cat "${cc_cold_id_file}")
  [[ -f ${cc_hot_id_file} ]] && cc_hot_id=$(cat "${cc_hot_id_file}")
  [[ -f ${ms_drep_id_file} ]] && ms_drep_id=$(cat "${ms_drep_id_file}")
  if [[ -z ${drep_id} && -f ${drep_vk_file} ]]; then
    println ACTION "${CCLI} conway governance drep id --drep-verification-key-file ${drep_vk_file}"
    drep_id=$(${CCLI} conway governance drep id --drep-verification-key-file "${drep_vk_file}")
    printf "${drep_id}" > "${drep_id_file}"
  elif [[ -z ${drep_id} && -f ${drep_script_file} ]]; then
    println ACTION "${CCLI} hash script --script-file ${drep_script_file}"
    drep_id=$(${CCLI} hash script --script-file "${drep_script_file}")
    printf "${drep_id}" > "${drep_id_file}"
  fi
  if [[ -z ${ms_drep_id} && -f ${ms_drep_vk_file} ]]; then
    println ACTION "${CCLI} conway governance drep id --drep-verification-key-file ${ms_drep_vk_file}"
    ms_drep_id=$(${CCLI} conway governance drep id --drep-verification-key-file "${ms_drep_vk_file}")
    printf "${ms_drep_id}" > "${ms_drep_id_file}"
  fi
  if [[ -z ${cc_cold_id} && -f ${cc_cold_vk_file} ]]; then
    println ACTION "bech32 cc_cold <<< \$(${CCLI} conway governance committee key-hash --verification-key-file ${cc_cold_vk_file})"
    cc_cold_id=$(bech32 cc_cold <<< "$(${CCLI} conway governance committee key-hash --verification-key-file "${cc_cold_vk_file}")")
    printf "${cc_cold_id}" > "${cc_cold_id_file}"
  fi
  if [[ -z ${cc_hot_id} && -f ${cc_hot_vk_file} ]]; then
    println ACTION "bech32 cc_hot <<< \$(${CCLI} conway governance committee key-hash --verification-key-file ${cc_hot_vk_file})"
    cc_hot_id=$(bech32 cc_hot <<< "$(${CCLI} conway governance committee key-hash --verification-key-file "${cc_hot_vk_file}")")
    printf "${cc_hot_id}" > "${cc_hot_id_file}"
  fi
  if [[ -n ${drep_id} ]]; then
    if [[ ${drep_id} = drep* ]]; then
      hash_type="keyHash"
      drep_hash="$(bech32 <<< ${drep_id})"
      drep_id_cip129="$(bech32 drep <<< "22${drep_hash}")"
    else
      hash_type="scriptHash"
      drep_hash="${drep_id}"
      drep_id="$(bech32 drep_script <<< "${drep_hash}")"
      drep_id_cip129="$(bech32 drep <<< "23${drep_hash}")"
    fi
  fi
  if [[ -n ${ms_drep_id} ]]; then
    ms_drep_hash="$(bech32 <<< ${ms_drep_id})"
    ms_drep_id=$(bech32 drep_script <<< "${ms_drep_hash}")
  fi
  if [[ -n ${cc_cold_id} ]]; then
    cc_cold_hash=$(bech32 <<< "${cc_cold_id}")
    cc_cold_id_cip129=$(bech32 cc_cold <<< "12${cc_cold_hash}")
  fi
  if [[ -n ${cc_hot_id} ]]; then
    cc_hot_hash=$(bech32 <<< "${cc_hot_id}")
    cc_hot_id_cip129=$(bech32 cc_hot <<< "02${cc_hot_hash}")
  fi
}

# Command     : getDRepIds [type] [hash]
getDRepIds() {
  unset drep_id drep_id_cip129
  [[ -z $1 || -z $2 ]] && return 1
  if [[ $1 = keyHash ]]; then
    drep_id="$(bech32 drep <<< ${2})"
    drep_id_cip129="$(bech32 drep <<< "22${2}")"
  else
    drep_id="$(bech32 drep_script <<< ${2})"
    drep_id_cip129="$(bech32 drep <<< "23${2}")"
  fi
}

# Command     : parseDRepId [drep_id]
parseDRepId() {
  unset drep_id drep_id_cip129 drep_hash hash_type
  [[ -z $1 ]] && return 1
  drep_hash=$(bech32 <<< $1)
  if [[ ${#drep_hash} -eq 56 ]]; then
    if [[ $1 = drep_script* ]]; then
      hash_type=scriptHash
      drep_id=$(bech32 drep_script <<< "${drep_hash}")
      drep_id_cip129=$(bech32 drep <<< "23${drep_hash}")
    else
      hash_type=keyHash
      drep_id=$(bech32 drep <<< "${drep_hash}")
      drep_id_cip129=$(bech32 drep <<< "22${drep_hash}")
    fi
  elif [[ ${#drep_hash} -eq 58 ]]; then
    if [[ ${drep_hash:0:2} = 23 ]]; then
      hash_type=scriptHash
      drep_hash=${drep_hash:2}
      drep_id=$(bech32 drep_script <<< "${drep_hash}")
      drep_id_cip129=$1
    else
      hash_type=keyHash
      drep_hash=${drep_hash:2}
      drep_id=$(bech32 drep <<< "${drep_hash}")
      drep_id_cip129=$1
    fi
  fi
}

# Command     : getCCIds [type] [hash]
getCCIds() {
  unset cc_cold_id cc_hot_id cc_cold_id_cip129 cc_hot_id_cip129
  [[ -z $1 || -z $2 ]] && return 1
  if [[ $1 = keyHash ]]; then
    cc_cold_id="$(bech32 cc_cold <<< ${2})"
    cc_hot_id="$(bech32 cc_hot <<< ${2})"
    cc_cold_id_cip129="$(bech32 cc_cold <<< "12${2}")"
    cc_hot_id_cip129="$(bech32 cc_cold <<< "02${2}")"
  else
    cc_cold_id="$(bech32 cc_cold_script <<< ${2})"
    cc_hot_id="$(bech32 cc_hot_script <<< ${2})"
    cc_cold_id_cip129="$(bech32 cc_cold <<< "13${2}")"
    cc_hot_id_cip129="$(bech32 cc_cold <<< "03${2}")"
  fi
}

# Command     : getGovActionId [tx_id] [index]
getGovActionId() {
  unset action_id action_id_cip129
  [[ -z $1 || -z $2 ]] && return 1
  action_id="${1}#${2}"
  action_id_cip129=$(bech32 gov_action <<< "${1}$(printf '%02x' ${2})")
}

# Command     : parseGovActionId [gov_action_id]
parseGovActionId() {
  unset action_tx_id action_idx
  [[ -z $1 ]] && return 1
  action_hex=$(bech32 <<< "${1}")
  action_tx_id=${action_hex:0:64}
  action_idx=$(printf "%d" "0x${action_hex:64}")
}

# Command     : getDRepStatus [type] [hash]
# Description : query status of drep id
# Return      : populates ${hash_type} ${drep_hash} ${drep_anchor_url} ${drep_anchor_hash} ${drep_deposit_amt} ${drep_expiry} ${drep_active} ${drep_vote_power}
getDRepStatus() {
  unset hash_type drep_anchor_url drep_anchor_hash drep_deposit_amt drep_expiry drep_active drep_vote_power
  [[ -z $1 || -z $2 || ($1 != keyHash && $1 != scriptHash) ]] && return 1
  hash_type="$1"
  drep_hash="$2"
  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    if [[ ${2} = alwaysAbstain ]]; then
      _param="drep_always_abstain"
    elif [[ ${2} = alwaysNoConfidence ]]; then
     _param="drep_always_no_confidence"
    else
      [[ ${hash_type} = keyHash ]] && _param=$(bech32 drep <<< "22${2}") || _param=$(bech32 drep <<< "23${2}")
    fi
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "Content-Type: application/json" -H "accept: text/csv")
    println ACTION "curl -sSL -f -X POST ${HEADERS[*]} -d '{\"_drep_ids\":[\"${_param}\"]}' ${KOIOS_API}/drep_info?select=registered,deposit,active,expires_epoch_no,amount,meta_url,meta_hash"
    ! drep_info_list=$(curl -sSL -f -X POST "${HEADERS[@]}" -d '{"_drep_ids":["'${_param}'"]}' "${KOIOS_API}/drep_info?select=registered,deposit,active,expires_epoch_no,amount,meta_url,meta_hash" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${drep_info_list}\n" && return 1 # print error and return
    [[ -z ${drep_info_list} ]] && return 1
    while IFS=',' read -r _registered _deposit _active _expires_epoch_no _amount _url _hash; do
      [[ ${_registered} != t ]] && return 1
      drep_anchor_url="${_url}"
      drep_anchor_hash="${_hash}"
      drep_deposit_amt="${_deposit}"
      drep_expiry="${_expires_epoch_no}"
      drep_active="${_active}"
      drep_vote_power="${_amount}"
      return 0
    done <<< "$(tail -n +2 <<< ${drep_info_list})"
  elif [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
    [[ ${hash_type} = keyHash ]] && hash_param="--drep-key-hash" || hash_param="--drep-script-hash"
    println ACTION "${CCLI} conway query drep-state ${hash_param} ${2} ${NETWORK_IDENTIFIER} | jq -r .[0][1]"
    drep_state=$(${CCLI} conway query drep-state ${hash_param} ${2} ${NETWORK_IDENTIFIER} | jq -r .[0][1])
    [[ ${drep_state} = null ]] && return 1
    IFS=',' read -r drep_anchor_url drep_anchor_hash drep_deposit_amt drep_expiry < <( jq -cr '"\(.anchor.url//""),\(.anchor.dataHash//""),\(.deposit),\(.expiry)"' <<< "${drep_state}" )
    return 0
  fi
  return 1
}

# Command     : getDRepAnchor [url] [hash]
# Description : download anchor data and verify hash
# Return      : populates ${drep_anchor_file} ${drep_anchor_real_hash}
#             : 0 = ok, 1 = invalid url, 2 = hash doesn't match
getDRepAnchor() {
  unset drep_anchor_file drep_anchor_real_hash
  [[ -z $1 ]] && return 1
  drep_anchor_file="${TMP_DIR}/metadata_$(date '+%Y%m%d%H%M%S').json"
  if ! curl -sL -m ${CURL_TIMEOUT} -o "${drep_anchor_file}" ${1}; then
    [[ -f "${drep_anchor_file}" ]] && rm -f "${drep_anchor_file}"
    unset drep_anchor_file
    return 1
  fi
  println ACTION "${CCLI} hash anchor-data --file-text ${drep_anchor_file}"
  drep_anchor_real_hash="$(${CCLI} hash anchor-data --file-text "${drep_anchor_file}")"
  [[ ${drep_anchor_real_hash} != "${2}" ]] && return 2
  return 0
}

# Command     : getDRepVotePower [type] <hash>
# Description : query status of drep id
# Return      : populates ${vote_power} ${vote_power_total} ${vote_power_pct}
getDRepVotePower() {
  unset vote_power vote_power_total vote_power_pct
  [[ -z $1 ]] && return 1
  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    if [[ $1 = always* ]]; then
      getDRepStatus "-" "$1" || return 1
    elif [[ ${drep_hash} != "$2" ]] || ! isNumber ${drep_vote_power}; then
      getDRepStatus "$1" "$2" || return 1
    fi
    current_epoch=$(getEpoch)
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "accept: text/csv")
    println ACTION "curl -sSL -f -X GET ${HEADERS[*]} ${KOIOS_API}/drep_epoch_summary?_epoch_no=${current_epoch}&select=amount"
    vote_power_total=$(curl -sSL -f -X GET "${HEADERS[@]}" "${KOIOS_API}/drep_epoch_summary?_epoch_no=${current_epoch}&select=amount") || return 1
    vote_power_total=$(tail -n +2 <<< ${vote_power_total})
    vote_power="${drep_vote_power}"
  elif [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
    println ACTION "${CCLI} conway query drep-stake-distribution --all-dreps ${NETWORK_IDENTIFIER}"
    all_drep_vote_power=$(${CCLI} conway query drep-stake-distribution --all-dreps ${NETWORK_IDENTIFIER})
    vote_power_total=$(jq -r '[.[][1]] | add' <<< "${all_drep_vote_power}")
    search_string="drep-${1}"
    [[ -n $2 ]] && search_string+="-${2}"
    vote_power=$(jq -r --arg v "${search_string}" 'first(.[] | select(.[0] == $v)) | .[1]' <<< "${all_drep_vote_power}")
    [[ -z ${vote_power} ]] && return 1
  else
    return 1
  fi
  [[ -z ${vote_power_total} ]] && vote_power_total=0
  [[ -z ${vote_power} ]] && vote_power=0
  if [[ ${vote_power_total} -eq 0 || ${vote_power} -eq 0 ]]; then
    vote_power_pct="0.00"
  else
    vote_power_pct=$(fractionToPCT "$(bc -l <<< "${vote_power}/${vote_power_total}")")
    [[ -z ${vote_power_pct%.*} || ${vote_power_pct%.*} = 0 ]] && pct_precision=4 || pct_precision=2
    vote_power_pct=$(printf "%.${pct_precision}f" ${vote_power_pct})
  fi
  return 0
}

# Command     : getWalletVoteDelegation [wallet name] [force]
# Description : check vote delegation status
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${vote_delegation}
getWalletVoteDelegation() {
  unset vote_delegation
  if isWalletRegistered $1; then
    if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
      vote_delegation=${vote_delegations[${reward_addr}]}
    fi
    [[ -n ${vote_delegation} ]] && return 0
  fi
  return 1
}

# Command     : getGovAction [tx_id] [index]
# Description : fetch governance action information by id (cli format)
# Return      : populates ${vote_action} ${proposal_url} ${proposal_hash} ${proposal_type} ${isParameterSecurityGroup}
#             : 0 = ok, 1 = action not found, 2 = invalid url or content, 3 = hash doesn't match
getGovAction() {
  unset vote_action proposal_url proposal_hash proposal_meta_file proposal_type
  [[ -z $1 || -z $2 ]] && return 1
  isParameterSecurityGroup=N
  isNetworkGroup=N
  isEconomicGroup=N
  isTechnicalGroup=N
  isGovernanceGroup=N
  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "accept: application/json")
    println ACTION "curl -sSL -f -X GET ${HEADERS[*]} ${KOIOS_API}/proposal_list?proposal_tx_hash=eq.${1}&proposal_index=eq.${2}"
    ! vote_action=$(curl -sSL -f -X GET "${HEADERS[@]}" "${KOIOS_API}/proposal_list?proposal_tx_hash=eq.${1}&proposal_index=eq.${2}" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${vote_action}\n" && return 1 # print error and return
    [[ ${vote_action} = '[]' ]] && return 1
    vote_action=$(jq -er .[0] <<< "${vote_action}")
    IFS=',' read -r proposal_url proposal_hash proposal_type < <( jq -cr '"\(.meta_url//""),\(.meta_hash//""),\(.proposal_type//"")"' <<< "${vote_action}" )
    [[ ${proposal_type} = "ParameterChange" ]] && parameterChange=$(jq -e '.param_proposal | keys[]' <<< "${vote_action}") && getParameterChangeGroups
  elif [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
    println ACTION "${CCLI} conway query gov-state ${NETWORK_IDENTIFIER} | jq -r --arg govActionId \"$1\" 'first(.proposals | to_entries[] | select(.value.actionId.txId | contains(\$govActionId))) | .value'"
    vote_action=$(${CCLI} conway query gov-state ${NETWORK_IDENTIFIER} | jq -r --arg govActionId "$1" 'first(.proposals | to_entries[] | select(.value.actionId.txId | contains($govActionId))) | .value')
    [[ -z ${vote_action} ]] && return 1
    IFS=',' read -r proposal_url proposal_hash proposal_type < <( jq -cr '"\(.proposalProcedure.anchor.url//""),\(.proposalProcedure.anchor.dataHash//""),\(.proposalProcedure.govAction.tag//"")"' <<< "${vote_action}" )
    [[ ${proposal_type} = "ParameterChange" ]] && parameterChange=$(jq -e '.proposalProcedure.govAction.contents[1] | keys[]' <<< "${vote_action}") && getParameterChangeGroups
  else
    return 1
  fi
  if [[ -n ${proposal_url} ]]; then
    proposal_meta_file="${TMP_DIR}/metadata_$(date '+%Y%m%d%H%M%S').json"
    [[ "${proposal_url}" = ipfs://* ]] && _proposal_url="https://ipfs.io/ipfs/${proposal_url:7}" || _proposal_url="${proposal_url}"
    [[ ! "${_proposal_url}" =~ https?://.* ]] && return 2
    if ! curl -sL -m ${CURL_TIMEOUT} -o "${proposal_meta_file}" ${_proposal_url}; then
      [[ -f "${proposal_meta_file}" ]] && rm -f "${proposal_meta_file}"
      return 2
    fi
    println ACTION "${CCLI} hash anchor-data --file-text ${proposal_meta_file}"
    proposal_meta_hash="$(${CCLI} hash anchor-data --file-text "${proposal_meta_file}")"
    [[ ${proposal_meta_hash} != "${proposal_hash}" ]] && return 3
  fi
  return 0
}

# Command     : getAllGovActions
# Return      : csv array of governance actions with different data depending on LIGHT VS LOCAL mode
getAllGovActions() {
  unset vote_action_list _vote_action_list _vote_action_summary _vote_action_votes own_drep_votes own_spo_votes own_cc_votes
  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    getCurrentCommittee; getParameterThresholds # to fetch thresholds
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "accept: text/csv")
    println ACTION "curl -sSL -f -X GET ${HEADERS[*]} ${KOIOS_API}/proposal_list?select=block_time,ratified_epoch,enacted_epoch,dropped_epoch,expired_epoch,proposal_id,proposal_tx_hash,proposal_index,proposal_type,proposed_epoch,expiration,meta_url,param_proposal&ratified_epoch=is.null&enacted_epoch=is.null&dropped_epoch=is.null&expired_epoch=is.null&order=block_time.desc"
    _vote_action_list=$(curl -sSL -f -X GET "${HEADERS[@]}" "${KOIOS_API}/proposal_list?select=block_time,ratified_epoch,enacted_epoch,dropped_epoch,expired_epoch,proposal_id,proposal_tx_hash,proposal_index,proposal_type,proposed_epoch,expiration,meta_url,param_proposal&ratified_epoch=is.null&enacted_epoch=is.null&dropped_epoch=is.null&expired_epoch=is.null&order=block_time.desc" 2>&1) || return 1
    vote_action_list=()
    while IFS=',' read -r _block_time _ratified_epoch _enacted_epoch _dropped_epoch _expired_epoch _proposal_id _proposal_tx_hash _proposal_index _proposal_type _proposed_epoch _expiration _meta_url _param_proposal; do
      println ACTION "curl -sSL -f -X GET ${HEADERS[*]} ${KOIOS_API}/proposal_voting_summary?_proposal_id=${_proposal_id}&select=drep_yes_votes_cast,drep_yes_vote_power,drep_yes_pct,drep_no_votes_cast,drep_no_vote_power,drep_no_pct,pool_yes_votes_cast,pool_yes_vote_power,pool_yes_pct,pool_no_votes_cast,pool_no_vote_power,pool_no_pct,committee_yes_votes_cast,committee_yes_pct,committee_no_votes_cast,committee_no_pct"
      _vote_action_summary=$(curl -sSL -f -X GET "${HEADERS[@]}" "${KOIOS_API}/proposal_voting_summary?_proposal_id=${_proposal_id}&select=drep_yes_votes_cast,drep_yes_vote_power,drep_yes_pct,drep_no_votes_cast,drep_no_vote_power,drep_no_pct,pool_yes_votes_cast,pool_yes_vote_power,pool_yes_pct,pool_no_votes_cast,pool_no_vote_power,pool_no_pct,committee_yes_votes_cast,committee_yes_pct,committee_no_votes_cast,committee_no_pct" 2>&1) || continue
      IFS=',' read -r drep_yes_votes_cast drep_yes_vote_power drep_yes_pct drep_no_votes_cast drep_no_vote_power drep_no_pct pool_yes_votes_cast pool_yes_vote_power pool_yes_pct pool_no_votes_cast pool_no_vote_power pool_no_pct committee_yes_votes_cast committee_yes_pct committee_no_votes_cast committee_no_pct <<< "$(tail -n +2 <<< ${_vote_action_summary})"
      drep_yes_pct=$(printf '%.2f' "${drep_yes_pct}" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      drep_no_pct=$(printf '%.2f' "${drep_no_pct}" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      pool_yes_pct=$(printf '%.2f' "${pool_yes_pct}" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      pool_no_pct=$(printf '%.2f' "${pool_no_pct}" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      committee_yes_pct=$(printf '%.2f' "${committee_yes_pct}" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      committee_no_pct=$(printf '%.2f' "${committee_no_pct}" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      isParameterSecurityGroup=N
      if [[ ${_proposal_type} = "ParameterChange" ]]; then
        param_proposal_unescaped=${_param_proposal:1: -1} # remove first and last char (quotation)
        param_proposal_unescaped=$(sed 's/""/"/g' <<< "${param_proposal_unescaped}") # remove all double quotes, sed seems to perform better than bash string manipulation
        parameterChange=$(jq -e '. | keys[]' <<< "${param_proposal_unescaped}")
        getParameterChangeGroups
      fi
      getVoteThreshold ${_proposal_type}
      println ACTION "curl -sSL -f -X GET ${HEADERS[*]} ${KOIOS_API}/proposal_votes?_proposal_id=${_proposal_id}&select=voter_role,voter_hex,vote"
      _vote_action_votes=$(curl -sSL -f -X GET "${HEADERS[@]}" "${KOIOS_API}/proposal_votes?_proposal_id=${_proposal_id}&select=voter_role,voter_hex,vote" 2>&1) || continue
      while IFS= read -r -d '' wallet; do
        wallet_name=$(basename ${wallet})
        getGovKeyInfo ${wallet_name}
        while IFS= read -r vote; do
          IFS=',' read -ra vote_arr <<< "${vote}"
          [[ ${vote_arr[0]} = DRep && ${vote_arr[1]} = "${drep_hash}" ]] && own_drep_votes+=( "${_proposal_tx_hash}#${_proposal_index};${wallet_name};${vote_arr[2]}" )
          [[ ${vote_arr[0]} = ConstitutionalCommittee && ${vote_arr[1]} = "${cc_hot_hash}" ]] && own_cc_votes+=( "${_proposal_tx_hash}#${_proposal_index};${wallet_name};${vote_arr[2]}" )
        done <<< "${_vote_action_votes}"
      done < <(find "${WALLET_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
      while IFS= read -r -d '' pool; do
        pool_name=$(basename ${pool})
        getPoolID ${pool_name} || continue
        while IFS= read -r vote; do
          IFS=',' read -ra vote_arr <<< "${vote}"
          [[ ${vote_arr[0]} = SPO && ${vote_arr[1]} = "${pool_id}" ]] && own_spo_votes+=( "${_proposal_tx_hash}#${_proposal_index};${pool_name};${vote_arr[2]}" ) && continue 2
        done <<< "${_vote_action_votes}"
      done < <(find "${POOL_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
      vote_action_list+=( "${_proposal_tx_hash}#${_proposal_index},${_proposal_type},${_proposed_epoch},$((_expiration-1)),${_meta_url},${drep_yes_votes_cast},${drep_yes_vote_power},${drep_yes_pct},${drep_no_votes_cast},${drep_no_vote_power},${drep_no_pct},${pool_yes_votes_cast},${pool_yes_vote_power},${pool_yes_pct},${pool_no_votes_cast},${pool_no_vote_power},${pool_no_pct},${committee_yes_votes_cast},${committee_yes_pct},${committee_no_votes_cast},${committee_no_pct},${drep_vt},${spo_vt},${cc_vt},${isParameterSecurityGroup}" )
    done <<< "$(tail -n +2 <<< ${_vote_action_list})"
  elif [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
    getCurrentCommittee; getParameterThresholds # to fetch thresholds
    # get current DRep distribution
    println ACTION "${CCLI} conway query drep-stake-distribution --all-dreps ${NETWORK_IDENTIFIER}"
    all_drep_vote_power=$(${CCLI} conway query drep-stake-distribution --all-dreps ${NETWORK_IDENTIFIER})
    # sum of all drep stake distribution entries without the alwaysAbstain and alwaysNoConfidence
    drep_power_total_no_abstain=$(jq -r '[.[] | select(.[0] == "drep-alwaysAbstain" | not) | .[1]] | add //0' <<< "${all_drep_vote_power}" 2>/dev/null)
    # get current Pool distribution
    unset all_spo_vote_power spo_power_total
    println ACTION "${CCLI} conway query spo-stake-distribution --all-spos ${NETWORK_IDENTIFIER}"
    all_spo_vote_power=$(${CCLI} conway query spo-stake-distribution --all-spos ${NETWORK_IDENTIFIER})
    spo_power_total=$(jq -r '[.[][1]] | add' <<< "${all_spo_vote_power}" 2>/dev/null)
    # get committee vote power (sum of authorized committee members)
    cc_power_authorized=$(jq -r 'reduce(select(.committee[].hotCredsAuthStatus.tag|strings=="MemberAuthorized")) as $_ (0; .+1)' <<< "${committee_info}")
    vote_action_list=(); _vote_action_list=()
    println ACTION "${CCLI} conway query gov-state ${NETWORK_IDENTIFIER} | jq -er '.proposals[] | @base64'"
    for vote_action in $(${CCLI} conway query gov-state ${NETWORK_IDENTIFIER} | jq -er '.proposals[] | @base64' 2>/dev/null); do
      IFS=',' read -r proposal_id proposal_type proposed_epoch expiration meta_url drep_yes_votes_cast drep_no_votes_cast spo_yes_votes_cast spo_no_votes_cast cc_yes_votes_cast cc_no_votes_cast < <( jq -cr '"\((.actionId.txId//"") + "#" + (.actionId.govActionIx//0|tostring)),\(.proposalProcedure.govAction.tag//""),\(.proposedIn//0),\(.expiresAfter//0),\(.proposalProcedure.anchor.url//""),\(.dRepVotes | reduce(..|select(strings=="VoteYes")) as $_ (0; .+1)),\(.dRepVotes | reduce(..|select(strings=="VoteNo")) as $_ (0; .+1)),\(.stakePoolVotes | reduce(..|select(strings=="VoteYes")) as $_ (0; .+1)),\(.stakePoolVotes | reduce(..|select(strings=="VoteNo")) as $_ (0; .+1)),\(.committeeVotes | reduce(..|select(strings=="VoteYes")) as $_ (0; .+1)),\(.committeeVotes | reduce(..|select(strings=="VoteNo")) as $_ (0; .+1))"' <<< "$(base64 -d <<< "${vote_action}")" )
      isParameterSecurityGroup=N
      if [[ $(jq -r '.proposalProcedure.govAction.tag' <<< "$(base64 -d <<< "${vote_action}")") = "ParameterChange" ]]; then
        parameterChange=$(jq -e '.proposalProcedure.govAction.contents[1] | keys[]' <<< "$(base64 -d <<< "${vote_action}")")
        getParameterChangeGroups
      fi
      getVoteThreshold "$(jq -r '.proposalProcedure.govAction.tag' <<< "$(base64 -d <<< "${vote_action}")")"
      
      # get list of drep voters based on vote
      drep_yes_voters="$(jq '[.dRepVotes | to_entries[] | select(.value=="VoteYes") | ("drep-" + .key)]' <<< "$(base64 -d <<< "${vote_action}")")"
      drep_no_voters="$(jq '[.dRepVotes | to_entries[] | select(.value=="VoteNo") | ("drep-" + .key)]' <<< "$(base64 -d <<< "${vote_action}")")"
      drep_abstain_voters="$(jq '[.dRepVotes | to_entries[] | select(.value=="Abstain") | ("drep-" + .key)]' <<< "$(base64 -d <<< "${vote_action}")")"
      # get sum of vote power for each type
      drep_yes_vote_power="$(jq -r --argjson v "${drep_yes_voters}" '[.[] | select(.[0] | IN($v[])) | .[1]] | add //0' <<< "${all_drep_vote_power}")"
      drep_no_vote_power="$(jq -r --argjson v "${drep_no_voters}" '[.[] | select(.[0] | IN($v[])) | .[1]] | add //0' <<< "${all_drep_vote_power}")"
      drep_abstain_vote_power="$(jq -r --argjson v "${drep_abstain_voters}" '[.[] | select(.[0] | IN($v[])) | .[1]] | add //0' <<< "${all_drep_vote_power}")"
      drep_power_total=$(( drep_power_total_no_abstain - drep_abstain_vote_power ))
      drep_no_vote_power_total=$(( drep_power_total - drep_yes_vote_power )) # total drep power - always abstain - proposal abstain - proposal yes
      if [[ ${proposal_type} = "NoConfidence" ]]; then
        # add alwaysNoConfidence power to yes vote
        drep_always_no_confidence="$(jq -r '[.[] | select(.[0] == "drep-alwaysNoConfidence") | .[1]] | add //0' <<< "${all_drep_vote_power}" 2>/dev/null)"
        drep_yes_vote_power=$(( drep_yes_vote_power + drep_always_no_confidence ))
        drep_no_vote_power_total=$(( drep_no_vote_power_total - (drep_always_no_confidence * 2) ))
      fi
      # calculate percentages
      drep_yes_pct=$(printf '%.2f' "$(bc -l <<< "(${drep_yes_vote_power}/${drep_power_total})*100")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      drep_no_pct=$(printf '%.2f' "$(bc -l <<< "(${drep_no_vote_power_total}/${drep_power_total})*100")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      # find votes by own DReps
      while IFS= read -r -d '' wallet; do
        wallet_name=$(basename ${wallet})
        getGovKeyInfo ${wallet_name}
        [[ -z ${drep_hash} ]] && continue
        for drep in ${drep_yes_voters[@]}; do
          [[ ${drep} = *"${hash_type}-${drep_hash}"* ]] && own_drep_votes+=( "${proposal_id};${wallet_name};Yes" ) && continue 2
        done
        for drep in ${drep_no_voters[@]}; do
          [[ ${drep} = *"${hash_type}-${drep_hash}"* ]] && own_drep_votes+=( "${proposal_id};${wallet_name};No" ) && continue 2
        done
        for drep in ${drep_abstain_voters[@]}; do
          [[ ${drep} = *"${hash_type}-${drep_hash}"* ]] && own_drep_votes+=( "${proposal_id};${wallet_name};Abstain" ) && continue 2
        done
      done < <(find "${WALLET_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
      
      # get list of spo voters based on vote
      spo_yes_voters="$(jq '[.stakePoolVotes | to_entries[] | select(.value=="VoteYes") | .key]' <<< "$(base64 -d <<< "${vote_action}")")"
      spo_no_voters="$(jq '[.stakePoolVotes | to_entries[] | select(.value=="VoteNo") | .key]' <<< "$(base64 -d <<< "${vote_action}")")"
      spo_abstain_voters="$(jq '[.stakePoolVotes | to_entries[] | select(.value=="Abstain") | .key]' <<< "$(base64 -d <<< "${vote_action}")")"
      # get sum of vote power for each type
      spo_yes_vote_power="$(jq -r --argjson v "${spo_yes_voters}" '[.[] | select(.[0] | IN($v[])) | .[1]] | add //0' <<< "${all_spo_vote_power}")"
      spo_no_vote_power="$(jq -r --argjson v "${spo_no_voters}" '[.[] | select(.[0] | IN($v[])) | .[1]] | add //0' <<< "${all_spo_vote_power}")"
      spo_abstain_vote_power="$(jq -r --argjson v "${spo_abstain_voters}" '[.[] | select(.[0] | IN($v[])) | .[1]] | add //0' <<< "${all_spo_vote_power}")"
      spo_power_total=$(( spo_power_total - spo_abstain_vote_power ))
      spo_no_vote_power_total=$(( spo_power_total - spo_yes_vote_power )) # total spo power - proposal abstain - proposal yes
      # calculate percentages
      spo_yes_pct=$(printf '%.2f' "$(bc -l <<< "(${spo_yes_vote_power}/${spo_power_total})*100")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      spo_no_pct=$(printf '%.2f' "$(bc -l <<< "(${spo_no_vote_power_total}/${spo_power_total})*100")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      # find votes by own pools
      while IFS= read -r -d '' pool; do
        pool_name=$(basename ${pool})
        getPoolID ${pool_name} || continue
        for spo in ${spo_yes_voters[@]}; do
          [[ ${spo} = *"${pool_id}"* ]] && own_spo_votes+=( "${proposal_id};${pool_name};Yes" ) && continue 2
        done
        for spo in ${spo_no_voters[@]}; do
          [[ ${spo} = *"${pool_id}"* ]] && own_spo_votes+=( "${proposal_id};${pool_name};No" ) && continue 2
        done
        for spo in ${spo_abstain_voters[@]}; do
          [[ ${spo} = *"${pool_id}"* ]] && own_spo_votes+=( "${proposal_id};${pool_name};Abstain" ) && continue 2
        done
      done < <(find "${POOL_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
      
      # get list of cc voters based on vote
      cc_yes_voters="$(jq '[.committeeVotes | to_entries[] | select(.value=="VoteYes")] | length' <<< "$(base64 -d <<< "${vote_action}")")"
      cc_no_voters="$(jq '[.committeeVotes | to_entries[] | select(.value=="VoteNo")] | length' <<< "$(base64 -d <<< "${vote_action}")")"
      cc_abstain_voters="$(jq '[.committeeVotes | to_entries[] | select(.value=="Abstain")] | length' <<< "$(base64 -d <<< "${vote_action}")")"
      cc_power_total=$(( cc_power_authorized - cc_abstain_voters ))
      cc_no_voters_total=$(( cc_power_total - cc_yes_voters )) # total cc power - proposal abstain - proposal yes
      # calculate percentages
      if [[ ${cc_power_total} -eq 0 ]]; then
        cc_yes_pct=0
        cc_no_pct=0
      else
        cc_yes_pct=$(printf '%.2f' "$(bc -l <<< "(${cc_yes_voters}/${cc_power_total})*100")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
        cc_no_pct=$(printf '%.2f' "$(bc -l <<< "(${cc_no_voters_total}/${cc_power_total})*100")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
      fi
      while IFS= read -r -d '' wallet; do
        wallet_name=$(basename ${wallet})
        getGovKeyInfo ${wallet_name}
        [[ -z ${cc_hot_hash} ]] && continue
        for cc_hot in ${cc_yes_voters[@]}; do
          [[ ${cc_hot} = *"${cc_hot_hash}"* ]] && own_cc_votes+=( "${proposal_id};${wallet_name};Yes" ) && continue 2
        done
        for cc_hot in ${cc_no_voters[@]}; do
          [[ ${cc_hot} = *"${cc_hot_hash}"* ]] && own_cc_votes+=( "${proposal_id};${wallet_name};No" ) && continue 2
        done
        for cc_hot in ${cc_abstain_voters[@]}; do
          [[ ${cc_hot} = *"${cc_hot_hash}"* ]] && own_cc_votes+=( "${proposal_id};${wallet_name};Abstain" ) && continue 2
        done
      done < <(find "${WALLET_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
      
      _vote_action_list+=( "${proposal_id},${proposal_type},${proposed_epoch},${expiration:=0},${meta_url},${drep_yes_votes_cast},${drep_yes_vote_power},${drep_yes_pct},${drep_no_votes_cast},${drep_no_vote_power_total},${drep_no_pct},${spo_yes_votes_cast},${spo_yes_vote_power},${spo_yes_pct},${spo_no_votes_cast},${spo_no_vote_power_total},${spo_no_pct},${cc_yes_votes_cast},${cc_yes_pct},${cc_no_votes_cast},${cc_no_pct},${drep_vt},${spo_vt},${cc_vt},${isParameterSecurityGroup}" )
    done
    # reverse order
    for ((i=${#_vote_action_list[@]}-1; i>=0; i--)); do
      vote_action_list+=( "${_vote_action_list[$i]}" )
    done
  fi
}

# Command     : getParameterChangeGroups
# Description : assumed parameterChange is populated with list of parameter changes, including quotation marks
# Return      : sets isParameterSecurityGroup isNetworkGroup isEconomicGroup isTechnicalGroup isGovernanceGroup
getParameterChangeGroups() {
  unset isParameterSecurityGroup isNetworkGroup isEconomicGroup isTechnicalGroup isGovernanceGroup
  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    [[ $parameterChange =~ (\"max_block_size\"|\"max_tx_size\"|\"max_bh_size\"|\"max_val_size\"|\"max_block_ex_|\"min_fee_a\"|\"min_fee_b\"|\"coins_per_utxo_size\"|\"gov_action_deposit\"|\"min_fee_ref_script_cost_per_byte\") ]] && isParameterSecurityGroup=Y
    [[ $parameterChange =~ (\"max_block_size\"|\"max_tx_size\"|\"max_bh_size\"|\"max_val_size\"|\"max_tx_ex_|\"max_block_ex_|\"max_collateral_inputs\") ]] && isNetworkGroup=Y
    [[ $parameterChange =~ (\"min_fee_a\"|\"min_fee_b\"|\"key_deposit\"|\"pool_deposit\"|\"monetary_expand_rate\"|\"treasury_growth_rate\"|\"min_pool_cost\"|\"coins_per_utxo_size\"|\"coins_per_utxo_size\"|\"price_) ]] && isEconomicGroup=Y
    [[ $parameterChange =~ (\"influence\"|\"max_epoch\"|\"optimal_pool_count\"|\"cost_model_id\"|\"collateral_percent\") ]] && isTechnicalGroup=Y
    [[ $parameterChange =~ (\"gov_action_lifetime\"|\"gov_action_deposit\"|\"drep_deposit\"|\"drep_activity\"|\"committee_min_size\"|\"committee_max_term_length\"|\"pvt_|\"dvt_) ]] && isGovernanceGroup=Y
  elif [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
    [[ $parameterChange =~ (\"maxBlockBodySize\"|\"maxTxSize\"|\"maxBlockHeaderSize\"|\"maxValueSize\"|\"maxBlockExecutionUnits\"|\"txFeePerByte\"|\"txFeeFixed\"|\"utxoCostPerByte\"|\"govActionDeposit\"|\"minFeeRefScriptCostPerByte\") ]] && isParameterSecurityGroup=Y
    [[ $parameterChange =~ (\"maxBlockBodySize\"|\"maxTxSize\"|\"maxBlockHeaderSize\"|\"maxValueSize\"|\"maxTxExecutionUnits\"|\"maxBlockExecutionUnits\"|\"maxCollateralInputs\") ]] && isNetworkGroup=Y
    [[ $parameterChange =~ (\"txFeePerByte\"|\"txFeeFixed\"|\"stakeAddressDeposit\"|\"stakePoolDeposit\"|\"monetaryExpansion\"|\"treasuryCut\"|\"minPoolCost\"|\"utxoCostPerByte\"|\"executionUnitPrices\") ]] && isEconomicGroup=Y
    [[ $parameterChange =~ (\"poolPledgeInfluence\"|\"poolRetireMaxEpoch\"|\"stakePoolTargetNum\"|\"costModels\"|\"collateralPercentage\") ]] && isTechnicalGroup=Y
    [[ $parameterChange =~ (\"govActionLifetime\"|\"govActionDeposit\"|\"dRepDeposit\"|\"dRepActivity\"|\"committeeMinSize\"|\"committeeMaxTermLength\"|\"VotingThresholds\") ]] && isGovernanceGroup=Y
  fi
}

# Command     : getVoteThreshold [type]
# Description : assumed getCurrentCommittee, getParameterThresholds & getParameterChangeGroups are called before this one
# Return      : Threshold for each type returned as a percentage. '-' if not valid for type.
getVoteThreshold() {
  case ${1} in
    "InfoAction") unset drep_vt spo_vt cc_vt ;; # no thresholds
    "NoConfidence")
      drep_vt=${dvt_motionNoConf}
      spo_vt=${pvt_motionNoConf}
      unset cc_vt
      ;;
    "HardForkInitiation")
      drep_vt=${dvt_HFInit}
      spo_vt=${pvt_HFInit}
      cc_vt=${cc_threshold}
      ;;
    "NewCommittee"|"UpdateCommittee")
      # TODO: Are we in Normal or NoConfidence state?
      drep_vt=${dvt_newCCNormal}
      spo_vt=${pvt_newCCNormal}
      unset cc_vt
      ;;
    "TreasuryWithdrawals")
      drep_vt=${dvt_treasuryWithdrawal}
      unset spo_vt
      cc_vt=${cc_threshold}
      ;;
    "ParameterChange")
      if versionCheck "10.0" "${PROT_VERSION}"; then
        # get highest of matching groups
        drep_vt=0
          if [[ ${isNetworkGroup} = Y ]]    && (( $(bc -l <<< "${dvt_ppNetGrp}  > ${drep_vt}") )); then drep_vt=${dvt_ppNetGrp}
        elif [[ ${isEconomicGroup} = Y ]]   && (( $(bc -l <<< "${dvt_ppEcoGrp}  > ${drep_vt}") )); then drep_vt=${dvt_ppEcoGrp}
        elif [[ ${isTechnicalGroup} = Y ]]  && (( $(bc -l <<< "${dvt_ppTechGrp} > ${drep_vt}") )); then drep_vt=${dvt_ppTechGrp}
        elif [[ ${isGovernanceGroup} = Y ]] && (( $(bc -l <<< "${dvt_ppGovGrp}  > ${drep_vt}") )); then drep_vt=${dvt_ppGovGrp}
        else unset drep_vt
        fi
      else
        unset drep_vt
      fi
      [[ ${isParameterSecurityGroup} = Y ]] && spo_vt=${pvt_ppSecGrp} || unset spo_vt
      cc_vt=${cc_threshold}
      ;;
    "NewConstitution")
      drep_vt=${dvt_newConst}
      unset spo_vt
      cc_vt=${cc_threshold}
      ;;
  esac
}

# Command     : isAllowedToVote [role] [type] [isParameterSecurityGroup (Y|N)]
# Return      : 0 = ok
#               1 = not allowed by role
#               2 = parameter change not of type Security Group
#               3 = chang-1 limitation
isAllowedToVote() {
  [[ -z $1 || -z $2 || -z $3 ]] && return 1
  case ${2} in
    "NoConfidence")
      [[ $1 = committee ]] && return 1
      ;;
    "HardForkInitiation")
      [[ $1 = drep ]] && ! versionCheck "10.0" "${PROT_VERSION}" && return 3
      ;;
    "InfoAction")
      : ;; # always allowed by all
    "NewCommittee"|"UpdateCommittee")
      [[ $1 = committee ]] && return 1
      ;;
    "TreasuryWithdrawals")
      [[ $1 = spo ]] && return 1
      ;;
    "ParameterChange")
      [[ $1 = spo && $3 = N ]] && return 2
      [[ $1 = drep ]] && ! versionCheck "10.0" "${PROT_VERSION}" && return 3
      ;;
    "NewConstitution")
      [[ $1 = spo ]] && return 1
      ;;
  esac
  return 0
}

# Command     : getParameterThresholds
# Description : fetches DRep / SPO thresholds from PROT_PARAMS into variables
getParameterThresholds() {
  read -r dvt_newCCNoConf dvt_newCCNormal dvt_HFInit dvt_motionNoConf dvt_ppEcoGrp dvt_ppGovGrp dvt_ppNetGrp dvt_ppTechGrp dvt_treasuryWithdrawal dvt_newConst pvt_newCCNoConf pvt_newCCNormal pvt_HFInit pvt_motionNoConf pvt_ppSecGrp <<<"$(jq -r '[
    (.dRepVotingThresholds.committeeNoConfidence //0) * 100,
    (.dRepVotingThresholds.committeeNormal //0) * 100,
    (.dRepVotingThresholds.hardForkInitiation //0) * 100,
    (.dRepVotingThresholds.motionNoConfidence //0) * 100,
    (.dRepVotingThresholds.ppEconomicGroup //0) * 100,
    (.dRepVotingThresholds.ppGovGroup //0) * 100,
    (.dRepVotingThresholds.ppNetworkGroup //0) * 100,
    (.dRepVotingThresholds.ppTechnicalGroup //0) * 100,
    (.dRepVotingThresholds.treasuryWithdrawal //0) * 100,
    (.dRepVotingThresholds.updateToConstitution //0) * 100,
    (.poolVotingThresholds.committeeNoConfidence //0) * 100,
    (.poolVotingThresholds.committeeNormal //0) * 100,
    (.poolVotingThresholds.hardForkInitiation //0) * 100,
    (.poolVotingThresholds.motionNoConfidence //0) * 100,
    (.poolVotingThresholds.ppSecurityGroup //0) * 100
    ] | @tsv' <<<"${PROT_PARAMS}" 2>/dev/null)"
}

# Command     : getCurrentCommittee
# Return      : 0 = valid member, 1 = not a member, 2 = not authorized
getCurrentCommittee() {
  unset committee_info
  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "accept: application/json")
    println ACTION "curl -sSL -f -X GET ${HEADERS[*]} ${KOIOS_API}/committee_info"
    committee_info=$(curl -sSL -f -X GET "${HEADERS[@]}" "${KOIOS_API}/committee_info")
    cc_threshold=$(printf '%.2f' "$(jq -r '(.[0].quorum_numerator //0) / (.[0].quorum_denominator //1) * 100' <<< "${committee_info}")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
  elif [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
    println ACTION "${CCLI} conway query committee-state ${NETWORK_IDENTIFIER}"
    committee_info=$(${CCLI} conway query committee-state ${NETWORK_IDENTIFIER})
    cc_threshold=$(printf '%.2f' "$(jq -r '(.threshold.numerator //0) / (.threshold.denominator //1) * 100' <<< "${committee_info}")" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
  fi
}

# Command     : isCommitteeMember [cold hash] [hot hash]
# Description : check if supplied hash is part of current committee list
# Return      : 0 = valid member, 1 = not a member, 2 = not authorized, 3 = resigned
isCommitteeMember() {
  [[ -z $1 || -z $2 ]] && return 1
  getCurrentCommittee
  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    grep -q $1 <<< "${committee_info}" || return 1
    grep -q resigned <<< "${committee_info}" && return 3
    grep -q $2 <<< "${committee_info}" || return 2
  else
    committee_member=$(jq -r --arg cc_cold_hash "$1" 'first(.committee | to_entries[] | select(.key | contains($cc_cold_hash))) | .value' <<< "${committee_info}")
    [[ -z ${committee_member} ]] && return 1
    grep -i -q resigned <<< "${committee_member}" && return 3
    grep -q $2 <<< "$(jq -r '.hotCredsAuthStatus.contents // [] | .[]' <<< "$committee_member")" || return 1
  fi
  return 0
}

# Command     : getBaseAddress [wallet name] | [payment.vkey] [stake.vkey]
# Description : create, store and save base address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${base_addr}
getBaseAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  payment_script_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}"
  stake_script_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SCRIPT_FILENAME}"
  base_addr_file="${WALLET_FOLDER}/${1}/${WALLET_BASE_ADDR_FILENAME}"
  [[ -f ${base_addr_file} ]] && base_addr=$(cat "${base_addr_file}") && return 0
  unset base_addr
  if [[ -f "${payment_vk_file}" && -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file ${payment_vk_file} --stake-verification-key-file ${stake_vk_file} --out-file ${base_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file "${payment_vk_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      base_addr=$(cat "${base_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${stdout}"
    fi
  elif [[ -f "${payment_script_file}" && -f "${stake_script_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-script-file ${payment_script_file} --stake-script-file ${stake_script_file} --out-file ${base_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-script-file "${payment_script_file}" --stake-script-file "${stake_script_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      base_addr=$(cat "${base_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${stdout}"
    fi
  elif [[ -f "${payment_script_file}" && -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-script-file ${payment_script_file} --stake-verification-key-file ${stake_vk_file} --out-file ${base_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-script-file "${payment_script_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      base_addr=$(cat "${base_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${stdout}"
    fi
  elif [[ -f "${payment_vk_file}" && -f "${stake_script_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file ${payment_vk_file} --stake-script-file ${stake_script_file} --out-file ${base_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file "${payment_vk_file}" --stake-script-file "${stake_script_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      base_addr=$(cat "${base_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${stdout}"
    fi
  elif [[ $# -eq 2 && -f "${1}" && -f "${2}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file ${1} --stake-verification-key-file ${2} ${NETWORK_IDENTIFIER}"
    if base_addr=$(${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file "${1}" --stake-verification-key-file "${2}" ${NETWORK_IDENTIFIER} 2>&1); then
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${base_addr}"
    fi
  fi
  return 1
}

# Command     : getRewardAddress [wallet name]
# Description : create, store and save reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_addr} ${is_reward_script_addr}
getRewardAddress() {
  unset reward_addr is_reward_script_addr
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_script_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SCRIPT_FILENAME}"
  stake_addr_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_ADDR_FILENAME}"
  [[ -f "${stake_script_file}" ]] && is_reward_script_addr=true || is_reward_script_addr=false
  [[ -f ${stake_addr_file} ]] && reward_addr=$(cat "${stake_addr_file}") && return 0
  if [[ -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file ${stake_vk_file} --out-file ${stake_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      reward_addr=$(cat "${stake_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during reward address creation!\n${stdout}"
    fi
  elif [[ -f "${stake_script_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} stake-address build --stake-script-file ${stake_script_file} --out-file ${stake_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} stake-address build --stake-script-file "${stake_script_file}" --out-file "${stake_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      reward_addr=$(cat "${stake_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during reward script address creation!\n${stdout}"
    fi
  elif [[ -f "${1}" ]]; then
    getRewardAddressFromKey ${1}
    return $?
  fi
  return 1
}

# Command     : getRewardAddressFromKey [stake vkey]
# Description : get reward address from a stake key
# Parameters  : stake key  >  path to stake.vkey file
# Return      : populates ${reward_addr}
getRewardAddressFromKey() {
  println ACTION "${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file ${1} ${NETWORK_IDENTIFIER}"
  if ! reward_addr=$(${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file "${1}" ${NETWORK_IDENTIFIER} 2>&1); then
    println LOG "\n${FG_RED}ERROR${NC}: failure during reward address creation!\n${base_addr}"
    return 1
  fi
}

# Command     : getCredential [type] [file]
# Description : create and save wallet credentials (key hash) for payment and stake keys (incl MultiSig)
# Parameters  : type  >  payment | stake | drep
#             : file  >  path to verification file
# Return      : populates ${cred}
getCredential() {
  unset cred
  [[ ! -f "$2" ]] && return 1
  if [[ $1 = drep ]]; then
    println ACTION "${CCLI} conway governance drep id --drep-verification-key-file $2 | bech32"
    if ! _drep_id=$(${CCLI} conway governance drep id --drep-verification-key-file "$2" 2>&1); then
      println LOG "\n${FG_RED}ERROR${NC}: failure during key hash creation!\n${cred}"
      unset cred
      return 1
    fi
    cred=$(bech32 <<< "${_drep_id}")
  else
    [[ $1 = payment ]] && CLI_ARGS=("--payment-verification-key-file" "$2") || CLI_ARGS=("--stake-verification-key-file" "$2")
    println ACTION "${CCLI} ${NETWORK_ERA} address key-hash ${CLI_ARGS[*]}"
    if ! cred=$(${CCLI} ${NETWORK_ERA} address key-hash "${CLI_ARGS[@]}" 2>&1); then
      println LOG "\n${FG_RED}ERROR${NC}: failure during key hash creation!\n${cred}"
      unset cred
      return 1
    fi
  fi
  return 0
}

# Command     : getCredentials [wallet name]
# Description : create and save wallet credentials (key hash) for payment and stake keys (incl MultiSig)
# Parameters  : wallet name  >  the name of the wallet
getCredentials() {
  unset pay_cred stake_cred ms_pay_cred ms_stake_cred script_pay_cred script_stake_cred
  payment_cred_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_CRED_FILENAME}"
  stake_cred_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_CRED_FILENAME}"
  ms_payment_cred_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_PAY_CRED_FILENAME}"
  ms_stake_cred_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_STAKE_CRED_FILENAME}"
  script_payment_cred_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_CRED_FILENAME}"
  script_stake_cred_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SCRIPT_CRED_FILENAME}"
  [[ -f ${payment_cred_file} ]] && pay_cred=$(cat "${payment_cred_file}")
  [[ -f ${stake_cred_file} ]] && stake_cred=$(cat "${stake_cred_file}")
  [[ -f ${ms_payment_cred_file} ]] && ms_pay_cred=$(cat "${ms_payment_cred_file}")
  [[ -f ${ms_stake_cred_file} ]] && ms_stake_cred=$(cat "${ms_stake_cred_file}")
  [[ -f ${script_payment_cred_file} ]] && script_pay_cred=$(cat "${script_payment_cred_file}")
  [[ -f ${script_stake_cred_file} ]] && script_stake_cred=$(cat "${script_stake_cred_file}")
  if [[ -z ${pay_cred} ]]; then
    payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
    if [[ -f "${payment_vk_file}" ]]; then
      println ACTION "${CCLI} ${NETWORK_ERA} address key-hash --payment-verification-key-file ${payment_vk_file} --out-file ${payment_cred_file}"
      if stdout=$(${CCLI} ${NETWORK_ERA} address key-hash --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_cred_file}" 2>&1); then
        pay_cred=$(cat "${payment_cred_file}")
      else
        println LOG "\n${FG_RED}ERROR${NC}: failure during payment key hash creation!\n${stdout}"
        return 1
      fi
    fi
  fi
  if [[ -z ${stake_cred} ]]; then
    stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
    if [[ -f "${stake_vk_file}" ]]; then
      println ACTION "${CCLI} ${NETWORK_ERA} stake-address key-hash --stake-verification-key-file ${stake_vk_file} --out-file ${stake_cred_file}"
      if stdout=$(${CCLI} ${NETWORK_ERA} stake-address key-hash --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_cred_file}" 2>&1); then
        stake_cred=$(cat "${stake_cred_file}")
      else
        println LOG "\n${FG_RED}ERROR${NC}: failure during stake key hash creation!\n${stdout}"
        return 1
      fi
    fi
  fi
  if [[ -z ${ms_pay_cred} ]]; then
    ms_payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_PAY_VK_FILENAME}"
    if [[ -f "${ms_payment_vk_file}" ]]; then
      println ACTION "${CCLI} ${NETWORK_ERA} address key-hash --payment-verification-key-file ${ms_payment_vk_file} --out-file ${ms_payment_cred_file}"
      if stdout=$(${CCLI} ${NETWORK_ERA} address key-hash --payment-verification-key-file "${ms_payment_vk_file}" --out-file "${ms_payment_cred_file}" 2>&1); then
        ms_pay_cred=$(cat "${ms_payment_cred_file}")
      else
        println LOG "\n${FG_RED}ERROR${NC}: failure during MultiSig payment key hash creation!\n${stdout}"
        return 1
      fi
    fi
  fi
  if [[ -z ${ms_stake_cred} ]]; then
    ms_stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_STAKE_VK_FILENAME}"
    if [[ -f "${ms_stake_vk_file}" ]]; then
      println ACTION "${CCLI} ${NETWORK_ERA} stake-address key-hash --stake-verification-key-file ${ms_stake_vk_file} --out-file ${ms_stake_cred_file}"
      if stdout=$(${CCLI} ${NETWORK_ERA} stake-address key-hash --stake-verification-key-file "${ms_stake_vk_file}" --out-file "${ms_stake_cred_file}" 2>&1); then
        ms_stake_cred=$(cat "${ms_stake_cred_file}")
      else
        println LOG "\n${FG_RED}ERROR${NC}: failure during MultiSig stake key hash creation!\n${stdout}"
        return 1
      fi
    fi
  fi
  if [[ -z ${script_pay_cred} ]]; then
    payment_script_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}"
    if [[ -f "${payment_script_file}" ]]; then
      println ACTION "${CCLI} ${NETWORK_ERA} transaction policyid --script-file ${payment_script_file} --out-file ${script_payment_cred_file}"
      if stdout=$(${CCLI} ${NETWORK_ERA} transaction policyid --script-file "${payment_script_file}" --out-file "${script_payment_cred_file}" 2>&1); then
        script_pay_cred=$(cat "${script_payment_cred_file}")
      else
        println LOG "\n${FG_RED}ERROR${NC}: failure during script payment policy creation!\n${stdout}"
        return 1
      fi
    fi
  fi
  if [[ -z ${script_stake_cred} ]]; then
    stake_script_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SCRIPT_FILENAME}"
    if [[ -f "${stake_script_file}" ]]; then
      println ACTION "${CCLI} ${NETWORK_ERA} transaction policyid --script-file ${stake_script_file} --out-file ${script_stake_cred_file}"
      if stdout=$(${CCLI} ${NETWORK_ERA} transaction policyid --script-file "${stake_script_file}" --out-file "${script_stake_cred_file}" 2>&1); then
        script_stake_cred=$(cat "${script_stake_cred_file}")
      else
        println LOG "\n${FG_RED}ERROR${NC}: failure during script stake policy creation!\n${stdout}"
        return 1
      fi
    fi
  fi
}

# Command     : getAddressInfo [address]
# Description : get address info from from node
# Parameters  : address  >  the wallet address to query
# Return      : populates ${address_info}
getAddressInfo() {
  println ACTION "${CCLI} ${NETWORK_ERA} address info --address $1"
  if ! address_info=$(${CCLI} ${NETWORK_ERA} address info --address $1 2>&1); then
    println LOG "\n${FG_RED}ERROR${NC}: failure during reward address creation!\n${base_addr}"
    return 1
  fi
}

# Command     : getBalance [address]
# Description : check balance for provided address
# Parameters  : address  >  the wallet address to query
getBalance() {
  declare -gA utxos=(); declare -gA assets=()
  assets["lovelace"]=0; utxo_cnt=0
  asset_name_maxlen=5; asset_amount_maxlen=12
  tx_in=""
  
  if [[ -z ${1} ]] || ! utxo_raw=$(${CCLI} ${NETWORK_ERA} query utxo ${NETWORK_IDENTIFIER} --address "${1}"); then return 1; fi
  [[ -z ${utxo_raw} ]] && return
  
  while IFS= read -r line; do
    IFS=' ' read -ra utxo_entry <<< "${line}"
    [[ ${#utxo_entry[@]} -lt 4 ]] && continue
    ((utxo_cnt++))
    tx_in+=" --tx-in ${utxo_entry[0]}#${utxo_entry[1]}"
    if [[ ${utxo_entry[3]} = "lovelace" ]]; then
      utxos["${utxo_entry[0]}#${utxo_entry[1]}. ADA"]=${utxo_entry[2]} # Space added before 'ADA' for sort to place it first
      assets["lovelace"]=$(( ${assets["lovelace"]:-0} + utxo_entry[2] ))
      idx=5
    else
      utxos["${utxo_entry[0]}#${utxo_entry[1]}. ADA"]=0 # Space added before 'ADA' for sort to place it first
      assets["lovelace"]=0
      idx=2
    fi
    if [[ ${#utxo_entry[@]} -gt "${idx}" ]]; then
      while [[ ${#utxo_entry[@]} -gt ${idx} ]]; do
        asset_amount=${utxo_entry[${idx}]}
        if ! isNumber "${asset_amount}"; then break; fi
        asset_hash_name="${utxo_entry[$((idx+1))]}"
        IFS='.' read -ra asset <<< "${asset_hash_name}"
        tname="$(hexToAscii ${asset[1]})"
        tname="${tname//[![:print:]]/}"
        [[ ${#asset[@]} -eq 2 && ${#tname} -gt ${asset_name_maxlen} ]] && asset_name_maxlen=${#tname}
        asset_amount_fmt="$(formatAsset ${asset_amount})"
        [[ ${#asset_amount_fmt} -gt ${asset_amount_maxlen} ]] && asset_amount_maxlen=${#asset_amount_fmt}
        assets["${asset_hash_name}"]=$(( ${assets["${asset_hash_name}"]:-0} + asset_amount ))
        utxos["${utxo_entry[0]}#${utxo_entry[1]}.${asset_hash_name}"]=${asset_amount}
        idx=$(( idx + 3 ))
      done
    fi
  done <<< "${utxo_raw}"

  [[ ${asset_name_maxlen} -ne 5 ]] && asset_name_maxlen=$(( asset_name_maxlen / 2 ))
  lovelace_fmt="$(formatLovelace ${assets["lovelace"]})"
  [[ ${#lovelace_fmt} -gt ${asset_amount_maxlen} ]] && asset_amount_maxlen=${#lovelace_fmt}
}

# Command     : getBalanceKoios parse_assets
# Description : check balance for provided addresses using Koios API
# Parameters  : parse_assets  >  [true|false] should additional assets on utxo be parsed or not (default=true)
getBalanceKoios() {
  # generate different arrays using key constructed in format: <address>,<additional fields...>
  # Ex: ( [addr123,lovelace]=1000 [addr456,policy.name]=500 )
  # Its assumed that an array called addr_list has been populated with all addresses to fetch balance for

  declare -gA utxos=(); declare -gA utxos_cnt=(); declare -gA assets=(); declare -gA tx_in_arr=(); declare -gA asset_name_maxlen_arr=(); declare -gA asset_amount_maxlen_arr=()

  if [[ -n ${KOIOS_API} && -n ${addr_list+x} ]]; then
    printf -v addr_list_joined '\"%s\",' "${addr_list[@]}"
    [[ $1 != false ]] && extended=true || extended=false
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "Content-Type: application/json" -H "accept: text/csv")
    println ACTION "curl -sSL -f -X POST ${HEADERS[*]} -d '{\"_addresses\":[${addr_list_joined%,}],\"_extended\":${extended}}' ${KOIOS_API}/address_utxos?select=address,tx_hash,tx_index,value,asset_list"
    ! address_utxo_list=$(curl -sSL -f -X POST "${HEADERS[@]}" -d '{"_addresses":['${addr_list_joined%,}'],"_extended":'${extended}'}' "${KOIOS_API}/address_utxos?select=address,tx_hash,tx_index,value,asset_list" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${address_utxo_list}\n" && return 1 # print error and return
    [[ -z ${address_utxo_list} ]] && return
    while IFS=',' read -r _address _tx_hash _tx_index _value _asset_list; do
      index_prefix="${_address},"
      assets["${index_prefix}lovelace"]=$(( ${assets["${index_prefix}lovelace"]:-0} + _value ))
      utxos["${index_prefix}${_tx_hash}#${_tx_index}. ADA"]=${_value}
      utxos_cnt["${_address}"]=$(( ${utxos_cnt["${_address}"]:-0} + 1 ))
      tx_in_arr["${_address}"]="${tx_in_arr["${_address}"]} --tx-in ${_tx_hash}#${_tx_index}"
      if [[ $1 != false ]]; then
        asset_list_unescaped=${_asset_list:1: -1} # remove first and last char (quotation)
        asset_list_unescaped=$(sed 's/""/"/g' <<< "${asset_list_unescaped}") # remove all double quotes, sed seems to perform better than bash string manipulation
        while IFS=',' read -r _policy_id _asset_name _quantity; do
          tname="$(hexToAscii ${_asset_name})"
          tname="${tname//[![:print:]]/}"
          [[ ${#tname} -gt ${asset_name_maxlen_arr["${_address}"]:-5} ]] && asset_name_maxlen_arr["${_address}"]=${#tname}
          asset_amount_fmt="$(formatAsset ${_quantity})"
          [[ ${#asset_amount_fmt} -gt ${asset_amount_maxlen_arr["${_address}"]:-12} ]] && asset_amount_maxlen_arr["${_address}"]=${#asset_amount_fmt}
          assets["${index_prefix}${_policy_id}.${_asset_name}"]=$(( ${assets["${index_prefix}${_policy_id}.${_asset_name}"]:-0} + _quantity ))
          utxos["${index_prefix}${_tx_hash}#${_tx_index}.${_policy_id}.${_asset_name}"]=${_quantity}
        done < <( jq -cr '.[] | "\(.policy_id),\(.asset_name),\(.quantity)"' <<< "${asset_list_unescaped}" )
      fi
    done <<< "$(tail -n +2 <<< ${address_utxo_list})"
  fi
}

# Command     : getWalletBalance [wallet name] [force] [base] [pay] [asset]
# Description : get balance for wallet
# Parameters  : force  >  optional: [true|false] force update of balance (default = false)
#             : base   >  optional: [true|false] get base address balance (default = true)
#             : pay    >  optional: [true|false] get payment address balance (default = true)
#             : asset  >  optional: [true|false] fetch additional koios asset data (default = false)
getWalletBalance() {
  addr_list=()
  declare -gA base_assets=(); declare -gA pay_assets=()
  [[ $2 = true ]] && declare -gA balances=()
  [[ $5 = true ]] && asset_info=true || asset_info=false
  if [[ $3 != false ]] && getBaseAddress $1 && [[ -n ${base_addr} ]]; then
    if [[ -v balances[${base_addr}] ]]; then
      base_lovelace=${balances[${base_addr}]}
    else
      if [[ -n ${KOIOS_API} ]]; then
        addr_list+=(${base_addr})
      else
        getBalance ${base_addr}
        base_lovelace=${assets[lovelace]:-0}
        for idx in "${!assets[@]}"; do base_assets[${idx}]=${assets[${idx}]}; done
      fi
    fi
  else
    base_lovelace=0
  fi
  if [[ $4 != false ]] && getPayAddress $1 && [[ -n ${pay_addr} ]]; then
    if [[ -v balances[${pay_addr}] ]]; then
      pay_lovelace=${balances[${pay_addr}]}
    else
      if [[ -n ${KOIOS_API} ]]; then
        addr_list+=(${pay_addr})
      else
        getBalance ${pay_addr}
        pay_lovelace=${assets[lovelace]:-0}
        for idx in "${!assets[@]}"; do pay_assets[${idx}]=${assets[${idx}]}; done
      fi
    fi
  else
    pay_lovelace=0
  fi
  if [[ ${#addr_list[@]} -gt 0 ]]; then
    getBalanceKoios ${asset_info}
    if [[ -n ${base_addr} ]]; then
      base_lovelace=${assets["${base_addr},lovelace"]:-0}
      for idx in "${!assets[@]}"; do [[ ${idx} != "${base_addr},"* ]] && continue; base_assets[${idx#*,}]=${assets[${idx}]}; done
    fi
    if [[ -n ${pay_addr} ]]; then
      pay_lovelace=${assets["${pay_addr},lovelace"]:-0}
      for idx in "${!assets[@]}"; do [[ ${idx} != "${pay_addr},"* ]] && continue; pay_assets[${idx#*,}]=${assets[${idx}]}; done
    fi
  fi
}

# Command     : getAddressBalance [address] [force] [asset]
# Description : get balance for address
# Parameters  : force  >  optional: [true|false] force update of balance (default = false)
#             : asset  >  optional: [true|false] fetch additional koios asset data (default = false)
getAddressBalance() {
  [[ $2 = true ]] && declare -gA balances=()
  [[ $3 = true ]] && asset_info=true || asset_info=false
  if [[ -n ${1} ]]; then
    if [[ -v balances[${1}] ]]; then
      lovelace=${balances[${1}]}
    else
      if [[ -n ${KOIOS_API} ]]; then
        addr_list=(${1})
        getBalanceKoios ${asset_info}
        lovelace=${assets["${1},lovelace"]:-0}
      else
        getBalance ${1}
        lovelace=${assets[lovelace]:-0}
      fi
    fi
  else
    lovelace=0
  fi
}

# Command     : getAssetsTxOut [PolicyID.AssetName] [Amount]
# Description : generate tx out string for multi-assets in wallet
#               getBalance assumed to be run before calling this function
#               address variable assumed to be set to selected wallet bech32 address
# Parameters  : PolicyID.AssetName  >  optional: Adjust balance for this asset before generating output
#               Amount              >  optional: The amount to adjust balance
# Return      : populates ${assets_tx_out}
getAssetsTxOut() {
  assets_tx_out=""
  if [[ $# -eq 2 ]]; then
    old_value=assets[$1]
    assets[$1]=$(( old_value + $2 ))
  fi
  for idx in "${!assets[@]}"; do
    [[ ${idx} = *lovelace ]] && continue
    [[ ${assets[${idx}]} -gt 0 ]] && assets_tx_out+="+${assets[${idx}]} ${idx#*,}"
  done
}

# Command     : getMinUTxO [string]
# Description : calculate minimum balance needed in transaction output to be valid
#             : string as passed to --tx-out parameter
# Return      : populates ${min_utxo_out}
getMinUTxO() {
  unset min_utxo_out
  min_utxo_args=(
    ${NETWORK_ERA}
    transaction calculate-min-required-utxo
    --protocol-params-file "${TMP_DIR}"/protparams.json
    --tx-out "$1"
  )
  println ACTION "${CCLI} ${min_utxo_args[*]}"
  if ! stdout=$(${CCLI} "${min_utxo_args[@]}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during min utxo calculation!\n${stdout}"
    return 1
  fi
  min_utxo_out=$([[ ${stdout} =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
}

# Command     : getWalletRewards [wallet name] [force]
# Description : check balance of reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_lovelace}
getWalletRewards() {
  reward_lovelace=-1
  if [[ $2 = true ]]; then
    declare -gA rewards_available=(); declare -gA reward_status=(); declare -gA pool_delegations=();
  fi
  if isWalletRegistered $1; then
    if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
      : # do nothing, variables populated through isWalletRegistered
    else
      reward_lovelace=${rewards_available[${reward_addr}]:-0}
      stake_deposit=${stake_deposits[${reward_addr}]}
    fi
  fi
}

# Command     : getRewardInfoKoios
# Description : check status and rewards for provided reward addresses using Koios API
getRewardInfoKoios() {
  # generate different arrays using reward address as key, rewards available, status and delegated pool if any
  # Its assumed that an array called reward_addr_list has been populated with all reward addresses to fetch data for

  declare -gA rewards_available=(); declare -gA reward_status=(); declare -gA pool_delegations=(); declare -gA vote_delegations=(); declare -gA stake_deposits=();

  # set defaults
  for _reward_addr in "${reward_addr_list[@]}"; do
    reward_status["${_reward_addr}"]="not registered"
    rewards_available["${_reward_addr}"]=0
    unset 'pool_delegations[${_reward_addr}]'
    unset 'vote_delegations[${_reward_addr}]'
  done

  if [[ -n ${KOIOS_API} && -n ${reward_addr_list+x} ]]; then
    printf -v addr_list_joined '\"%s\",' "${reward_addr_list[@]}"
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "Content-Type: application/json" -H "accept: text/csv")
    println ACTION "curl -sSL -f -X POST ${HEADERS[*]} -d '{\"_stake_addresses\":[${addr_list_joined%,}]}' ${KOIOS_API}/account_info?select=stake_address,status,delegated_pool,delegated_drep,rewards_available,deposit"
    ! account_info_list=$(curl -sSL -f -X POST "${HEADERS[@]}" -d '{"_stake_addresses":['${addr_list_joined%,}']}' "${KOIOS_API}/account_info?select=stake_address,status,delegated_pool,delegated_drep,rewards_available,deposit" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${account_info_list}\n" && return 1 # print error and return
    [[ -z ${account_info_list} ]] && return
    while IFS=',' read -r stake_address status delegated_pool delegated_drep rewards_available deposit; do
      reward_status["${stake_address}"]="${status}"
      rewards_available["${stake_address}"]="${rewards_available}"
      [[ -n ${delegated_pool} ]] && pool_delegations["${stake_address}"]="${delegated_pool}"
      if [[ -n ${delegated_drep} ]]; then
        if [[ ${delegated_drep} = drep_always_abstain ]]; then
          vote_delegations["${stake_address}"]="alwaysAbstain"; return
        elif [[ ${delegated_drep} = drep_always_no_confidence ]]; then
          vote_delegations["${stake_address}"]="alwaysNoConfidence"; return
        fi
        # convert to cli format <type>-<hash>
        vote_delegation_raw=$(bech32 <<< "${delegated_drep}")
        if [[ ${vote_delegation_raw:0:2} = '22' ]]; then
          vote_delegations["${stake_address}"]="keyHash-${vote_delegation_raw:2}"
        else
          vote_delegations["${stake_address}"]="scriptHash-${vote_delegation_raw:2}"
        fi
      fi
      stake_deposits["${stake_address}"]="${deposit}"
    done <<< "$(tail -n +2 <<< ${account_info_list})"
  fi
}

# Command     : getRewardsFromAddr [stake address]
# Description : check balance of reward address
# Parameters  : stake address  >  the address from stake.vkey
# Return      : populates ${reward_lovelace}
getRewardsFromAddr() {
  unset stake_address pool_delegation vote_delegation
  reward_lovelace=0; stake_deposit=0
  println ACTION "${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address ${1}"
  ! stake_address_info=$(${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address ${1}) && println "ERROR" "\n${FG_RED}NODE CLI ERROR${NC}: ${stake_address_info}\n" && return 1 # print error and return
  IFS=',' read -r stake_address reward_lovelace stake_deposit pool_delegation vote_delegation < <( jq -cr '"\(.[0].address//""),\(.[0].rewardAccountBalance//0),\(.[0].delegationDeposit//0),\(.[0].stakeDelegation//""),\(.[0].voteDelegation//"")"' <<< "${stake_address_info}" )
}

# Command     : isWalletRegistered [wallet name]
# Description : check if wallet is registered on chain
# Parameters  : wallet name  >  the name of the wallet
isWalletRegistered() {
  if getRewardAddress $1; then
    if [[ -n ${KOIOS_API} ]]; then
      [[ ! -v "reward_status[${reward_addr}]" ]] && reward_addr_list=( ${reward_addr} ) && getRewardInfoKoios
      [[ ${reward_status[${reward_addr}]} = registered ]] && return 0
    else
      getRewardsFromAddr ${reward_addr}
      [[ -n "${stake_address}" ]] && return 0
    fi
  fi
  return 1
}

# Command     : getWalletType [wallet name]
# Description : check if wallet is a hardware wallet, 0=hw, 1=cli, 2=cli & encrypted, 3=signing keys missing, 4=verification keys missing, 5=MultiSig
# Parameters  : wallet name  >  the name of the wallet
getWalletType() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}"
  payment_script_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}"
  stake_script_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SCRIPT_FILENAME}"
  ms_payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_PAY_VK_FILENAME}"
  ms_payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_PAY_SK_FILENAME}"
  ms_stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_STAKE_VK_FILENAME}"
  ms_stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_STAKE_SK_FILENAME}"
  if [[ -f "${payment_vk_file}" && -f "${stake_vk_file}" ]]; then # CNTools wallet
    wallet_desc=$(jq -r '.description' "${payment_vk_file}")
    if [[ ${wallet_desc} = *"Hardware"* ]]; then
      payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_PAY_SK_FILENAME}"
      stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_STAKE_SK_FILENAME}"
      ms_payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_HW_PAY_VK_FILENAME}"
      ms_payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_HW_PAY_SK_FILENAME}"
      ms_stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_HW_STAKE_VK_FILENAME}"
      ms_stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_MULTISIG_PREFIX}${WALLET_HW_STAKE_SK_FILENAME}"
      [[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]] && return 3 || return 0
    elif [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}.gpg" || -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}.gpg" ]]; then
      return 2
    else
      [[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]] && return 3 || return 1
    fi
  elif [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}" || -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_SCRIPT_FILENAME}" ]]; then # CNTools MultiSig wallet
    return 5
  else
    return 4
  fi
}

# Command     : getAllMultiSigKeys [script]
# Description : parse json MultiSig script for all signatures
# Parameters  : script      > the native script in json format
# Return      : populates: ${script_sig_list} (associative array that acts as a set)
getAllMultiSigKeys() {
  unset script_sig_list
  declare -gA script_sig_list=()
  while read -r _keyHash; do
    script_sig_list[${_keyHash}]=1
  done < <( jq -r '.. | select(.type?=="sig") | .keyHash' <<< "$1" )
}

# Command     : validateMultiSigScript [verbose] [script] [sigs...]
# Description : parse json MultiSig script to check if needed signatures exist
#             : NOTE !! please unset required_total before calling this function
# Parameters  : verbose     > true|false, print time lock warnings
#             : script      > the native script in json format
#             : sigs        > array of creds for wallets found
# Return      : 0 = success, 1 = failed, populates ${required_total} with total needed signatures
validateMultiSigScript() {
  local found=0
  local required=1
  local verbose=$1
  local script=$2
  shift
  IFS=',' read -r _type _scripts _scripts_cnt _required <<< "$(jq -cr '"\(.type),\(.scripts|@base64),\(.scripts|length),\(.required)"' <<< "${script}")"
  if [[ ${_type} = atLeast ]]; then
    required=${_required}
  elif [[ ${_type} = all ]]; then
    required=${_scripts_cnt}
  fi
  while IFS=',' read -r __type __key_hash __slot __script; do
    if [[ ${__type} = sig ]]; then
      for _sig in "$@"; do
        [[ ${_sig} = "${__key_hash}" ]] && ((found++))
      done
    elif [[ ${__type} = before ]]; then
      if [[ $(getSlotTipRef) -lt ${__slot} ]]; then
        ((found++))
      else
        [[ ${verbose} = true ]] && println ERROR "${FG_RED}Time locked!${NC} This script is locked with a before condition that has passed, before slot = ${__slot}, current slot = $(getSlotTipRef)"
      fi
    elif [[ ${__type} = after ]]; then
      if [[ $(getSlotTipRef) -gt ${__slot} ]]; then
        ((found++))
      else
        [[ ${verbose} = true ]] && println ERROR "${FG_RED}Time locked!${NC} This script is locked with an after condition that has yet to pass, after slot = ${__slot}, current slot = $(getSlotTipRef)"
      fi
    else
      validateMultiSigScript ${verbose} "$(base64 -d <<< ${__script})" "$@" && ((found++))
    fi
  done < <( base64 -d <<< ${_scripts} | jq -cr '.[] | "\(.type),\(.keyHash),\(.slot),\(.|@base64)"' )
  required_total=$(( required_total + required ))
  [[ ${found} -ge ${required} ]] && return 0 || return 1
}

# Command     : getPoolType [pool name]
# Description : check if pool is a hardware pool, 0=yes, 1=cli, 2=cli & encrypted, 3=signing keys missing, 4=verification keys missing
# Parameters  : pool name  >  the name of the pool
getPoolType() {
  pool_coldkey_vk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}"
  pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}"
  if [[ -f "${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}" ]]; then # CNTools pool
    if [[ $(jq -r '.description' "${pool_coldkey_vk_file}") = *"Hardware"* ]]; then
      pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_HW_COLDKEY_SK_FILENAME}"
      ([[ ${op_mode} = "online" && ( ! -f ${pool_coldkey_sk_file} ) ]]) && return 3 || return 0
    elif [[ -f "${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}.gpg" ]]; then
      return 2
    else
      ([[ ${op_mode} = "online" && ( ! -f ${pool_coldkey_sk_file} ) ]]) && return 3 || return 1
    fi
  else
    return 4
  fi
}

# Command     : getTTL [force, true|false]
# Description : query node for slot tip and calculate/get TTL from input depending on op_mode
getTTL() {
  tip_ref=$(getSlotTipRef)
  if [[ ${op_mode} = "hybrid" || $1 = true ]]; then
    println DEBUG "\nHow long do you want the transaction to be valid?"
    getAnswerAnyCust ttl_enter "TTL (in seconds, default: 1800/30min)"
    ttl_enter=${ttl_enter:-1800}
    if ! isNumber ${ttl_enter}; then
      println ERROR "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}"
      return 1
    fi
    ttl=$(( tip_ref + (ttl_enter/SLOT_LENGTH) ))
  else
    ttl=$(( tip_ref + (TX_TTL/SLOT_LENGTH) ))
  fi
  println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl}"
}

# Command     : getCustomDerivationPath
# Description : ask user for custom derivation path (account and key index)
# Return      : populates: ${acct_idx} ${key_idx}
getCustomDerivationPath() {
  println DEBUG "Enter a custom account index to derive keys for (enter for default)"
  getAnswerAnyCust acct_idx "Account (default: 0)"
  acct_idx=${acct_idx:-0}
  if ! isNumber ${acct_idx}; then
    println ERROR "${FG_RED}ERROR${NC}: Invalid account index, must be a number!"
    waitToProceed && return 1
  fi
  println DEBUG "\nEnter a custom key index to derive keys for (enter for default)"
  getAnswerAnyCust key_idx "Key index (default: 0)"
  key_idx=${key_idx:-0}
  if ! isNumber ${key_idx}; then
    println ERROR "${FG_RED}ERROR${NC}: Invalid key index, must be a number!"
    waitToProceed && return 1
  fi
  return 0
}

# Command     : getSavedDerivationPath [derivation_path_file]
# Description : parse saved derivation path file for acct_idx and key_idx
# Return      : populates: ${derivation_path} ${acct_idx} ${key_idx}
getSavedDerivationPath() {
  unset derivation_path acct_idx key_idx
  [[ ! -f $1 ]] && return 1
  derivation_path=$(cat "$1")
  IFS='/' read -ra array <<< "${derivation_path}"
  acct_idx="${array[2]//H}"
  key_idx="${array[4]}"
  return 0
}

# Command     : createNewWallet
# Description : creates a new empty wallet folder
createNewWallet() {
  getAnswerAnyCust wallet_name "Name of wallet (non-alphanumeric characters will be replaced with a space)"
  # Remove unwanted characters from wallet name
  wallet_name=${wallet_name//[^[:alnum:]]/_}
  if [[ -z "${wallet_name}" ]]; then
    println ERROR "${FG_RED}ERROR${NC}: Empty wallet name, please retry!"
    waitToProceed && return 1
  fi
  echo
  if ! mkdir -p "${WALLET_FOLDER}/${wallet_name}"; then
    println ERROR "${FG_RED}ERROR${NC}: Failed to create directory for wallet:\n${WALLET_FOLDER}/${wallet_name}"
    waitToProceed && return 1
  fi
  if [[ $(find "${WALLET_FOLDER}/${wallet_name}" -type f -print0 | wc -c) -gt 0 ]]; then
    println "${FG_RED}WARN${NC}: A wallet ${FG_GREEN}$wallet_name${NC} already exists"
    println "      Choose another name or delete the existing one"
    waitToProceed && return 1
  fi
  return 0
}

# Command     : createNewWallet
# Description : creates a new
# Return      : populates: ${acct_idx} ${key_idx}
createMnemonicWallet() {
  if ! cmdAvailable "bech32" &>/dev/null || \
    ! cmdAvailable "cardano-address" &>/dev/null; then
    println ERROR "${FG_RED}ERROR${NC}: bech32 and/or cardano-address not found in '\$PATH'"
    println ERROR "Please run updated guild-deploy.sh and re-build/re-download cardano-node"
    waitToProceed && return 1
  fi
  derivation_path_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_DERIVATION_PATH_FILENAME}"
  payment_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_SK_FILENAME}"
  payment_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_VK_FILENAME}"
  stake_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_SK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_VK_FILENAME}"
  drep_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_GOV_DREP_VK_FILENAME}"
  drep_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_GOV_DREP_SK_FILENAME}"
  cc_cold_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_GOV_CC_COLD_VK_FILENAME}"
  cc_cold_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_GOV_CC_COLD_SK_FILENAME}"
  cc_hot_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_GOV_CC_HOT_VK_FILENAME}"
  cc_hot_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_GOV_CC_HOT_SK_FILENAME}"
  ms_payment_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_MULTISIG_PREFIX}${WALLET_PAY_SK_FILENAME}"
  ms_payment_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_MULTISIG_PREFIX}${WALLET_PAY_VK_FILENAME}"
  ms_stake_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_MULTISIG_PREFIX}${WALLET_STAKE_SK_FILENAME}"
  ms_stake_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_MULTISIG_PREFIX}${WALLET_STAKE_VK_FILENAME}"
  ms_drep_sk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_DREP_SK_FILENAME}"
  ms_drep_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_MULTISIG_PREFIX}${WALLET_GOV_DREP_VK_FILENAME}"
  isImport=true
  if [[ -z ${mnemonic} ]]; then
    println ACTION "cardano-address recovery-phrase generate"
    mnemonic=$(cardano-address recovery-phrase generate)
    isImport=false
  fi
  IFS=" " read -r -a words <<< "${mnemonic}"
  if [[ ${#words[@]} -ne 24 ]] && [[ ${#words[@]} -ne 15 ]]; then
    println ERROR "${FG_RED}ERROR${NC}: 24 or 15 words expected, found ${FG_RED}${#words[@]}${NC}"
    echo && safeDel "${WALLET_FOLDER}/${wallet_name}"
    unset mnemonic; unset words
    waitToProceed && return 1
  fi
  getCustomDerivationPath || return 1
  echo "1852H/1815H/${acct_idx}H/x/${key_idx}" > "${derivation_path_file}"
  caddr_v="$(cardano-address -v | awk '{print $1}')"
  [[ "${caddr_v}" == 3* ]] && caddr_arg="--with-chain-code" || caddr_arg=""
  println ACTION "cardano-address key from-recovery-phrase Shelley <<< <mnemonic words>"
  if ! root_prv=$(cardano-address key from-recovery-phrase Shelley <<< ${mnemonic}); then
    echo && safeDel "${WALLET_FOLDER}/${wallet_name}"
    unset mnemonic; unset words
    waitToProceed && return 1
  fi
  unset mnemonic
  [[ ${isImport} = true ]] && unset words
  println ACTION "cardano-address key child "1852H/1815H/${acct_idx}H/0/${key_idx}" <<< <root private key>"
  payment_xprv=$(cardano-address key child "1852H/1815H/${acct_idx}H/0/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key child "1852H/1815H/${acct_idx}H/2/${key_idx}" <<< <root private key>"
  stake_xprv=$(cardano-address key child "1852H/1815H/${acct_idx}H/2/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key child "1852H/1815H/${acct_idx}H/3/${key_idx}" <<< <root private key>"
  drep_xprv=$(cardano-address key child "1852H/1815H/${acct_idx}H/3/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key child "1852H/1815H/${acct_idx}H/4/${key_idx}" <<< <root private key>"
  cc_cold_xprv=$(cardano-address key child "1852H/1815H/${acct_idx}H/4/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key child "1852H/1815H/${acct_idx}H/5/${key_idx}" <<< <root private key>"
  cc_hot_xprv=$(cardano-address key child "1852H/1815H/${acct_idx}H/5/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key child "1854H/1815H/${acct_idx}H/0/${key_idx}" <<< <root private key>"
  ms_payment_xprv=$(cardano-address key child "1854H/1815H/${acct_idx}H/0/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key child "1854H/1815H/${acct_idx}H/2/${key_idx}" <<< <root private key>"
  ms_stake_xprv=$(cardano-address key child "1854H/1815H/${acct_idx}H/2/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key child "1854H/1815H/${acct_idx}H/3/${key_idx}" <<< <root private key>"
  ms_drep_xprv=$(cardano-address key child "1854H/1815H/${acct_idx}H/3/${key_idx}" <<< ${root_prv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <payment xprv>"
  payment_xpub=$(cardano-address key public ${caddr_arg} <<< ${payment_xprv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <stake xprv>"
  stake_xpub=$(cardano-address key public ${caddr_arg} <<< ${stake_xprv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <drep xprv>"
  drep_xpub=$(cardano-address key public ${caddr_arg} <<< ${drep_xprv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <cc_cold xprv>"
  cc_cold_xpub=$(cardano-address key public ${caddr_arg} <<< ${cc_cold_xprv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <cc_hot xprv>"
  cc_hot_xpub=$(cardano-address key public ${caddr_arg} <<< ${cc_hot_xprv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <payment xprv>"
  ms_payment_xpub=$(cardano-address key public ${caddr_arg} <<< ${ms_payment_xprv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <stake xprv>"
  ms_stake_xpub=$(cardano-address key public ${caddr_arg} <<< ${ms_stake_xprv})
  println ACTION "cardano-address key public ${caddr_arg} <<< <drep xprv>"
  ms_drep_xpub=$(cardano-address key public ${caddr_arg} <<< ${ms_drep_xprv})
  [[ "${NWMAGIC}" == "764824073" ]] && network_tag=1 || network_tag=0
  println ACTION "cardano-address address delegation ${stake_xpub} <<< $(cardano-address address payment --network-tag ${network_tag} <<< ${payment_xpub})"
  base_addr_candidate=$(cardano-address address delegation ${stake_xpub} <<< "$(cardano-address address payment --network-tag ${network_tag} <<< ${payment_xpub})")
  if [[ "${caddr_v}" == 2* ]] && [[ "${NWMAGIC}" != "764824073" ]]; then
    println LOG "TestNet, converting address to 'addr_test'"
    println ACTION "bech32 addr_test <<< ${base_addr_candidate}"
    base_addr_candidate=$(bech32 addr_test <<< ${base_addr_candidate})
  fi
  println LOG "Base address candidate = ${base_addr_candidate}"
  println LOG "Address Inspection:\n$(cardano-address address inspect <<< ${base_addr_candidate})"
  println ACTION "\$(bech32 <<< \${payment_xprv} | cut -b -128)\$(bech32 <<< ${payment_xpub})"
  pes_key=$(bech32 <<< ${payment_xprv} | cut -b -128)$(bech32 <<< ${payment_xpub})
  println ACTION "\$(bech32 <<< \${stake_xprv} | cut -b -128)\$(bech32 <<< ${stake_xpub})"
  ses_key=$(bech32 <<< ${stake_xprv} | cut -b -128)$(bech32 <<< ${stake_xpub})
  println ACTION "\$(bech32 <<< \${drep_xprv} | cut -b -128)\$(bech32 <<< ${drep_xpub})"
  drep_es_key=$(bech32 <<< ${drep_xprv} | cut -b -128)$(bech32 <<< ${drep_xpub})
  println ACTION "\$(bech32 <<< \${cc_cold_xprv} | cut -b -128)\$(bech32 <<< ${cc_cold_xpub})"
  cc_cold_es_key=$(bech32 <<< ${cc_cold_xprv} | cut -b -128)$(bech32 <<< ${cc_cold_xpub})
  println ACTION "\$(bech32 <<< \${cc_hot_xprv} | cut -b -128)\$(bech32 <<< ${cc_hot_xpub})"
  cc_hot_es_key=$(bech32 <<< ${cc_hot_xprv} | cut -b -128)$(bech32 <<< ${cc_hot_xpub})
  println ACTION "\$(bech32 <<< \${ms_payment_xprv} | cut -b -128)\$(bech32 <<< ${ms_payment_xpub})"
  ms_pes_key=$(bech32 <<< ${ms_payment_xprv} | cut -b -128)$(bech32 <<< ${ms_payment_xpub})
  println ACTION "\$(bech32 <<< \${ms_stake_xprv} | cut -b -128)\$(bech32 <<< ${ms_stake_xpub})"
  ms_ses_key=$(bech32 <<< ${ms_stake_xprv} | cut -b -128)$(bech32 <<< ${ms_stake_xpub})
  println ACTION "\$(bech32 <<< \${ms_drep_xprv} | cut -b -128)\$(bech32 <<< ${ms_drep_xpub})"
  ms_drep_es_key=$(bech32 <<< ${ms_drep_xprv} | cut -b -128)$(bech32 <<< ${ms_drep_xpub})
  cat <<-EOF > "${payment_sk_file}"
		{
				"type": "PaymentExtendedSigningKeyShelley_ed25519_bip32",
				"description": "Payment Signing Key",
				"cborHex": "5880${pes_key}"
		}
		EOF
  cat <<-EOF > "${stake_sk_file}"
		{
				"type": "StakeExtendedSigningKeyShelley_ed25519_bip32",
				"description": "Stake Signing Key",
				"cborHex": "5880${ses_key}"
		}
		EOF
	cat <<-EOF > "${drep_sk_file}"
		{
				"type": "DRepExtendedSigningKey_ed25519_bip32",
				"description": "Delegate Representative Signing Key",
				"cborHex": "5880${drep_es_key}"
		}
		EOF
	cat <<-EOF > "${cc_cold_sk_file}"
		{
				"type": "ConstitutionalCommitteeColdExtendedSigningKey_ed25519_bip32",
				"description": "Constitutional Committee Cold Signing Key",
				"cborHex": "5880${cc_cold_es_key}"
		}
		EOF
	cat <<-EOF > "${cc_hot_sk_file}"
		{
				"type": "ConstitutionalCommitteeHotExtendedSigningKey_ed25519_bip32",
				"description": "Constitutional Committee Hot Signing Key",
				"cborHex": "5880${cc_hot_es_key}"
		}
		EOF
	cat <<-EOF > "${ms_payment_sk_file}"
		{
				"type": "PaymentExtendedSigningKeyShelley_ed25519_bip32",
				"description": "MultiSig Payment Signing Key",
				"cborHex": "5880${pes_key}"
		}
		EOF
  cat <<-EOF > "${ms_stake_sk_file}"
		{
				"type": "StakeExtendedSigningKeyShelley_ed25519_bip32",
				"description": "MultiSig Stake Signing Key",
				"cborHex": "5880${ses_key}"
		}
		EOF
 	cat <<-EOF > "${ms_drep_sk_file}"
		{
				"type": "DRepExtendedSigningKey_ed25519_bip32",
				"description": "MultiSig Delegate Representative Signing Key",
				"cborHex": "5880${drep_es_key}"
		}
		EOF
  println ACTION "${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file ${payment_sk_file} --verification-key-file ${TMP_DIR}/payment.evkey"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file "${payment_sk_file}" --verification-key-file "${TMP_DIR}/payment.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during payment extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file ${stake_sk_file} --verification-key-file ${TMP_DIR}/stake.evkey"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file "${stake_sk_file}" --verification-key-file "${TMP_DIR}/stake.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during stake extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key verification-key --signing-key-file ${drep_sk_file} --verification-key-file ${TMP_DIR}/drep.evkey"
  if ! stdout=$(${CCLI} conway key verification-key --signing-key-file "${drep_sk_file}" --verification-key-file "${TMP_DIR}/drep.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during drep extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key verification-key --signing-key-file ${cc_cold_sk_file} --verification-key-file ${TMP_DIR}/cc-cold.evkey"
  if ! stdout=$(${CCLI} conway key verification-key --signing-key-file "${cc_cold_sk_file}" --verification-key-file "${TMP_DIR}/cc-cold.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during cc-cold extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key verification-key --signing-key-file ${cc_hot_sk_file} --verification-key-file ${TMP_DIR}/cc-hot.evkey"
  if ! stdout=$(${CCLI} conway key verification-key --signing-key-file "${cc_hot_sk_file}" --verification-key-file "${TMP_DIR}/cc-hot.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during cc-hot extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file ${ms_payment_sk_file} --verification-key-file ${TMP_DIR}/ms_payment.evkey"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file "${ms_payment_sk_file}" --verification-key-file "${TMP_DIR}/ms_payment.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during MultiSig payment extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file ${ms_stake_sk_file} --verification-key-file ${TMP_DIR}/ms_stake.evkey"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file "${ms_stake_sk_file}" --verification-key-file "${TMP_DIR}/ms_stake.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during MultiSig stake extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key verification-key --signing-key-file ${ms_drep_sk_file} --verification-key-file ${TMP_DIR}/ms_drep.evkey"
  if ! stdout=$(${CCLI} conway key verification-key --signing-key-file "${ms_drep_sk_file}" --verification-key-file "${TMP_DIR}/ms_drep.evkey" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during MultiSig drep extended verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file ${TMP_DIR}/payment.evkey --verification-key-file ${payment_vk_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file "${TMP_DIR}/payment.evkey" --verification-key-file "${payment_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during payment verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file ${TMP_DIR}/stake.evkey --verification-key-file ${stake_vk_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file "${TMP_DIR}/stake.evkey" --verification-key-file "${stake_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during stake verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key non-extended-key --extended-verification-key-file ${TMP_DIR}/drep.evkey --verification-key-file ${drep_vk_file}"
  if ! stdout=$(${CCLI} conway key non-extended-key --extended-verification-key-file "${TMP_DIR}/drep.evkey" --verification-key-file "${drep_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during drep verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key non-extended-key --extended-verification-key-file ${TMP_DIR}/cc-cold.evkey --verification-key-file ${cc_cold_vk_file}"
  if ! stdout=$(${CCLI} conway key non-extended-key --extended-verification-key-file "${TMP_DIR}/cc-cold.evkey" --verification-key-file "${cc_cold_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during cc-cold verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key non-extended-key --extended-verification-key-file ${TMP_DIR}/cc-hot.evkey --verification-key-file ${cc_hot_vk_file}"
  if ! stdout=$(${CCLI} conway key non-extended-key --extended-verification-key-file "${TMP_DIR}/cc-hot.evkey" --verification-key-file "${cc_hot_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during cc-hot verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file ${TMP_DIR}/ms_payment.evkey --verification-key-file ${ms_payment_vk_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file "${TMP_DIR}/ms_payment.evkey" --verification-key-file "${ms_payment_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during MultiSig payment verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file ${TMP_DIR}/ms_stake.evkey --verification-key-file ${ms_stake_vk_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} key non-extended-key --extended-verification-key-file "${TMP_DIR}/ms_stake.evkey" --verification-key-file "${ms_stake_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during MultiSig stake verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  println ACTION "${CCLI} conway key non-extended-key --extended-verification-key-file ${TMP_DIR}/ms_drep.evkey --verification-key-file ${ms_drep_vk_file}"
  if ! stdout=$(${CCLI} conway key non-extended-key --extended-verification-key-file "${TMP_DIR}/ms_drep.evkey" --verification-key-file "${ms_drep_vk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during MultiSig drep verification key extraction!\n${stdout}"; safeDel "${WALLET_FOLDER}/${wallet_name}"; waitToProceed && return 1
  fi
  chmod 600 "${WALLET_FOLDER}/${wallet_name}/"*
  getBaseAddress ${wallet_name}
  getPayAddress ${wallet_name}
  getRewardAddress ${wallet_name}
  getCredentials ${wallet_name}
  if [[ ${base_addr} != "${base_addr_candidate}" ]]; then
    println ERROR "${FG_RED}ERROR${NC}: base address generated doesn't match base address candidate."
    println ERROR "base_addr[${FG_LGRAY}${base_addr}${NC}]\n!=\nbase_addr_candidate[${FG_LGRAY}${base_addr_candidate}${NC}]"
    println ERROR "Create a GitHub issue and include log file from failed CNTools session."
    echo && safeDel "${WALLET_FOLDER}/${wallet_name}"
    waitToProceed && return 1
  fi
  return 0
}

printWalletInfo() {
  println DEBUG "You can now send and receive ADA using the above addresses. Note that Payment Address will not take part in staking"
  println DEBUG "Wallet will be automatically registered on chain if you choose to delegate or pledge wallet when registering a stake pool"
  echo
  println DEBUG "${FG_FG_LBLUE}INFO!${NC} Using a mnemonic or hardware wallet in CNTools comes with a few limitations"
  echo
  println DEBUG "Only the specified address in the HD wallet is extracted and because of this the following apply if used elsewhere:"
  println DEBUG " ${FG_LGRAY}>${NC} If restored wallet balance doesn't match, send all ADA to address shown in CNTools"
  println DEBUG " ${FG_LGRAY}>${NC} Only use receive address shown in CNTools (enable 'Single Address Mode' in wallet if available)"
  echo
  println DEBUG "Some of the advantages of using a mnemonic imported wallet instead of CLI are:"
  println DEBUG " ${FG_LGRAY}>${NC} Wallet can be restored from saved mnemonic/hardware device if keys are lost/deleted"
  println DEBUG " ${FG_LGRAY}>${NC} Wallet can be shared and used in multiple wallets concurrently, including CNTools"
  echo
  println DEBUG "Please read more about HD wallets at:"
  println DEBUG "https://cardano-community.github.io/support-faq/Wallets/wallets/#heirarchical-deterministic-hd-wallets"
}

# Command     : buildOfflineJSON [type]
# Description : construct a json containing all data for offline signing
# Parameters  : type  >  type of transaction, e.g 'payment'
buildOfflineJSON() {
  offlineJSON="{}"
  if ! offlineJSON=$(jq ". += { id: \"$(date +%s)\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { type: \"${1}\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-created\": \"$(date --iso-8601=s)\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-expire\": \"$(date --iso-8601=s --date="@$(($(date +%s)+ttl_enter))")\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { ttl: \"${ttl}\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"script-file\": [] }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { witness: [] }" <<< ${offlineJSON}); then return 1; fi
}

# Command     : registerStakeWallet [wallet name] [optional: skip validation]
# Description : Register stake keys on chain and move funds from payment address to payment base address
# Parameters  : wallet name      >  the name of the wallet
# Parameters  : skip validation  >  [optional] [true|false] if true, skip wallet registration check
registerStakeWallet() {

  wallet_name=$1
  wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ -z $2 || $2 = "false" ]]; then
    println DEBUG "Wallet ${FG_GREEN}${wallet_name}${NC} not registered on chain"
    waitToProceed "press any key to continue with registration"
  fi

  stake_cert_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_CERT_FILENAME}"

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=$(( required_total + 1 ))
    stake_param=("--stake-script-file" "${stake_script_file}")
  else
    witness_cnt=2
    stake_param=("--stake-verification-key-file" "${stake_vk_file}")
  fi

  if versionCheck "9.0" "${PROT_VERSION}"; then
    stake_param+=("--key-reg-deposit-amt" ${KEY_DEPOSIT})
  fi

  println ACTION "${CCLI} ${NETWORK_ERA} stake-address registration-certificate ${stake_param[*]} --out-file ${stake_cert_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} stake-address registration-certificate "${stake_param[@]}" --out-file "${stake_cert_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during stake registration certificate creation!\n${stdout}"; return 1
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi

  println LOG "Key Deposit is ${KEY_DEPOSIT}"

  getAssetsTxOut

  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=( --tx-in-script-file "${payment_script_file}" )
  fi
 
  tmpNewBalance=$(( base_lovelace - KEY_DEPOSIT )) 
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${stake_cert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1
  
  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1
  
  newBalance=$(( base_lovelace - min_fee - KEY_DEPOSIT ))
  println LOG "New balance after tx fee and key deposit is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${KEY_DEPOSIT}))"

  if [[ ${base_lovelace} -lt $(( min_fee + KEY_DEPOSIT )) ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee and key deposit!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee + KEY_DEPOSIT )))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and key deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${stake_cert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"$(( min_fee + KEY_DEPOSIT ))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' stake script\", script: $(jq -c . "${stake_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "MultiSig wallet registration transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
  echo
  if ! verifyTx ${base_addr}; then return 1; fi
  echo

  reward_lovelace=0
}

# Command     : deregisterStakeWallet
# Description : Deregister stake keys/wallet from chain, key deposit fee returned to wallets base address
deregisterStakeWallet() {

  wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=${required_total}
    unset required_total
    validateMultiSigScript false "$(cat "${stake_script_file}")"
    witness_cnt=$(( witness_cnt + required_total ))
    stake_param=("--stake-script-file" "${stake_script_file}")
  else
    witness_cnt=2
    stake_param=("--stake-verification-key-file" "${stake_vk_file}")
  fi

  if versionCheck "9.0" "${PROT_VERSION}"; then
    stake_param+=("--key-reg-deposit-amt" ${stake_deposit})
  fi

  stake_dereg_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_DEREG_FILENAME}"
  println ACTION "${CCLI} ${NETWORK_ERA} stake-address deregistration-certificate ${stake_param[*]} --out-file ${stake_dereg_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} stake-address deregistration-certificate "${stake_param[@]}" --out-file "${stake_dereg_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during stake deregistration certificate creation!\n${stdout}"; return 1
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi
  
  println LOG "Key Deposit is ${KEY_DEPOSIT}"

  getAssetsTxOut

  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=(
      --tx-in-script-file "${payment_script_file}"
      --certificate-script-file "${stake_script_file}"
    )
  fi

  tmpNewBalance=$(( base_lovelace + KEY_DEPOSIT ))
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${stake_dereg_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( base_lovelace + KEY_DEPOSIT - min_fee ))
  println LOG "New balance after returned key deposit and subtracted tx fee is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) + $(formatLovelace ${KEY_DEPOSIT}) - $(formatLovelace ${min_fee}))"
  
  if [[ $(( ${base_lovelace} + KEY_DEPOSIT )) -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee - KEY_DEPOSIT )))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and returned key deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${stake_dereg_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"amount-returned\": \"${KEY_DEPOSIT}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' stake script\", script: $(jq -c . "${stake_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "MultiSig wallet de-registration transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : sendAssets
# Description : send Assets from source to destination
#             : can also be used to defrag address by sending all to self
#             : supports fee to be payed by sender(default) or receiver by reducing amount to send
sendAssets() {

  [[ $(cat "${WALLET_FOLDER}/${s_wallet}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${s_addr}" ]] && wallet_source="payment" || wallet_source="base"

  getWalletType ${s_wallet}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${s_addr}]}
    tx_in=${tx_in_arr[${s_addr}]}
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=${required_total}
  else
    witness_cnt=1
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi

  if [[ -n ${metafile} && -f ${metafile} ]]; then
    metafile_param="--json-metadata-no-schema --metadata-json-file ${metafile}"
  else
    metafile_param=""
  fi

  [[ ${#assets_left[@]} -eq 0 ]] && outCount=1 || outCount=2
  
  assets_tx_out_s=""
  assets_tx_out_d=""
  for idx in "${!assets_left[@]}"; do
    [[ ${idx} = "lovelace" ]] && continue
    [[ ${assets_left[${idx}]} -gt 0 ]] && assets_tx_out_s+="+${assets_left[${idx}]} ${idx}"
  done
  for idx in "${!assets_to_send[@]}"; do
    [[ ${idx} = "lovelace" ]] && continue
    [[ ${assets_to_send[${idx}]} -gt 0 ]] && assets_tx_out_d+="+${assets_to_send[${idx}]} ${idx}"
  done

  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=( --tx-in-script-file "${payment_script_file}" )
  fi

  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx0.tmp
  )
  if [[ ${outCount} -eq 1 ]]; then
    build_args+=( --tx-out "${d_addr}+${assets_to_send[lovelace]}${assets_tx_out_d}" )
  else
    build_args+=( --tx-out "${s_addr}+${assets_left[lovelace]}${assets_tx_out_s}" --tx-out "${d_addr}+${assets_to_send[lovelace]}${assets_tx_out_d}" )
  fi

  buildTx || return 1
  
  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} ${outCount} ${witness_cnt} || return 1
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx.raw
  )
  
  if [[ ${outCount} -eq 1 ]]; then # all assets to destination, nothing to return
    newBalance=0
    tx_out="${d_addr}+$(( ${assets_to_send[lovelace]} - min_fee ))${assets_tx_out_d}"
    getMinUTxO "${tx_out}" || return 1
    if [[ ${assets_to_send[lovelace]} -lt ${min_utxo_out} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in address ( $(formatLovelace ${assets_to_send[lovelace]}) < $(formatLovelace ${min_utxo_out}) )"
      println ERROR "Top up wallet with enough ADA to cover minimum UTxO balance"
      return 1
    fi
    build_args+=( --tx-out "${tx_out}" )
  else
    if [[ ${include_fee} = "no" ]]; then
      newBalance=$(( ${assets[${index_prefix}lovelace]} - ${assets_to_send[lovelace]} - min_fee ))
      tx_out_d="${d_addr}+${assets_to_send[lovelace]}${assets_tx_out_d}"
    else
      newBalance=$(( ${assets[${index_prefix}lovelace]} - ${assets_to_send[lovelace]} ))
      tx_out_d="${d_addr}+$(( ${assets_to_send[lovelace]} - min_fee ))${assets_tx_out_d}"
    fi
    getMinUTxO "${tx_out_d}"
    min_utxo_out_d=${min_utxo_out}
    build_args+=( --tx-out "${tx_out_d}" )
    
    tx_out_s="${s_addr}+${newBalance}${assets_tx_out_s}"
    getMinUTxO "${tx_out_s}"
    min_utxo_out_s=${min_utxo_out}
    build_args+=( --tx-out "${tx_out_s}" )
    
    if [[ ${newBalance} -lt ${min_utxo_out_s} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA left in source address ( $(formatLovelace ${newBalance}) < $(formatLovelace ${min_utxo_out_s}) )"
      println ERROR "Send all ADA or top up wallet with enough ADA to cover minimum UTxO balance"
      return 1
    elif [[ ${assets_to_send[lovelace]} -lt ${min_utxo_out_d} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, requires ${FG_LBLUE}$(formatLovelace ${min_utxo_out_d})${NC} ADA to be sent along!"
      return 1
    fi
  fi
  
  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Payment"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${s_wallet}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"source-address\": \"${s_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"destination-address\": \"${d_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { "assets": [] }" <<< ${offlineJSON}); then return 1; fi
    for idx in "${!assets_to_send[@]}"; do
      [[ ${assets_to_send[${idx}]} -gt 0 ]] && if ! offlineJSON=$(jq "."assets" += [{ asset: \"${idx}\", amount: \"${assets_to_send[${idx}]}\" }]" <<< ${offlineJSON}); then return 1; fi
    done
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${s_wallet}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${s_wallet}' payment signing key\", vkey: $(jq -c . "${s_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "MultiSig wallet transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Source Wallet ${FG_GREEN}${s_wallet} ${FG_LGRAY}$(basename ${s_payment_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${s_payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : Delegate
# Description : Register pool with pledge on chain
delegate() {

  wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=${required_total}
    unset required_total
    validateMultiSigScript false "$(cat "${stake_script_file}")"
    witness_cnt=$(( witness_cnt + required_total ))
    stake_param=("--stake-script-file" "${stake_script_file}")
  else
    witness_cnt=2
    stake_param=("--stake-verification-key-file" "${stake_vk_file}")
  fi

  pool_delegcert_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_DELEGCERT_FILENAME}"
  println ACTION "${CCLI} ${NETWORK_ERA} stake-address stake-delegation-certificate ${stake_param[*]} --stake-pool-id ${pool_id} --out-file ${pool_delegcert_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} stake-address stake-delegation-certificate "${stake_param[@]}" --stake-pool-id "${pool_id}" --out-file "${pool_delegcert_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during stake delegation certificate creation!\n${stdout}"; return 1
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi
  
  getAssetsTxOut
  
  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=(
      --tx-in-script-file "${payment_script_file}"
      --certificate-script-file "${stake_script_file}"
    )
  fi

  tmpNewBalance=${base_lovelace}
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${pool_delegcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( base_lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) )"
  
  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_delegcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Delegation"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-id\": \"${pool_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${pool_name} != "${pool_id}" ]]; then
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' stake script\", script: $(jq -c . "${stake_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "MultiSig wallet delegation transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : withdrawRewards
# Description : withdraw rewards earned and send to wallet base address
withdrawRewards() {

  wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=${required_total}
    unset required_total
    validateMultiSigScript false "$(cat "${stake_script_file}")"
    witness_cnt=$(( witness_cnt + required_total ))
  else
    witness_cnt=2
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi
  
  getAssetsTxOut

  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=(
      --tx-in-script-file "${payment_script_file}"
      --withdrawal-script-file "${stake_script_file}"
    )
  fi
 
  tmpNewBalance=$(( base_lovelace + reward_lovelace )) 
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --withdrawal ${reward_addr}+${reward_lovelace}
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( base_lovelace - min_fee + reward_lovelace ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $((min_fee - reward_lovelace)))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and withdrawal, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --withdrawal ${reward_addr}+${reward_lovelace}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Rewards Withdrawal"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { rewards: \"${reward_lovelace}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' stake script\", script: $(jq -c . "${stake_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "MultiSig wallet withdrawal transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : registerPool
# Description : Register pool with pledge on chain
registerPool() {

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi
  
  println LOG "Pool Deposit is ${POOL_DEPOSIT}"
  
  owner_delegation_cert=""
  [[ ${delegate_owner_wallet} = 'Y' ]] && owner_delegation_cert="--certificate-file ${owner_delegation_cert_file}"

  # owner payment + cold + multi-owners(main owner included)
  unset witness_cnt hasScriptOwner
  script_args=()
  for index in "${!owner_wallets[@]}"; do
    getWalletType ${owner_wallets[${index}]}
    if [[ ${wallet_type} -eq 5 ]]; then
      op_mode=hybrid
      hasScriptOwner=true
      if [[ ${index} -eq 0 ]]; then
        unset required_total
        validateMultiSigScript false "$(cat "${payment_script_file}")"
        witness_cnt=${required_total}
        script_args+=( --tx-in-script-file "${payment_script_file}" )
      fi
      unset required_total
      validateMultiSigScript false "$(cat "${stake_script_file}")"
      witness_cnt=$(( witness_cnt + required_total ))
      script_args+=( --certificate-script-file "${stake_script_file}" )
    else
      [[ ${index} -eq 0 ]] && witness_cnt=1
      witness_cnt=$(( witness_cnt + 1 ))
    fi
  done
  witness_cnt=$(( witness_cnt + 1 )) # cold key witness

  if ! getTTL "$([[ ${hasScriptOwner} = true ]] && echo true)"; then return 1; fi
  
  owner_delegation_cert=""
  if [[ ${delegate_owner_wallet} = 'Y' ]]; then
    owner_delegation_cert="${owner_delegation_cert_file}"
  fi
  
  getAssetsTxOut
 
  tmpNewBalance=$(( base_lovelace - POOL_DEPOSIT )) 
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )
  [[ -n ${owner_delegation_cert} ]] && build_args+=( --certificate-file "${owner_delegation_cert}" )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1
  
  newBalance=$(( base_lovelace - min_fee - POOL_DEPOSIT ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${POOL_DEPOSIT}) )"
  
  if [[ ${base_lovelace} -lt $(( min_fee + POOL_DEPOSIT )) ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee and pool registration deposit!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee + POOL_DEPOSIT )))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and pool registration deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )
  [[ -n ${owner_delegation_cert} ]] && build_args+=( --certificate-file "${owner_delegation_cert}" )

  if [[ ${hw_owner_wallets} = 'Y' || ${hw_reward_wallet} = 'Y' || ${isHWpool} = 'Y' ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": \"${pledge_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": \"${cost_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"$(( min_fee + POOL_DEPOSIT ))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      getWalletType ${owner_wallets[${index}]}
      if [[ ${index} -eq 0 ]]; then
        if [[ ${wallet_type} -eq 5 ]]; then
          if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
        else
          if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
        fi
      fi
      if [[ ${wallet_type} -eq 5 ]]; then
        if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake script\", script: $(jq -c . "${stake_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      else
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
    done
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${hasScriptOwner} = true ]]; then
      println "Pool registration transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with owner wallets and pool cold key."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}${POOL_COLDKEY_SK_FILENAME}${NC}"
      println DEBUG "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_LGRAY}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
      for index in "${!owner_wallets[@]}"; do
        [[ ${index} -eq 0 ]] && continue # skip main owner
        println DEBUG "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
      done
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  multi_owner_keys=()
  for index in "${!owner_wallets[@]}"; do
    [[ ${index} -eq 0 ]] && continue # skip main owner
    getWalletType ${owner_wallets[${index}]}
    multi_owner_keys+=( "${stake_sk_file}" )
  done
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : modifyPool
# Description : Register pool with pledge on chain
modifyPool() {

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  # owner payment + cold + multi-owners(main owner included)
  unset witness_cnt hasScriptOwner
  script_args=()
  for index in "${!owner_wallets[@]}"; do
    getWalletType ${owner_wallets[${index}]}
    if [[ ${wallet_type} -eq 5 ]]; then
      op_mode=hybrid
      hasScriptOwner=true
      if [[ ${index} -eq 0 ]]; then
        unset required_total
        validateMultiSigScript false "$(cat "${payment_script_file}")"
        witness_cnt=${required_total}
        script_args+=( --tx-in-script-file "${payment_script_file}" )
      fi
      unset required_total
      validateMultiSigScript false "$(cat "${stake_script_file}")"
      witness_cnt=$(( witness_cnt + required_total ))
      script_args+=( --certificate-script-file "${stake_script_file}" )
    else
      [[ ${index} -eq 0 ]] && witness_cnt=1
      witness_cnt=$(( witness_cnt + 1 ))
    fi
  done
  witness_cnt=$(( witness_cnt + 1 )) # cold key witness

  if ! getTTL "$([[ ${hasScriptOwner} = true ]] && echo true)"; then return 1; fi
  
  getAssetsTxOut
 
  tmpNewBalance=${base_lovelace}
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1
  
  newBalance=$(( base_lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Update"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": \"${pledge_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": \"${cost_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      getWalletType ${owner_wallets[${index}]}
      if [[ ${index} -eq 0 ]]; then
        if [[ ${wallet_type} -eq 5 ]]; then
          if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
        else
          if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
        fi
      fi
      if [[ ${wallet_type} -eq 5 ]]; then
        if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake script\", script: $(jq -c . "${stake_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      else
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
    done
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${hasScriptOwner} = true ]]; then
      println "Pool update transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with owner wallets and pool cold key."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}${POOL_COLDKEY_SK_FILENAME}${NC}"
      println DEBUG "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_LGRAY}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
      for index in "${!owner_wallets[@]}"; do
        [[ ${index} -eq 0 ]] && continue # skip main owner
        println DEBUG "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
      done
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi

  multi_owner_keys=()
  for index in "${!owner_wallets[@]}"; do
    [[ ${index} -eq 0 ]] && continue # skip main owner
    getWalletType ${owner_wallets[${index}]}
    multi_owner_keys+=( "${stake_sk_file}" )
  done

  if ! witnessTx "${TMP_DIR}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : deRegisterPool
# Description : Retire pool
deRegisterPool() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="payment" || wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=$(( required_total + 1 ))
  else
    witness_cnt=2
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in "${!assets[@]}"; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
  fi

  getAssetsTxOut

  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=( --tx-in-script-file "${payment_script_file}" )
  fi

  tmpNewBalance=$(( lovelace ))
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${pool_deregcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi

  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_deregcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -f "${POOL_FOLDER}/${pool_name}/poolmeta.json" ]]; then
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"$(jq -r .name "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"$(jq -r .ticker "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"\" }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"retire-epoch\": \"${epoch_enter}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "Pool de-registration transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}$(basename ${pool_coldkey_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi

  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${pool_coldkey_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : rotatePoolKeys
# Description : Rotate pool's KES keys
# parameters  : $1 = cold counter (offline mode)
rotatePoolKeys() {

  # cold keys
  if getPoolType ${pool_name}; then needHWCLI="true"; else needHWCLI="false" ;fi

  # generated files
  pool_hotkey_vk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_VK_FILENAME}"
  pool_hotkey_sk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_SK_FILENAME}"
  pool_opcert_counter_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_COUNTER_FILENAME}"
  pool_saved_kes_start="${POOL_FOLDER}/${pool_name}/${POOL_CURRENT_KES_START}"
  pool_opcert_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_FILENAME}"

  if [[ ! -f ${pool_coldkey_vk_file} ]]; then # lets re-generate it from cold signing key
    println ACTION "${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file ${pool_coldkey_sk_file} --verification-key-file ${pool_coldkey_vk_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file "${pool_coldkey_sk_file}" --verification-key-file "${pool_coldkey_vk_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during cold verification key creation!\n${stdout}"; return 1
    fi
    println ACTION "jq '.description = \"Stake Pool Operator Verification Key\"' ${pool_coldkey_vk_file}"
    if ! stdout=$(jq '.description = "Stake Pool Operator Verification Key"' "${pool_coldkey_vk_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during cold verification key description update!\n${stdout}"; return 1
    else
      jq <<< ${stdout} > "${pool_coldkey_vk_file}"
    fi
  fi

  current_kes_period=$(getCurrentKESperiod)
  echo "${current_kes_period}" > ${pool_saved_kes_start}

  println ACTION "${CCLI} ${NETWORK_ERA} node key-gen-KES --verification-key-file ${pool_hotkey_vk_file} --signing-key-file ${pool_hotkey_sk_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} node key-gen-KES --verification-key-file "${pool_hotkey_vk_file}" --signing-key-file "${pool_hotkey_sk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during KES key creation!\n${stdout}"; return 1
  fi

  p_opcert=""
  if [[ $# -eq 1 ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value $1 --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value $1 --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate counter creation!\n${stdout}"; return 1
    fi
  elif [[ -n ${KOIOS_API} ]]; then
    ! getPoolID "${pool_name}" && println "ERROR" "\n${FG_RED}ERROR${NC}: failed to get pool ID!\n" && return 1
    HEADERS=("${KOIOS_API_HEADERS[@]}" -H "Content-Type: application/json")
    println ACTION "curl -sSL -f -X POST ${HEADERS[*]} -d '{\"_pool_bech32_ids\":[\"${pool_id_bech32}\"]}' ${KOIOS_API}/pool_info"
    ! pool_info=$(curl -sSL -f -X POST "${HEADERS[@]}" -d '{"_pool_bech32_ids":["'${pool_id_bech32}'"]}' "${KOIOS_API}/pool_info" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${pool_info}\n" && p_opcert="" # print error but ignore
    if old_counter_nbr=$(jq -er '.[0].op_cert_counter' <<< "${pool_info}" 2>/dev/null); then
      new_counter_nbr=$(( old_counter_nbr + 1 ))
    else
      new_counter_nbr=0 # null returned = no block on chain for this pool
    fi
    println ACTION "${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate counter creation!\n${stdout}"; return 1
    fi
  elif [[ -f ${pool_opcert_file} ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} query kes-period-info --op-cert-file ${pool_opcert_file} ${NETWORK_IDENTIFIER}"
    if ! kes_period_info=$(${CCLI} ${NETWORK_ERA} query kes-period-info --op-cert-file "${pool_opcert_file}" ${NETWORK_IDENTIFIER}); then
      println "ERROR" "\n${FG_RED}ERROR${NC}: failed to grab counter from node: [${kes_period_info}]\n" && return 1
    fi
    if old_counter_nbr=$(awk '/{/,0' <<< "${kes_period_info}" | jq -er '.qKesNodeStateOperationalCertificateNumber' 2>/dev/null); then
      new_counter_nbr=$(( old_counter_nbr + 1 ))
    else
      new_counter_nbr=0 # null returned = no block on chain for this pool
    fi
    println ACTION "${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate counter creation!\n${stdout}"; return 1
    fi
  else
    println "ERROR" "\n${FG_RED}ERROR${NC}: op cert file missing and Koios disabled/unavailable. Unable to get current on-chain counter value!\n" && return 1
  fi

  if [[ ${needHWCLI} = true ]]; then
    if ! unlockHWDevice "issue the opcert"; then return 1; fi
    println ACTION "cardano-hw-cli node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --hw-signing-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}"
    if ! stdout=$(cardano-hw-cli node issue-op-cert \
    --kes-verification-key-file "${pool_hotkey_vk_file}" \
    --hw-signing-file "${pool_coldkey_sk_file}" \
    --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" \
    --kes-period "${current_kes_period}" \
    --out-file "${pool_opcert_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during hardware operational certificate creation!\n${stdout}"; return 1
    fi
  else
    println ACTION "${CCLI} ${NETWORK_ERA} node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --cold-signing-key-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node issue-op-cert --kes-verification-key-file "${pool_hotkey_vk_file}" --cold-signing-key-file "${pool_coldkey_sk_file}" --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" --kes-period "${current_kes_period}" --out-file "${pool_opcert_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate creation!\n${stdout}"; return 1
    fi
  fi

  chmod 700 ${POOL_FOLDER}/${pool_name}/*

  unset remaining_kes_periods
  kesExpiration ${current_kes_period}
}

# Command     : sendMetadata
# Description : post metadata file on chain using specified wallet to pay for the transaction fee
sendMetadata() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="payment" || wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${metatype} = "no-schema" ]]; then
    metafile_param="--json-metadata-no-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "detailed-schema" ]]; then
    metafile_param="--json-metadata-detailed-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "cbor" ]]; then
    metafile_param="--metadata-cbor-file ${metafile}"
  else
    println ERROR "${FG_RED}ERROR${NC}: unknown metadata type '${metatype}'"
    return 1
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=${required_total}
  else
    witness_cnt=1
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in "${!assets[@]}"; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
  fi

  getAssetsTxOut

  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=( --tx-in-script-file "${payment_script_file}" )
  fi

  tmpNewBalance=$(( lovelace ))
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1
  
  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Metadata"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "Metadata transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : mintAsset
# Description : mint a custom asset using specified wallet to pay for the transaction fee
mintAsset() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="payment" || wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in "${!assets[@]}"; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    index_prefix="${addr},"
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
    unset index_prefix
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=$(( required_total + 1 ))
  else
    witness_cnt=2
  fi

  if [[ ${policy_ttl} -eq 0 ]]; then 
    if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi
  else
    ttl=${policy_ttl}
    tip_ref=$(getSlotTipRef)
    println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl} based on policy expiration"
  fi
  
  [[ -z ${asset_name} ]] && asset_name_out="" || asset_name_out=".$(asciiToHex "${asset_name}")"
  getAssetsTxOut "${index_prefix}${policy_id}${asset_name_out}" "${assets_to_mint}"
  
  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=( --tx-in-script-file "${payment_script_file}" )
  fi

  tmpNewBalance=$(( lovelace ))
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${addr}+${tmpNewBalance}${assets_tx_out}"
    --mint "${assets_to_mint} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1
  
  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --mint "${assets_to_mint} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Asset Minting"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-name\": \"${policy_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-id\": \"${policy_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-name\": \"$(asciiToHex "${asset_name}") (${asset_name})\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-amount\": \"${assets_to_mint}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-minted\": \"${asset_minted}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Asset '${policy_sk_file}' policy signing key\", vkey: $(jq -c . "${policy_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "Asset mint transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Policy ${FG_GREEN}${policy_name} ${FG_LGRAY}$(basename ${policy_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${policy_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : burnAsset
# Description : burn custom assets on specified wallet
burnAsset() {

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in "${!assets[@]}"; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    index_prefix="${addr},"
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
    unset index_prefix
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=$(( required_total + 1 ))
  else
    witness_cnt=2
  fi

  if [[ ${policy_ttl} -eq 0 ]]; then 
    if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi
  else
    ttl=${policy_ttl}
    tip_ref=$(getSlotTipRef)
    println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl} based on policy expiration"
  fi
  
  [[ -z ${asset_name} ]] && asset_name_out="" || asset_name_out=".${asset_name}"
  getAssetsTxOut "${index_prefix}${policy_id}${asset_name_out}" "-${assets_to_burn}"
  
  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=( --tx-in-script-file "${payment_script_file}" )
  fi

  tmpNewBalance=$(( lovelace ))
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${addr}+${tmpNewBalance}${assets_tx_out}"
    --mint "-${assets_to_burn} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"
  
  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --mint "-${assets_to_burn} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Asset Burning"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-name\": \"${policy_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-id\": \"${policy_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-name\": \"${asset_name} ($(hexToAscii ${asset_name}))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-amount\": \"${assets_to_burn}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-minted\": \"${asset_minted}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Asset '${policy_sk_file}' policy signing key\", vkey: $(jq -c . "${policy_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "Asset burn transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Policy ${FG_GREEN}${policy_name} ${FG_LGRAY}$(basename ${policy_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${policy_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : voteDelegation
# Description : delegate wallet to a DRep for governance actions
voteDelegation() {

  wallet_source="base"

  getWalletType ${wallet_name}
  wallet_type=$?

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ ${wallet_type} -eq 5 ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${payment_script_file}")"
    witness_cnt=${required_total}
    unset required_total
    validateMultiSigScript false "$(cat "${stake_script_file}")"
    witness_cnt=$(( witness_cnt + required_total ))
    stake_param=("--stake-script-file" "${stake_script_file}")
  else
    witness_cnt=2
    stake_param=("--stake-verification-key-file" "${stake_vk_file}")
  fi

  vote_deleg_cert_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_GOV_VOTE_DELEG_CERT_FILENAME}"
  VOTE_DELEG_CMD=(
    ${CCLI} ${NETWORK_ERA} stake-address vote-delegation-certificate
    "${stake_param[@]}"
    "${vote_param_arr[@]}"
    --out-file "${vote_deleg_cert_file}"
  )
  println ACTION "${VOTE_DELEG_CMD[*]}"
  if ! stdout=$("${VOTE_DELEG_CMD[@]}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during vote delegation certificate creation!\n${stdout}"; return 1
  fi

  if ! getTTL "$([[ ${wallet_type} -eq 5 ]] && echo true)"; then return 1; fi

  getAssetsTxOut

  unset script_args
  if [[ ${wallet_type} -eq 5 ]]; then
    script_args=(
      --tx-in-script-file "${payment_script_file}"
      --certificate-script-file "${stake_script_file}"
    )
  fi

  tmpNewBalance=${base_lovelace}
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${vote_deleg_cert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( base_lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi

  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${vote_deleg_cert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Vote Delegation"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"drep-hash\": \"${drep_hash}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"drep-id-cip105\": \"${drep_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"drep-id-cip129\": \"${drep_id_cip129}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${wallet_type} -eq 5 ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' payment script\", script: $(jq -c . "${payment_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${wallet_name}' stake script\", script: $(jq -c . "${stake_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${wallet_type} -eq 5 ]]; then
      println "MultiSig wallet vote delegation transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with MultiSig wallet participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi

  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : registerDRep
# Description : register as a DRep
registerDRep() {

  getWalletType ${wallet_name}
  wallet_type=$?
  wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ ${hash_type} = "scriptHash" ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${drep_script_file}")"
    witness_cnt=$(( required_total + 1 ))
  else
    witness_cnt=2
  fi

  if ! getTTL; then return 1; fi

  [[ ${is_update} = N ]] && println LOG "DRep deposit is ${FG_LBLUE}$(formatLovelace ${DREP_DEPOSIT})${NC}"

  getAssetsTxOut

  unset script_args
  if [[ ${hash_type} = "scriptHash" ]]; then
    script_args=(
      --certificate-script-file "${drep_script_file}"
    )
  fi

  if [[ ${is_update} = N ]]; then
    tmpNewBalance=$(( base_lovelace - DREP_DEPOSIT ))
  else
     tmpNewBalance=${base_lovelace}
  fi

  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${drep_cert_file}"
    "${script_args[@]}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  if [[ ${is_update} = N ]]; then
    fee=$(( DREP_DEPOSIT + min_fee ))
    newBalance=$(( base_lovelace - fee ))
    println LOG "New balance after DRep deposit and subtracted tx fee is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) - $(formatLovelace ${DREP_DEPOSIT}) - $(formatLovelace ${min_fee}))"
  else
    fee=${min_fee}
    newBalance=$(( base_lovelace - min_fee ))
    println LOG "New balance after subtracted tx fee is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}))"
  fi

  if [[ ${base_lovelace} -lt ${fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${fee})${NC} ADA"
    return 1
  fi

  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and DRep deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${drep_cert_file}"
    "${script_args[@]}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet DRep Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"drep-wallet-name\": \"${drep_wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if [[ ${hash_type} = "scriptHash" ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${drep_wallet_name}' DRep script\", script: $(jq -c . "${drep_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${drep_wallet_name}' DRep signing key\", vkey: $(jq -c . "${drep_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${hash_type} = "scriptHash" ]]; then
      println "MultiSig DRep registration transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with fee wallet and MultiSig DRep participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${drep_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi

  if ! witnessTx "${TMP_DIR}/tx.raw" "${drep_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : retireDRep
# Description : retire as a DRep and get DRep deposit back
retireDRep() {

  getWalletType ${wallet_name}
  wallet_type=$?
  wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ ${hash_type} = "scriptHash" ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${drep_script_file}")"
    witness_cnt=$(( required_total + 1 ))
  else
    witness_cnt=2
  fi

  if ! getTTL; then return 1; fi

  println LOG "DRep deposit to be returned is ${FG_LBLUE}$(formatLovelace ${drep_deposit_amt})${NC}"

  getAssetsTxOut

  unset script_args
  if [[ ${hash_type} = "scriptHash" ]]; then
    script_args=(
      --certificate-script-file "${drep_script_file}"
    )
  fi

  tmpNewBalance=$(( base_lovelace + drep_deposit_amt ))
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --certificate-file "${drep_cert_file}"
    "${script_args[@]}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( base_lovelace + drep_deposit_amt - min_fee ))
  println LOG "New balance after returned DRep deposit and subtracted tx fee is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) + $(formatLovelace ${drep_deposit_amt}) - $(formatLovelace ${min_fee}))"

  if [[ $(( base_lovelace + drep_deposit_amt )) -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Returned deposit: ${FG_LBLUE}$(formatLovelace ${drep_deposit_amt})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee} )))${NC} ADA"
    return 1
  fi

  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and DRep deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${drep_cert_file}"
    "${script_args[@]}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet DRep Retire"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"drep-wallet-name\": \"${drep_wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if [[ ${hash_type} = "scriptHash" ]]; then
      if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${drep_wallet_name}' DRep script\", script: $(jq -c . "${drep_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${drep_wallet_name}' DRep signing key\", vkey: $(jq -c . "${drep_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${hash_type} = "scriptHash" ]]; then
      println "MultiSig DRep retire transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with fee wallet and MultiSig DRep participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${drep_sk_file})${NC}"
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi

  if ! witnessTx "${TMP_DIR}/tx.raw" "${drep_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : governanceVote
# Description : cast governance vote
governanceVote() {

  getWalletType ${wallet_name}
  wallet_type=$?
  wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ ${vote_mode} = "drep" && ${hash_type} = "scriptHash" ]]; then
    op_mode=hybrid
    unset required_total
    validateMultiSigScript false "$(cat "${drep_script_file}")"
    witness_cnt=$(( required_total + 1 ))
  else
    witness_cnt=2
  fi

  if ! getTTL; then return 1; fi

  getAssetsTxOut

  unset script_args
  if [[ ${vote_mode} = "drep" && ${hash_type} = "scriptHash" ]]; then
    script_args=(
      --tx-in-script-file "${drep_script_file}"
    )
  fi

  tmpNewBalance=${base_lovelace}
  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${base_addr}+${tmpNewBalance}${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${DUMMYFEE}
    --vote-file "${vote_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  buildTx || return 1

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_cnt} || return 1

  newBalance=$(( base_lovelace - min_fee ))
  println LOG "New balance after subtracted tx fee is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}))"

  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi

  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    "${script_args[@]}"
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --vote-file "${vote_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if [[ ${wallet_type} -eq 0 ]]; then
    buildTx "${TMP_DIR}/tx.raw" || return 1
  else
    buildTx || return 1
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Governance Vote"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"action-id\": \"${action_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"action-id-cip129\": \"${action_id_cip129}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { vote: \"${vote_param//-}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if [[ ${vote_mode} = "spo" ]]; then
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    elif [[ ${vote_mode} = "drep" ]]; then
      if ! offlineJSON=$(jq ". += { \"drep-wallet-name\": \"${drep_wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
      if [[ ${hash_type} = "scriptHash" ]]; then
        if ! offlineJSON=$(jq ".\"script-file\" += [{ name: \"Wallet '${drep_wallet_name}' DRep script\", script: $(jq -c . "${drep_script_file}") }]" <<< ${offlineJSON}); then return 1; fi
      else
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${drep_wallet_name}' DRep signing key\", vkey: $(jq -c . "${drep_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
    else
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' committee hot signing key\", vkey: $(jq -c . "${cc_hot_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    if [[ ${vote_mode} = "drep" && ${hash_type} = "scriptHash" ]]; then
      println "MultiSig DRep vote transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "Use CNTools [Transaction >> Sign] to witness the transaction with fee wallet and MultiSig DRep participants."
    else
      println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
      println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
      println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
      if [[ ${vote_mode} = "spo" ]]; then
        println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}$(basename ${pool_coldkey_sk_file})${NC}"
      elif [[ ${vote_mode} = "drep" ]]; then
        println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${drep_sk_file})${NC}"
      else
        println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${cc_hot_sk_file})${NC}"
      fi
    fi
    return 2 # return as failed to stop main processing and return to home menu
  fi

  if [[ ${vote_mode} = "spo" ]]; then
    vote_key="${pool_coldkey_sk_file}"
  elif [[ ${vote_mode} = "drep" ]]; then
    vote_key="${drep_sk_file}"
  else
    vote_key="${cc_hot_sk_file}"
  fi
  if ! witnessTx "${TMP_DIR}/tx.raw" "${vote_key}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : buildTx [out_file]
# Description : Helper function to build a raw transaction
#             : populate an array variable called 'build_args' with all data
# Parameters  : out_file  >  (optional) output file of tx build command needed for HW transform
buildTx() {
  println ACTION "${CCLI} ${NETWORK_ERA} transaction build-raw ${build_args[*]}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} transaction build-raw "${build_args[@]}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during transaction building!\n${stdout}"; return 1
  fi
  if [[ -n $1 ]] && command -v "cardano-hw-cli" &>/dev/null; then
    HWCLIversionCheck || return 1
    transformRawTx "$1" || return 1
  fi
}

# Command     : calcMinFee [rax tx file] 
# Description : Helper function to calculate minimum fee from a build transaction
# Parameters  : $1 = raw tx file > the transaction body file to use for calculating fee
#               $2 = Count of transaction inputs (spent txo count)
#               $3 = Count of transaction outputs
#               $4 = Count of witnesses required to sign the transaction
calcMinFee() {
  min_fee_args=(
    ${NETWORK_ERA}
    transaction calculate-min-fee
    --tx-body-file "$1"
    --tx-in-count $2
    --tx-out-count $3
    --witness-count $4
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  if ! stdout=$(${CCLI} "${min_fee_args[@]}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during minimum fee calculation!\n${stdout}"; return 1
  fi
  min_fee=$([[ ${stdout} =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) ADA"
}

# Command     : witnessTx [raw tx file] [signing keys ...]
# Description : Helper function to witness a raw transaction
# Parameters  : raw tx file   >  the transaction file to sign
#             : signing keys  >  list of signing keys to use when witnessing the transaction
witnessTx() {
  tx_raw="$1"
  shift
  tx_witness_files=()
  unset isHW
  for skey in "$@"; do
    [[ -z ${skey//[[:blank:]]/} ]] && continue
    skey_name=$(basename "${skey}")
    if [[ ! -f "${skey}" ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: file not found: ${skey}"
      return 1
    elif [[ $(jq -r '.description' "${skey}") = *"Hardware"* ]]; then # HW signing key
      if [[ ${isHW} = 'Y' ]]; then
        # just add key and output to witness_command()
        tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
        hw_witness_command+=(
          --hw-signing-file "${skey}"
          --change-output-key-file "${skey}"
          --out-file "${tx_witness}"
        )
      else
        isHW=Y
        tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
        hw_witness_command=(
          cardano-hw-cli transaction witness
          --tx-file "${tx_raw}"
          --hw-signing-file "${skey}"
          --change-output-key-file "${skey}"
          --out-file "${tx_witness}"
          ${NETWORK_IDENTIFIER}
        )
      fi
    else
      tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
      witness_command=(
        ${CCLI} ${NETWORK_ERA} transaction witness
        --tx-body-file "${tx_raw}"
        --signing-key-file "${skey}"
        ${NETWORK_IDENTIFIER}
        --out-file "${tx_witness}"
      )
      println ACTION "${witness_command[@]}"
      if ! stdout=$("${witness_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during transaction signing !!\n${stdout}" && return 1; fi
    fi
    tx_witness_files+=( "${tx_witness}" )
  done

  # Special case for HW
  if [[ ${isHW} = 'Y' ]]; then
    if ! unlockHWDevice "witness the transaction"; then return 1; fi
    println ACTION "${hw_witness_command[@]}"
    if ! stdout=$("${hw_witness_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during hardware wallet signing !!\n${stdout}" && return 1; fi
  fi
}

# Command     : assembleTx [raw tx file]
# Description : Helper function to witnessTx for assembling a signed tx using witnesses from tx_witness_files[] array
assembleTx() {
  tx_raw="$1"
  tx_signed="${TMP_DIR}/tx.signed_$(date +%s)"
  if [[ ${#tx_witness_files[@]} -gt 0 ]]; then # assemble witness files and sign
    tx_witness_out=()
    for witness in "${tx_witness_files[@]}"; do
      [[ -z ${witness//[[:blank:]]/} || ! -s "${witness}" ]] && continue
      if [[ -f "${witness}" ]]; then
        tx_witness_out+=( "--witness-file ${witness}" )
      else
        println ERROR "\n${FG_RED}ERROR${NC}: witness file not found: ${witness}"
        return 1
      fi
    done
    sign_command=(
      ${CCLI} ${NETWORK_ERA} transaction assemble
      --tx-body-file "${tx_raw}"
      ${tx_witness_out[@]}
      --out-file "${tx_signed}"
    )
    println ACTION "${sign_command[@]}"
    if ! stdout=$("${sign_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during hardware wallet signing !!\n${stdout}" && return 1; fi
  else
    println ERROR "\n${FG_RED}ERROR${NC}: no witness files provided, unable to assemble tx!"
    return 1
  fi
}

# Command     : submitTx [signed tx file]
# Description : Helper function to submit signed transaction file
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTx() {
  tx_signed="$1"
  answer=0
  while true; do
    if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
      submitTxNode ${tx_signed} && break
    else
      submitTxKoiosOgmios ${tx_signed} && break
    fi
    tput sc
    println DEBUG "\nRetry transaction submit?"
    select_opt "[y] Yes" "[n] No"
    answer=$?
    tput rc && tput ed
    case ${answer} in
      0) : ;;
      1) break ;;
    esac
  done
  return ${answer}
}

# Command     : submitTxNode [signed tx file]
# Description : Helper function to submit signed transaction file using local node
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTxNode() {
  getTxId $1 || return $?
  submit_command=(
    ${CCLI} ${NETWORK_ERA} transaction submit
    --tx-file "$1"
    ${NETWORK_IDENTIFIER}
  )
  println ACTION "${submit_command[@]}"
  if ! stdout=$("${submit_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: Transaction submit failed !!\n${stdout}"; return 1; fi
}

# Command     : getTxId [tx file]
# Description : Helper function to calculate transaction id
# Parameters  : signed tx file   >  the signed transaction file to submit
# Info        : tx_id set to hash of transaction body
getTxId() {
  txid_command=(
    ${CCLI} ${NETWORK_ERA} transaction txid
    --tx-file "$1"
  )
  println ACTION "${txid_command[@]}"
  if ! tx_id=$("${txid_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during transaction hashing !!\n${tx_id}" && return 1; fi
}

# Command     : submitTxKoiosSubmitAPI [signed tx file]
# Description : Helper function to submit signed transaction file using koios submitapi endpoint
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTxKoiosSubmitAPI() {
  getTxId $1 || return $?
  cborHex=$(jq -er '.cborHex' "$1" 2>/dev/null) || { println ERROR "\n${FG_RED}ERROR${NC}: Invalid tx file format, 'cborHex' missing in: $1"; return 1; }
  txdata="$(mktemp "${TMP_DIR}/tx.signed_XXXXXXXXXX")"
  xxd -p -r <<< ${cborHex} > ${txdata}
  HEADERS=("${KOIOS_API_HEADERS[@]}" -H "Content-Type: application/cbor")
  println ACTION "curl -sfSL -X POST ${HEADERS[*]} --data-binary @${txdata} \"${KOIOS_API}/submittx\""
  if ! stdout=$(curl -sfSL -X POST "${HEADERS[@]}" --data-binary @${txdata} "${KOIOS_API}/submittx" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction submit failed !!\n${stdout}"; return 1
  fi
  println LOG "Submit result: ${stdout}"
}

# Command     : submitTxKoiosOgmios [signed tx file]
# Description : Helper function to submit signed transaction file using koios submitapi endpoint
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTxKoiosOgmios() {
  getTxId $1 || return $?
  cborHex=$(jq -er '.cborHex' "$1" 2>/dev/null) || { println ERROR "\n${FG_RED}ERROR${NC}: Invalid tx file format, 'cborHex' missing in: $1"; return 1; }
  jsonrpc=$(jq -n -c --arg cbor "${cborHex}" '{jsonrpc: "2.0", method: "submitTransaction", params: {transaction: {cbor: $cbor}}}')
  unset ogmios_error
  HEADERS=("${KOIOS_API_HEADERS[@]}" -H "accept: application/json" -H "Content-Type: application/json")
  println ACTION "curl -sSL -X POST ${HEADERS[*]} -d \"${jsonrpc}\" \"${KOIOS_API}/ogmios/\""
  stdout=$(curl -sSL -X POST "${HEADERS[@]}" -d "${jsonrpc}" "${KOIOS_API}/ogmios/" 2>&1)
  if [[ -z ${stdout} ]] || ogmios_error=$(jq -er '.error //empty' <<< "${stdout}") || ! jq -er '.result //empty' <<< "${stdout}" &>/dev/null; then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction submit failed !!"
    if [[ -n ${ogmios_error} ]]; then
      jq -r . <<< "${ogmios_error}"
      println LOG "$(jq -rc . <<< ${ogmios_error})"
    else
      println ERROR "Ogmios API error: ${stdout}"
    fi
    return 1
  fi
  ogmios_res=$(jq -erc '.result' <<< "${stdout}") && println LOG "Submit result: ${ogmios_res}"
}

# Command     : transformRawTx [raw tx file]
# Description : Transform raw tx to be in canonical order for HW wallets 
# Parameters  : raw tx file  >  path to raw tx to correct
transformRawTx() {
  tx_raw="$1"
  tx_raw_tmp="$(mktemp "${TMP_DIR}/tx.raw_XXXXXXXXXX")"
  println ACTION "cardano-hw-cli transaction transform --tx-file ${tx_raw} --out-file ${tx_raw_tmp}"
  if ! stdout=$(cardano-hw-cli transaction transform --tx-file "${tx_raw}" --out-file "${tx_raw_tmp}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction transform failed !!\n${stdout}"; return 1
  fi
  println ACTION "mv ${tx_raw_tmp} ${tx_raw}"
  if ! stdout=$(mv "${tx_raw_tmp}" "${tx_raw}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction transform failure moving temporary file to ${tx_raw} !!\n${stdout}"; return 1
  fi
}

# Command     : unlockHWDevice [action]
# Description : Directions to unlock and open HW device
# Parameters  : action  >  message for action to be taken
unlockHWDevice() {
  if ! HWCLIversionCheck; then waitToProceed && return 1; fi
  waitToProceed "${FG_BLUE}INFO${NC}: please connect and unlock hardware device" "\n  ${FG_YELLOW}Ledger${NC} - Unlock with pin and open Cardano app" "\n  ${FG_YELLOW}Trezor${NC} - Make sure trezor bridge is installed (https://wallet.trezor.io/#/bridge) " "\n\nwhen done, press any key to continue"
  println ACTION "cardano-hw-cli device version"
  if ! device_app=$(cardano-hw-cli device version 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: accessing hardware device failed !!\n${device_app}"; return 1
  fi
  device_app_vendor="$(cut -d' ' -f1 <<< "${device_app}")"
  device_app_version="$(cut -d' ' -f4 <<< "${device_app}")"
  println LOG "hardware device: vendor=${device_app_vendor} version=${device_app_version}"
  if [[ ! ${device_app_version} =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    println ERROR "${FG_RED}ERROR${NC}: unable to identify connected hardware device, is the device plugged in and unlocked?"
    println ERROR "Make sure device is seen by OS using tools like lsusb etc and is working correctly"
    waitToProceed && return 1
  fi
  println DEBUG "\n${FG_BLUE}INFO${NC}: follow directions on hardware device to $1"
}

HWCLIversionCheck() {
  ! command -v "cardano-hw-cli" &>/dev/null && echo "cardano-hw-cli not found, please install using guild-deploy.sh with '-s w' option" && return 1
  println ACTION "cardano-hw-cli version"
  HWCLI_version="$(cardano-hw-cli version 2>/dev/null | head -n 1 | cut -d' ' -f6)"
  println LOG "cardano-hw-cli version: ${HWCLI_version}"
  if ! versionCheck "1.16.0" "${HWCLI_version}"; then
    println ERROR "${FG_RED}ERROR${NC}: Vacuumlabs cardano-hw-cli ${FG_LGRAY}v${HWCLI_version}${NC} installed on system, minimum required version is ${FG_GREEN}v1.16.0${NC} !!"
    println ERROR "Please run ${FG_LGRAY}guild-deploy.sh -s w${NC} to upgrade to the latest version."
    return 1
  fi
  return 0
}

# Command     : selectOpMode
# Description : Helper function to choose operational mode
selectOpMode() {
  println OFF "\nOnline mode  -  The default mode to use if all keys are available\n"\
		"Hybrid mode  -  1) Go through steps to build a transaction file"\
		"                2) Copy built tx file to offline computer"\
		"                3) Sign it using 'Sign Tx' with keys on offline computer"\
		"                   (CNTools started in offline mode '-o' without node connection)"\
		"                4) Copy the signed tx file back to online computer and submit using 'Submit Tx'\n"
  select_opt "[o] Online" "[h] Hybrid" "[Esc] Cancel"
  case $? in
    0) op_mode="online" ;;
    1) op_mode="hybrid" ;;
    2) return 1 ;;
  esac
}

# Command     : to_cbor
# Description : converts different majortypes and there values into a cborHexString
# Original src: SPO Scripts (https://github.com/gitmachtl/scripts/blob/master/cardano/testnet/00_common.sh#L979) 
to_cbor() {

  # ${1} type: unsigned, negative, bytes, string, array, map, tag
  # ${2} value: unsigned int value or hexstring for bytes

  local type=${1}
  local value="${2}"

  # majortypes
  #  unsigned      000x|xxxx       majortype 0     not limited, but above 18446744073709551615 (2^64), the numbers are represented via tag2 + bytearray
  #  bytes         010x|xxxx       majortype 2     limited to max. 65535 here
  #  array         100x|xxxx       majortype 4     limited to max. 65535 here
  #  map           101x|xxxx       majortype 5     limited to max. 65535 here
  # extras - not used yet but implemented for the future
  #  negative    001x|xxxx    majortype 1    not limited, but below -18446744073709551616 (-2^64 -1), the numbers are represented via tag3 + bytearray
  #  string    011x|xxxx    majortype 3    limited to max. 65535 chars
  #  tag           110x|xxxx       majortype 6     limited to max. 65535 here

  case ${type} in
    #unsigned - input is an unsigned integer, range is selected via a bc query because bash can't handle big numbers
    unsigned )
      if [[ $(bc <<< "${value} < 24") -eq 1 ]]; then printf -v cbor "%02x" $((10#${value})) #1byte total value below 24
      elif [[ $(bc <<< "${value} < 256") -eq 1 ]]; then printf -v cbor "%04x" $((0x1800 + 10#${value})) #2bytes total: first 0x1800 + 1 lower byte value
      elif [[ $(bc <<< "${value} < 65536") -eq 1 ]]; then printf -v cbor "%06x" $((0x190000 + 10#${value})) #3bytes total: first 0x190000 + 2 lowerbytes value
      elif [[ $(bc <<< "${value} < 4294967296") -eq 1 ]]; then printf -v cbor "%10x" $((0x1A00000000 + 10#${value})) #5bytes total: 0x1A00000000 + 4 lower bytes value
      elif [[ $(bc <<< "${value} < 18446744073709551616") -eq 1 ]]; then local tmp;tmp="00$(bc <<< "obase=16;ibase=10;${value}+498062089990157893632")"; cbor="${tmp: -18}" #9bytes total: first 0x1B0000000000000000 + 8 lower bytes value
      #if value does not fit into an 8byte unsigned integer, the cbor representation is tag2(pos.bignum)+bytearray of the value
      else local cbor;cbor=$(to_cbor "tag" 2); local tmp;tmp="00$(bc <<< "obase=16;ibase=10;${value}")"; tmp=${tmp: -$(( (${#tmp}-1)/2*2 ))}; local cbor;cbor+=$(to_cbor "bytes" ${tmp}) #fancy calc to get a leading zero in the hex array if needed
      fi
      ;;
    #bytestring - input is a hexstring
    bytes )
      local bytesLength=$(( ${#value} / 2 ))  #bytesLength is length of value /2 because of hex encoding (2chars -> 1byte)
      if [[ ${bytesLength} -lt 24 ]]; then printf -v cbor "%02x${value}" $((0x40 + 10#${bytesLength})) #1byte total 0x40 + lower part value & bytearrayitself
      elif [[ ${bytesLength} -lt 256 ]]; then printf -v cbor "%04x${value}" $((0x5800 + 10#${bytesLength})) #2bytes total: first 0x4000 + 0x1800 + 1 lower byte value & bytearrayitself
      elif [[ ${bytesLength} -lt 65536 ]]; then printf -v cbor "%06x${value}" $((0x590000 + 10#${bytesLength})) #3bytes total: first 0x400000 + 0x190000 + 2 lower bytes value & bytearrayitself
      fi
      ;;
    #array - input is an unsigned integer
    array )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0x80 + 10#${value})) #1byte total 0x80 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0x9800 + 10#${value})) #2bytes total: first 0x8000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0x990000 + 10#${value})) #3bytes total: first 0x800000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    #map - input is an unsigned integer
    map )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0xA0 + 10#${value})) #1byte total 0xA0 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0xB800 + 10#${value})) #2bytes total: first 0xA000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0xB90000 + 10#${value})) #3bytes total: first 0xA00000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    ###
    ### the following types are not used in these scripts yet, but added to have a more complete function for the future
    ###
    #negative - input is a negative unsigned integer, range is selected via a bc query because bash can't handle big numbers
    negative )
      local value;value="$(bc <<< "${value//-/} -1")" #negative representation in cbor is the neg. number as a pos. number minus 1, so a -500 will be represented as a 499
      if [[ $(bc <<< "${value} < 24") -eq 1 ]]; then printf -v cbor "%02x" $((0x20 + 10#${value})) #1byte total 0x20 value below 24
      elif [[ $(bc <<< "${value} < 256") -eq 1 ]]; then printf -v cbor "%04x" $((0x3800 + 10#${value})) #2bytes total: first 0x2000 + 0x1800 + 1 lower byte value
      elif [[ $(bc <<< "${value} < 65536") -eq 1 ]]; then printf -v cbor "%06x" $((0x390000 + 10#${value})) #3bytes total: first 0x200000 + 0x190000 + 2 lowerbytes value
      elif [[ $(bc <<< "${value} < 4294967296") -eq 1 ]]; then printf -v cbor "%10x" $((0x3A00000000 + 10#${value})) #5bytes total: 0x2000000000 + 0x1A00000000 + 4 lower bytes value
      elif [[ $(bc <<< "${value} < 18446744073709551616") -eq 1 ]]; then local tmp;tmp="00$(bc <<< "obase=16;ibase=10;${value}+1088357900348863545344")"; cbor="${tmp: -18}" #9bytes total: first 0x3B0000000000000000 + 8 lower bytes value
      #if value does not fit into an 8byte unsigned integer, the cbor representation is tag3(neg.bignum)+bytearray of the value
      else local cbor;cbor=$(to_cbor "tag" 3); local tmp;tmp="00$(bc <<< "obase=16;ibase=10;${value}")"; tmp=${tmp: -$(( (${#tmp}-1)/2*2 ))}; local cbor;cbor+=$(to_cbor "bytes" ${tmp}) #fancy calc to get a leading zero in the hex array if needed
      fi
      ;;
    #tag - input is an unsigned integer
    tag )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0xC0 + 10#${value})) #1byte total 0xC0 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0xD800 + 10#${value})) #2bytes total: first 0xC000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0xD90000 + 10#${value})) #3bytes total: first 0xC00000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    #textstring - input is a utf8-string
    string )
      local value;value="$(echo -ne "${value}" | xxd -p -c 65536 | tr -d '\n')" #convert the given string into a hexstring and process it further like a bytearray
      local bytesLength;bytesLength=$(( ${#value} / 2 ))  #bytesLength is length of value /2 because of hex encoding (2chars -> 1byte)
      if [[ ${bytesLength} -lt 24 ]]; then printf -v cbor "%02x${value}" $((0x60 + 10#${bytesLength})) #1byte total 0x60 + lower part value & bytearrayitself
      elif [[ ${bytesLength} -lt 256 ]]; then printf -v cbor "%04x${value}" $((0x7800 + 10#${bytesLength})) #2bytes total: first 0x6000 + 0x1800 + 1 lower byte value & bytearrayitself
      elif [[ ${bytesLength} -lt 65536 ]]; then printf -v cbor "%06x${value}" $((0x790000 + 10#${bytesLength})) #3bytes total: first 0x600000 + 0x190000 + 2 lower bytes value & bytearrayitself
      fi
      ;;
  esac
  echo -n "${cbor^^}" #return the cbor in uppercase
}

# Command     : getPriceInfo
# Description : fetch current ADA price from coingecko in selected currency
getPriceInfo() {

  [[ -z ${CURRENCY_URL} ]] && return

  if ! price_info=$(curl -sSL -f -m 3 "${CURRENCY_URL}" 2>&1); then
    logln "ERROR" "${price_info}"
    return
  fi
  if ! jq -e ".cardano.${CURRENCY}" <<< ${price_info} &>/dev/null; then
    logln "ERROR" "invalid currency set, please check config!"
    return
  fi

  price_info_tsv=$(jq -r "[
  .cardano.${CURRENCY} //0,
  .cardano.${CURRENCY}_24h_change //0
  ] | @tsv" <<< "${price_info}")

  read -ra price_info_arr <<< ${price_info_tsv}

  price_now=${price_info_arr[0]}
  price_24h=$(LC_NUMERIC=C printf "%.2f" "${price_info_arr[1]}")
}

# Command     : getPriceString
# Description : construct the ada value price string in set currency from lovelace value
getPriceString() {
  unset price_str
  if [[ -n ${price_now} && $1 -ne 0 ]]; then
    ada_value=$(bc -l <<< "${price_now}*($1/1000000)")
    getDecimalPlaces ${ada_value}
    decimals=$?
    price_str=$(LC_NUMERIC=C printf " (${FG_LBLUE}%s${NC} ${CURRENCY^^})" "$(formatAsset "$(LC_NUMERIC=C printf "%.${decimals}f" "${ada_value}")")")
  fi
}
