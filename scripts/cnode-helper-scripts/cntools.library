#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2086,SC2230,SC2206,SC2140,SC2059,SC2154

######################################
# Do NOT modify code below           #
######################################

############################################################
# Variables to keep counter for versions                   #
############################################################
# The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
# and this adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
# Major: Any considerable change in the code base, big feature, workflow or breaking change from previous version
CNTOOLS_MAJOR_VERSION=13
# Minor: Changes and features of minor character that can be applied without breaking existing functionality or workflow
CNTOOLS_MINOR_VERSION=0
# Patch: Backwards compatible bug fixes. No additional functionality or major changes
CNTOOLS_PATCH_VERSION=0

CNTOOLS_VERSION="${CNTOOLS_MAJOR_VERSION}.${CNTOOLS_MINOR_VERSION}.${CNTOOLS_PATCH_VERSION}"

############################################################
# Default config values                                    #
# overriden by values set in cntools.sh                    #
############################################################
TMP_DIR="${TMP_DIR}/cntools"
if ! mkdir -p "${TMP_DIR}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create directory for temporary files: ${TMP_DIR}"; fi
if ! mkdir -p "${WALLET_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create wallet directory: ${WALLET_FOLDER}"; fi
if ! mkdir -p "${POOL_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create pool directory: ${POOL_FOLDER}"; fi
if ! mkdir -p "${ASSET_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create asset directory: ${POOL_ASSET}"; fi
[[ -z ${CNTOOLS_MODE} ]] && CNTOOLS_MODE=LOCAL || CNTOOLS_MODE=${CNTOOLS_MODE^^}
if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
  CNTOOLS_MODE_COLOR="${FG_BLUE}"
elif [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
  CNTOOLS_MODE_COLOR="${FG_GREEN}"
else
  CNTOOLS_MODE_COLOR="${FG_GRAY}"
fi
printf -v launch_modes_info "${FG_BLUE}INFO${NC}: Available launch modes, re-run CNTools in
  ${CNTOOLS_MODE_COLOR}LOCAL${NC} mode (-n): Default mode with a local node connection.
  ${CNTOOLS_MODE_COLOR}LIGHT${NC} mode (-l): Utilizing Koios query layer with full functionallity for supported networks.
  ${CNTOOLS_MODE_COLOR}OFFLINE${NC} mode (-o): A limited set of functionallity without external communication useful for air-gapped mode."
[[ -z ${TIMEOUT_NO_OF_SLOTS} ]] && TIMEOUT_NO_OF_SLOTS=600
[[ -z ${TX_TTL} ]] && TX_TTL=3600
[[ -z ${WALLET_SELECTION_FILTER_LIMIT} ]] && WALLET_SELECTION_FILTER_LIMIT=10
[[ -z ${KES_ALERT_PERIOD} ]] && KES_ALERT_PERIOD=172800 # default 2 days
[[ -z ${KES_WARNING_PERIOD} ]] && KES_WARNING_PERIOD=604800 # default 7 days
[[ $(uname) == Darwin ]] && ENABLE_CHATTR=false
[[ -z ${ENABLE_CHATTR} ]] && ENABLE_CHATTR=true
[[ -z ${ENABLE_DIALOG} ]] && ENABLE_DIALOG=false
[[ ${ENABLE_ADVANCED} = "true" ]] && ADVANCED_MODE="true"
[[ -z ${CHECK_KES} ]] && CHECK_KES=true
[[ -z ${CNTOOLS_LOG} ]] && CNTOOLS_LOG="${LOG_DIR}/cntools-history.log"
[[ -z ${CURRENCY} ]] && CURRENCY="off" || CURRENCY=${CURRENCY,,}
[[ ${CURRENCY} = off || ${NETWORK_NAME} != Mainnet ]] && unset CURRENCY_URL || CURRENCY_URL="https://api.coingecko.com/api/v3/simple/price?ids=cardano&vs_currencies=${CURRENCY}&include_24hr_change=true"

############################################################
# library sourced by cntools with common taskes to perform #
############################################################

# Assumes that env has been sourced by calling script

# Command     : logln [log level] [message]
# Description : write message to log file with log level specified
logln() {
  local log_level=$1
  shift
  [[ -z $1 ]] && return
  echo -e "$@" | while read -r log_line; do
    log_line=$(sed -E 's/\x1b(\[[0-9;]*[a-zA-Z]|[0-9])//g' <<< ${log_line##*( )})
    [[ -z ${log_line} ]] && continue
    printf '%s %-8s %s\n' "$(date "+%F %T %Z")" "[${log_level}]" "${log_line}" >> "${CNTOOLS_LOG}"
  done
}

# Command     : println [log level] [newline] [message]
# Description : print and log(if enabled) message
# Parameters  : log level  >  log level (default: INFO)
#                             OFF    : logging disabled, output only to tty
#                             LOG    : logged as DEBUG but not printed to tty
#                             DEBUG  : verbose output, logged and printed to tty
#                             INFO   : normal output printed to tty and logged
#                             ACTION : e.g cardano-cli executions etc, logged but not printed to tty
#                             ERROR  : stderr output and error messages
#             : newline    >  Add a newline at the end for tty output (default true) 
#             : message    >  The message to print/log
println() {  
  local log_level=$1
  shift
  local newline="\n"
  if [[ $1 = false && $# -gt 2 ]]; then unset newline; shift; elif [[ $1 = true && $# -gt 2 ]]; then shift; fi
  case $log_level in
    OFF) printf "%b${newline}" "$@" ;;
    LOG) logln "DEBUG" "$@" ;;
    DEBUG) printf "%b${newline}" "$@"; logln "DEBUG" "$@" ;;
    INFO) printf "%b${newline}" "$@"; logln "INFO" "$@" ;;
    ACTION) logln "ACTION" "$@" ;;
    ERROR) printf "%b${newline}" "$@"; logln "ERROR" "$@" ;;
    *) println INFO "${log_level}" "$@" ;;
  esac
}

# Command     : getAnswerAnyCust [variable name] [log] [question]
# Description : wrapper function for getAnswerAny() in env to read input from stdin 
#               and save response into provided variable name while also logging response
# Parameters  : variable name  >  the name of the variable to save users response into
#             : log            >  [true|false] log question (default: true)
#             : question       >  what to ask user to input
getAnswerAnyCust() {
  var_name=$1
  shift
  local log_question=true
  if [[ $1 =~ true|false ]]; then
    [[ $1 = false ]] && log_question=false
    shift
  fi
  getAnswerAny "${var_name}" "$*"
  [[ ${log_question} = true ]] && println LOG "$*: ${!var_name}"
}

# Command     : archiveLog
# Description : archive old log file and clean archive folder keeping last 10 log files
archiveLog() {
  [[ -z ${CNTOOLS_LOG} ]] && return
  log_archive="$(dirname "${CNTOOLS_LOG}")/archive"
  log_file="$(basename "${CNTOOLS_LOG}")"
  mkdir -p "${log_archive}"
  [[ -f ${CNTOOLS_LOG} ]] && mv -f "${CNTOOLS_LOG}" "${log_archive}/${log_file}_$(date +%s)"
  find "${log_archive}" -maxdepth 1 -type f -name "${log_file}*" -printf '%Ts\t%p\n' | sort -n | head -n -10 | cut -f 2- | xargs rm -rf
}

# Command     : protectionPreRequisites
# Description : Check if needed protection prerequisites is available, else print error
protectionPreRequisites() {
  ! cmdAvailable "gpg" && return 1

  if ! cmdAvailable "chattr" &>/dev/null; then
    [[ ${ENABLE_CHATTR} = true ]] && echo -e "chattr command not available but enabled in config, please install or disable in cntools.sh and re-run CNTools" && return 1
  elif [[ ${ENABLE_CHATTR} = true ]]; then # chattr available and enabled, make sure sudo access to chattr is enabled
    touch "${TMP_DIR}"/test
    echo -e "Testing chattr access permission, enter user password if requested..."
    if ! sudo chattr -i "${TMP_DIR}"/test; then
      rm -f "${TMP_DIR}"/test
      echo -e "\n${FG_YELLOW}WARN${NC}: Elevated privileges needed for chattr command used to write protect wallet and pool keys"
      echo -e "Add required sudo permissions or run the following command to add passwordless sudo access to chattr command for '$(whoami)' user"
      echo -e "echo \"$(whoami) ALL=NOPASSWD: $(command -v chattr)\" | sudo tee /etc/sudoers.d/cntools"
      return 1
    fi
    rm -f "${TMP_DIR}"/test
  fi
  return 0
}

# Command     : safeDel [path]
# Description : unlock and use secure delete (srm) if available to delete file|dir
# Note        : srm mainly effective for traditional magnetic HDDs and non copy-on-write or journal file systems
# Parameters  : command  >  The command to check
safeDel() {
  path=$1
  [[ ${ENABLE_CHATTR} = true && -f "${path}" && $(lsattr -R "${path}") =~ -i- ]] && sudo chattr -i "${path}"
  command -v "srm" &>/dev/null && delcommand='srm' || delcommand='rm'
  if "${delcommand}" -rf "${path}"; then
    println "Deleted: ${path}"
  else
    println ERROR "${FG_RED}ERROR${NC}: delete failed for ${path}"
    return 1
  fi
  return 0
}

updateProtocolParams() {
  _epoch_=$(getEpoch)
  [[ -n ${current_epoch} && ${current_epoch} -eq ${_epoch_} ]] && return
  current_epoch=${_epoch_}
  getProtocolParams
  case $? in
    1) myExit 1 "${FG_YELLOW}WARN${NC}: node socket path wrongly configured or node not running, please verify that socket set in env file match what is used to run the node\n\n${launch_modes_info}" ;;
    2) myExit 1 "${FG_YELLOW}WARN${NC}: failed to query protocol parameters, ensure your node is running with correct genesis (the node needs to be in sync to 1 epoch after the hardfork)\n\nError message: ${PROT_PARAMS}\n\n${launch_modes_info}" ;;
    3) myExit 1 "${FG_YELLOW}WARN${NC}: Unable to query Koios for current epoch parameters\n\n${launch_modes_info}" ;;
  esac
  echo "${PROT_PARAMS}" > "${TMP_DIR}"/protparams.json
}

# Command     : dialogSetup
# Description : set config parameters for dialog formatting
dialogSetup() {
  export DIALOGRC="${TMP_DIR}"/.dialogrc
  [[ ! -f ${DIALOGRC} ]] && cat <<-EOF > "${TMP_DIR}"/.dialogrc
		# Types of values:
		#
		# Number     -  <number>
		# String     -  "string"
		# Boolean    -  <ON|OFF>
		# Attribute  -  (foreground,background,highlight?)
		# Set aspect-ration.
		aspect = 0
		# Set separator (for multiple widgets output).
		separate_widget = ""
		# Set tab-length (for textbox tab-conversion).
		tab_len = 0
		# Make tab-traversal for checklist, etc., include the list.
		visit_items = OFF
		# Shadow dialog boxes? This also turns on color.
		use_shadow = OFF
		# Turn color support ON or OFF
		use_colors = OFF
		# Screen color
		screen_color = (BLACK,BLACK,OFF)
		# Shadow color
		shadow_color = (BLACK,BLACK,ON)
		# Dialog box color
		dialog_color = (BLACK,BLACK,OFF)
		# Dialog box title color
		title_color = (RED,BLACK,ON)
		# Dialog box border color
		border_color = (BLACK,BLACK,OFF)
		# Active button color
		button_active_color = (WHITE,BLACK,ON)
		# Inactive button color
		button_inactive_color = (BLACK,WHITE,OFF)
		# Active button key color
		button_key_active_color = button_active_color
		# Inactive button key color
		button_key_inactive_color = (RED,BLACK,OFF)
		# Active button label color
		button_label_active_color = (YELLOW,BLACK,OFF)
		# Inactive button label color
		button_label_inactive_color = (BLACK,WHITE,ON)
		# Input box color
		inputbox_color = button_inactive_color
		# Input box border color
		inputbox_border_color = button_inactive_color
		# Item color
		item_color = button_inactive_color
		# Selected item color
		item_selected_color = button_active_color
		# Dialog box border2 color
		border2_color = button_inactive_color
		# Input box border2 color
		inputbox_border2_color = button_inactive_color
		EOF
}

# Command     : fileDialog [title] [optional: start path]
# Description : open a file dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: ${TMP_DIR}/)
fileDialog() {
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    getAnswerAnyCust file "$1" && return
  else
    println DEBUG false "${1}: "
    waitToProceed "Press any key to open the file explorer [cancel to skip!]"
  fi
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="${TMP_DIR}/"
  dialog --clear --keep-tite --title "$1" --fselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)) 2>"${TMP_DIR}/dialog.out"
  file=$([[ -f "${TMP_DIR}/dialog.out" ]] && cat "${TMP_DIR}/dialog.out" || echo "")
  tput cup $(( ${ROW#*[} -1 )) $(( COL -1 ))
  println DEBUG "${FG_LGRAY}${file}${NC}"
}
# Command     : dirDialog [title] [optional: start dir]
# Description : open a directory dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: ${TMP_DIR}/)
dirDialog() {
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    getAnswerAnyCust dir "$1" && return
  else
    println DEBUG false "${1}: "
    waitToProceed "Press any key to open the file explorer [cancel to skip!]"
  fi
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="${TMP_DIR}/"
  dialog --clear --keep-tite --title "$1" --dselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)) 2>"${TMP_DIR}/dialog.out"
  dir=$([[ -f "${TMP_DIR}/dialog.out" ]] && cat "${TMP_DIR}/dialog.out" || echo "")
  tput cup $(( ${ROW#*[} -1 )) $(( COL -1 ))
  println DEBUG "${FG_LGRAY}${dir}${NC}"
}


# Command     : selectOption [opt1] [opt2] ...
# Description : Create a bash menu to select one of the provided options
# Parameters  : optX  >  a list of available options to choose from
ESC=$(printf "\033")
cursor_blink_on()  { printf "${ESC}[?25h"; }
cursor_blink_off() { printf "${ESC}[?25l"; }
cursor_to()        { printf "${ESC}[$1;${2:-1}H"; }
print_option()     { printf "  $1 "; }
print_selected()   { printf " ${ESC}[7m $1 ${ESC}[27m$2"; }
get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
key_input()        { key2=""
                     read -rsn1 key1   # get 1 character
                     if [[ $key1 == "${ESC}" ]]; then
                       read -rsn2 -t 0.3 key2 # read 2 more chars, 1s timeout
                     fi
                       if [[ ${key2} = "[A" ]]; then echo up;
                     elif [[ ${key2} = "[B" ]]; then echo down;
                     elif [[ ${key1} = "${ESC}" && ${key2} = "" ]]; then echo Esc;
                     elif [[ ${key1} = ""   ]]; then echo enter;
                     else echo ${key1}; fi; }
opt_shortcut()     { [[ "$1" =~ ^\[([[:alnum:]]+)\].* ]] && echo ${BASH_REMATCH[1]}; }
opt_firstchar()    { printf "${1:0:1}" | tr '[:upper:]' '[:lower:]'; }
clrbuf()           { read -r -t 0.1 -s -e; stty echo echok; }
selectOption() {

  # initially print empty new lines (scroll down if at bottom of screen)
  printf "\n" && for opt; do printf "\n"; done

  # determine current screen position for overwriting the options or return -1 on failure
  clrbuf
  local startrow=-1
  for i in {1..10}; do
    local cursor_row=$(get_cursor_row)
    isNumber ${cursor_row} && startrow=$(( cursor_row - $# - 1 )) && break
  done
  [[ ${startrow} -eq -1 ]] && return 255

  cursor_blink_off

  local shortcut_found="no"
  local selected=0
  while true; do
    # print options by overwriting the last lines
    local idx=0
    for opt; do
      opt_part2=""
      if [[ "$opt" =~ ^(.*)[[:space:]](\(.*) ]]; then
        opt_part1="${BASH_REMATCH[1]}"
        opt_part2=" ${BASH_REMATCH[2]}"
      else
        opt_part1="$opt"
      fi
      cursor_to $(( startrow + idx ))
      if [ ${idx} -eq ${selected} ]; then
        print_selected "${opt_part1}" "${opt_part2}"
      else
        print_option "${opt_part1}${opt_part2}"
      fi
      ((idx++))
    done

    [[ "${shortcut_found}" = "yes" ]] && break

    # user key control
    key_pressed=$(key_input)
    case ${key_pressed} in
      enter) break;;
      up)    ((selected--));
             if [ ${selected} -lt 0 ]; then selected=$(($# - 1)); fi;;
      down)  ((selected++));
             if [ ${selected} -ge $# ]; then selected=0; fi;;
      *)     # shortcut available for selected key?
             i=0
             for opt; do
               [[ ${key_pressed} = $(opt_shortcut "${opt}") ]] && selected=${i} && shortcut_found="yes" && break
               ((i++))
             done
             # If no shortcut is found, lets see if it matches the first char of any of the options
             j=0
             for opt; do
               [[ "${shortcut_found}" != "yes" && ${key_pressed} = $(opt_firstchar "${opt}") ]] && selected=${j} && break
               ((j++))
             done
             ;;
    esac
  done

  # clear menu
  cursor_blink_on
  cursor_to $startrow
  tput ed
  
  return $selected
}

# Command     : select_opt [opt1] [opt2] ...
# Description : Helper function to selectOption
# Parameters  : optX  >  a list of available options to choose from
select_opt() {
  local opts=()
  for item in "$@"; do
    [[ -n ${item} ]] && opts+=("${item}")
  done
  selectOption "${opts[@]}"
  local answer=$?
  if [[ ${answer} -eq 255 ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Failed to print menu, default selection used!\n"
    return 0
  fi
  selected_value="${opts[${answer}]}"
  println DEBUG "Selected value: ${selected_value}"
  return $answer
}

# Command     : getDirs [path to folder]
# Description : A helper function to get all subdirs for a directory
# Parameters  : path to folder    >   full path to folder, subdirs of this folder returned
# Return      : populates ${dirs} array
getDirs() {
  if [[ ! -d "$1" ]]; then
    println ERROR "${FG_RED}ERROR${NC}: Missing folder: $1"
    waitToProceed && return 1
  fi
  dirs=()
  while IFS= read -r -d '' dir; do
    dirs+=("$(basename ${dir})")
  done < <(find "${1}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
  return 0
}

# Command     : selectDir [type] [dir1 dir2 ...]
# Description : A helper function to selectOption() specifically for directory selection
# Parameters  : type  >  'wallet' 'pool' 'policy' 'asset'
#             : dirX  >  array of dirs to include in selection, '[Esc] Cancel' option added to all selections
# Return      : populates ${dir_name} variable
selectDir() {
  local type=$1 && shift
  dirs=( "$@" )
  dirs+=("[Esc] Cancel")
  selectOption "${dirs[@]}"
  local answer=$?
  if [[ ${answer} -eq 255 ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Failed to print menu, please try again or report issue!"
    return 1
  fi
  dir_name=${dirs[${answer}]}
  [[ "${dir_name}" = "[Esc] Cancel" ]] && return 2
  println DEBUG "Selected ${type}: ${dir_name}"
}

# Command     : selectWallet [mode] [file1 file2 ... | wallet_name1 wallet_name1 ... ]
# Description : A helper function to select a CNTools wallet
# Parameters  : mode       >  a string containing some of the following: none|encrypted|non-reg|reg|balance|delegate|reward|assets to be added next to wallet in selection menu
#             : arg array  >  array of files required to exist in wallet folder for it to be selectable **OR** the name of wallet to exclude from selection
# Return      : populates ${wallet_name} variable with wallet selection
selectWallet() {

  mode=$1 && shift

  if [[ ${mode} = "cache" && ${#wallet_dirs_filtered[@]} -gt 0 ]]; then
    selectDir "wallet" "${wallet_dirs_filtered[@]}" || return $? # ${dir_name} populated by selectDir function
    wallet_name="$(echo ${dir_name} | cut -d' ' -f1)"
    return 0
  fi

  wallet_dirs=()

  if ! getDirs "${WALLET_FOLDER}"; then return 1; fi # dirs() array populated with all wallet folders
  if [[ ${CNTOOLS_MODE} != "OFFLINE" && ${mode} != "none" ]]; then
    tput sc
    wallet_count=${#dirs[@]}
    if [[ ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then
      if [[ -n ${KOIOS_API} ]]; then
        println OFF "${FG_YELLOW}> Querying Koios API for wallet balance${NC}"
      else
        println OFF "${FG_YELLOW}> Querying node for wallet balance${NC}"
      fi
    else
      println OFF "${FG_YELLOW}> Max wallet count exceeded for balance/filtering (${wallet_count}/${WALLET_SELECTION_FILTER_LIMIT}).\nUpdate 'WALLET_SELECTION_FILTER_LIMIT' setting to increase this limit${NC}"
    fi
  fi

  unset reward_status
  addr_list=()
  reward_addr_list=()
  declare -gA asset_cnt=()
  declare -gA balances=()
  declare -gA reward_pool=()
  declare -gA rewards_available=()

  for dir in "${dirs[@]}"; do
    for arg in "$@"; do # check if wallet is missing a required file or name matches execution, if so hide it
      [[ ${arg} == *"."* && ! -f "${WALLET_FOLDER}/${dir}/${arg}" ]] && continue 2
      [[ ${arg} != *"."* && ${dir} = "${arg}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${WALLET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        wallet_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        wallet_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
    elif [[ ${CNTOOLS_MODE} != "OFFLINE" && ${mode} != "none" && ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then
      if [[ ${mode} = "reg" || ${mode} = "non-reg" ]]; then
        if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
          if [[ ${mode} = "reg" ]]; then
            ! isWalletRegistered ${dir} && continue
          else
            isWalletRegistered ${dir} && continue
          fi
        else
          getRewardAddress ${dir}
          [[ -n ${reward_addr} ]] && reward_addr_list+=(${reward_addr})
        fi
      fi
      if [[ ${mode} = "balance" || ${mode} = "non-reg" || ${mode} = "reg" ]]; then
        getBaseAddress ${dir}
        getPayAddress ${dir}
        [[ -z ${base_addr} || -z ${pay_addr} ]] && wallet_dirs+=("${dir}") && continue # ignore and add wallet without extra details
        addr_list+=(${base_addr} ${pay_addr})
        if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
          getBalance ${base_addr}
          balances["${base_addr}"]=${assets[lovelace]}
          [[ ${#assets[@]} -gt 1 ]] && asset_cnt["${base_addr}"]="$((${#assets[@]}-1))"
          getBalance ${pay_addr}
          balances["${pay_addr}"]=${assets[lovelace]}
          [[ ${#assets[@]} -gt 1 ]] && asset_cnt["${pay_addr}"]="$((${#assets[@]}-1))"
        fi
        wallet_dirs+=("${dir}_balance_")
      elif [[ ${mode} = "delegate" ]]; then
        getBaseAddress ${dir}
        [[ -z ${base_addr} ]] && wallet_dirs+=("${dir}") && continue # ignore and add wallet without extra details
        addr_list+=(${base_addr})
        getRewardAddress ${dir}
        if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
          getBalance ${base_addr}
          balances["${base_addr}"]=${assets[lovelace]}
          if [[ -n ${reward_addr} ]]; then
            delegation_pool_id=$(${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address "${reward_addr}" | jq -r '.[0].delegation // empty')
            [[ -n ${delegation_pool_id} ]] && reward_pool[${reward_addr}]=${delegation_pool_id}
          fi
        else
           [[ -n ${reward_addr} ]] && reward_addr_list+=(${reward_addr})
        fi
        wallet_dirs+=("${dir}_balance_")
      elif [[ ${mode} = "reward" ]]; then
        if [[ -n ${KOIOS_API} ]]; then
          getRewardAddress ${dir}
          [[ -n ${reward_addr} ]] && reward_addr_list+=(${reward_addr})
        else
          getWalletRewards ${dir}
          [[ ${reward_lovelace} -eq 0 ]] && continue
          rewards_available[${reward_addr}]=${reward_lovelace}
        fi
        wallet_dirs+=("${dir}_balance_")
      fi
    else
      wallet_dirs+=("${dir}")
    fi
  done

  if [[ -n ${KOIOS_API} ]]; then
    if [[ ${#addr_list[@]} -gt 0 ]]; then
      getBalanceKoios false
      for key in ${!assets[@]}; do
        if [[ ${key} = *lovelace ]]; then
          _address=${key%,*}
          balances[${_address}]=${assets[${key}]}
        fi
      done
    fi
    [[ ${#reward_addr_list[@]} -gt 0 ]] && getRewardInfoKoios
  fi

  wallet_dirs_filtered=()

  for dir in "${wallet_dirs[@]}"; do
    if [[ ${dir} = *_balance_ ]]; then
      wallet_dir=${dir%%_balance_}
      unset base_addr
      getBaseAddress ${wallet_dir}
      base_lovelace=${balances[${base_addr}]:-0}
      if [[ ${mode} = "reg" || ${mode} = "non-reg" ]]; then
        getRewardAddress ${wallet_dir}
        if [[ -n ${reward_addr} ]]; then
          if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
            if [[ ${mode} = "reg" ]]; then
              if [[ ! -v reward_status[${reward_addr}] || ${reward_status[${reward_addr}]} != "registered" ]]; then continue; fi
            else
              [[ -v reward_status[${reward_addr}] && ${reward_status[${reward_addr}]} = "registered" ]] && continue
            fi
          fi
        fi
      elif [[ ${mode} = "delegate" ]]; then
        getRewardAddress ${wallet_dir}
        if [[ -n ${reward_addr} ]]; then
          delegation_pool_id=${reward_pool[${reward_addr}]}
          unset poolName
          if [[ -n ${delegation_pool_id} ]]; then
            while IFS= read -r -d '' pool; do
              getPoolID "$(basename ${pool})"
              if [[ "${pool_id_bech32}" = "${delegation_pool_id}" ]]; then
                poolName=$(basename ${pool}) && break
              fi
            done < <(find "${POOL_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
          fi
          if [[ -n ${poolName} ]]; then
            wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA - ${FG_RED}delegated${NC} to ${FG_GREEN}${poolName}${NC})")
          elif [[ -n ${delegation_pool_id} ]]; then
            wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA - ${FG_RED}delegated${NC} to ${FG_LGRAY}${delegation_pool_id:0:6}...${delegation_pool_id: -6}${NC})")
          else
            wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA)")
          fi
        else
          wallet_dirs_filtered+=("${wallet_dir} (${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA)")
        fi
        continue
      elif [[ ${mode} = "reward" ]]; then
        getRewardAddress ${wallet_dir}
        if [[ -n ${reward_addr} && -v rewards_available[${reward_addr}] && ${rewards_available[${reward_addr}]} -gt 0 ]]; then
          wallet_dirs_filtered+=("${wallet_dir} (Rewards: ${FG_LBLUE}$(formatLovelace ${rewards_available[${reward_addr}]})${NC} ADA)")
        fi
        continue
      fi
      getPayAddress ${wallet_dir}
      pay_lovelace=${balances[${pay_addr}]:-0}
      [[ -v asset_cnt[${base_addr}] ]] && base_asset_str=" + ${FG_LBLUE}${asset_cnt[${base_addr}]}${NC} additional assets" || unset base_asset_str
      [[ -v asset_cnt[${pay_addr}] ]] && pay_asset_str=" + ${FG_LBLUE}${asset_cnt[${pay_addr}]}${NC} additional assets" || unset pay_asset_str
      if [[ ${base_lovelace} -gt 0 && ${pay_lovelace} -gt 0 ]]; then
        wallet_dirs_filtered+=("${wallet_dir} (Funds: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA${base_asset_str} | Enterprise Funds: ${FG_LBLUE}$(formatLovelace ${pay_lovelace})${NC} ADA${pay_asset_str})")
      elif [[ ${pay_lovelace} -gt 0 ]]; then
        wallet_dirs_filtered+=("${wallet_dir} (Enterprise Funds: ${FG_LBLUE}$(formatLovelace ${pay_lovelace})${NC} ADA${pay_asset_str})")
      else
        wallet_dirs_filtered+=("${wallet_dir} (Funds: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA${base_asset_str})")
      fi
    else
      wallet_dirs_filtered+=("${dir}")
    fi
  done

  if [[ ${CNTOOLS_MODE} != "OFFLINE" && ${mode} != "none" && ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then tput rc && tput ed; fi
  if [[ ${#wallet_dirs_filtered[@]} -eq 0 ]]; then
    if [[ ${mode} = "balance" ]]; then
      println ERROR "\n${FG_YELLOW}WARN${NC}: No wallets with funds available for selection! Required files:\n$(printf '%b\n' "$@")"
    elif [[ ${mode} = "delegate" ]]; then
      println ERROR "\n${FG_YELLOW}WARN${NC}: No wallets available that can be delegated or used as pool pledge/owner/reward wallet! Required files:\n$(printf '%b\n' "$@")"
    elif [[ ${mode} = "reward" ]]; then
      println ERROR "\n${FG_YELLOW}WARN${NC}: No wallets available that have rewards to withdraw or signing keys to do so!"
    elif [[ ${mode} = "reg" ]]; then
      println ERROR "\n${FG_YELLOW}WARN${NC}: No wallets available that are registered on chain!"
    elif [[ ${mode} = "non-reg" ]]; then
      println ERROR "\n${FG_YELLOW}WARN${NC}: No wallets available that are unregistered!"
    else
      println ERROR "\n${FG_YELLOW}WARN${NC}: No wallets available for selection! Required files:\n$(printf '%b\n' "$@")"
    fi
    return 1
  fi

  selectDir "wallet" "${wallet_dirs_filtered[@]}" || return $? # ${dir_name} populated by selectDir function
  wallet_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : selectPool [mode] [file1 file2 ...]
# Description : A helper function to select a CNTools pool
# Parameters  : mode   >  a string containing some of the following: reg|non-reg|encrypted
#             : fileX  >  array of files required to exist in pool folder for it to be selectable
# Return      : populates ${pool_name} variable with pool selection
selectPool() {
  pool_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${POOL_FOLDER}"; then return 1; fi # dirs() array populated with all pool folders
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if pool is missing a required file and if so hide it
      [[ -f "${POOL_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${POOL_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${POOL_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        pool_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        pool_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
      continue
    elif [[ ${mode} = "non-reg" || ${mode} = "reg" ]]; then
      isPoolRegistered "${dir}"
      case $? in
        0) println "ERROR" "KOIOS_API: ${error_msg}" &>/dev/null ;; # log error without printing but show pool
        1) [[ ${mode} = "reg" ]] && continue ;;
        2) [[ ${mode} = "non-reg" ]] && continue ;;
        3) [[ ${mode} = "non-reg" ]] && continue ;;
        4) [[ ${mode} = "reg" ]] && continue ;;
      esac
    fi
    pool_dirs+=("${dir}")
  done
  if [[ ${#pool_dirs[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No pools available that can be selected! Required files:\n$(printf '%b\n' "$@")"
    [[ ${enc_req_files} -gt 0 ]] && println DEBUG "\n${FG_YELLOW}* Encrypted pools found but not listed *${NC}"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && println DEBUG "${FG_YELLOW}encrypted pools found but NOT listed, please decrypt to show${NC}"
  selectDir "pool" "${pool_dirs[@]}" || return $? # ${dir_name} populated by selectDir function
  pool_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : isPoolRegistered [pool_name]
# Description : check if pool is registered on chain
#               existence of POOL_REGCERT_FILENAME checked when KOIOS API is not available
# Parameters  : pool_name   >  the name of the pool to check
# Return      : 0 => error quering KOIOS API (error message saved in ${error_msg})
#               1 => NOT registered
#               2 => registered
#               3 => retiring (only for KOIOS API)
#               4 => retired (only for KOIOS API)
isPoolRegistered() {
  unset error_msg pool_info pool_info_tsv pool_info_arr
  unset p_active_epoch_no p_vrf_key_hash p_margin p_fixed_cost p_pledge p_reward_addr p_owners p_relays p_meta_url p_meta_hash p_meta_json p_pool_status
  unset p_retiring_epoch p_op_cert p_op_cert_counter p_active_stake p_epoch_block_cnt p_live_stake p_live_delegators p_live_saturation
  if [[ ${CNTOOLS_MODE} != "LIGHT" ]]; then
    [[ -f "${POOL_FOLDER}/${1}/${POOL_REGCERT_FILENAME}" ]] && return 2 || return 1
  else
    getPoolID "$1"
    println ACTION "curl -sSL -f -X POST -H \"Content-Type: application/json\" -d '{\"_pool_bech32_ids\":[\"${pool_id_bech32}\"]}' ${KOIOS_API}/pool_info"
    ! pool_info=$(curl -sSL -f -X POST -H "Content-Type: application/json" -d '{"_pool_bech32_ids":["'${pool_id_bech32}'"]}' "${KOIOS_API}/pool_info" 2>&1) && error_msg=${pool_info} && return 0
    if [[ ${pool_info} = '[]' ]]; then
      return 1
    fi
    pool_info_tsv=$(jq -r '[
    .[0].active_epoch_no //0,
    .[0].vrf_key_hash //"-",
    .[0].margin //0,
    .[0].fixed_cost //0,
    .[0].pledge //0,
    .[0].reward_addr //"-",
    (.[0].owners|@json),
    (.[0].relays|@json),
    .[0].meta_url //"-",
    .[0].meta_hash //"-",
    (.[0].meta_json|@base64),
    .[0].pool_status //"-",
    .[0].retiring_epoch //"-",
    .[0].op_cert //"-",
    .[0].op_cert_counter //"null",
    .[0].active_stake //0,
    .[0].block_count //0,
    .[0].live_pledge //0,
    .[0].live_stake //0,
    .[0].live_delegators //0,
    .[0].live_saturation //0
    ] | @tsv' <<< "${pool_info}")

    read -ra pool_info_arr <<< ${pool_info_tsv}

    p_active_epoch_no=${pool_info_arr[0]}
    p_vrf_key_hash=${pool_info_arr[1]}
    p_margin=${pool_info_arr[2]}
    p_fixed_cost=${pool_info_arr[3]}
    p_pledge=${pool_info_arr[4]}
    p_reward_addr=${pool_info_arr[5]}
    p_owners=${pool_info_arr[6]}
    p_relays=${pool_info_arr[7]}
    p_meta_url=${pool_info_arr[8]}
    p_meta_hash=${pool_info_arr[9]}
    p_meta_json=$(base64 -d <<< ${pool_info_arr[10]})
    p_pool_status=${pool_info_arr[11]}
    p_retiring_epoch=${pool_info_arr[12]}
    p_op_cert=${pool_info_arr[13]}
    p_op_cert_counter=${pool_info_arr[14]}
    p_active_stake=${pool_info_arr[15]}
    p_block_count=${pool_info_arr[16]}
    p_live_pledge=${pool_info_arr[17]}
    p_live_stake=${pool_info_arr[18]}
    p_live_delegators=${pool_info_arr[19]}
    p_live_saturation=${pool_info_arr[20]}

    [[ ${p_pool_status} = 'registered' ]] && return 2
    [[ ${p_pool_status} = 'retiring' ]] && return 3 || return 4
  fi
}

# Command     : getAssetInfo [policy_id] [asset_name_hex]
# Description : Query Koios for asset information.
# Return      : 0: data saved in asset_<koios_field>
#               1: on error ($error_msg contains error message)
#               2: offline/disabled/no result
getAssetInfo() {
  unset
  if [[ ${CNTOOLS_MODE} != "LIGHT" || $# -lt 1 ]]; then
    return 2
  else
    println ACTION "curl -sSL -f -d _asset_policy=$1 -d _asset_name=$2  ${KOIOS_API}/asset_info"
    ! asset_info=$(curl -sSL -f -d _asset_policy=$1 -d _asset_name=$2 "${KOIOS_API}/asset_info" 2>&1) && error_msg="${asset_info}" && return 1
    if [[ ${asset_info} = '[]' ]]; then
      return 2
    fi
    asset_info_tsv=$(jq -r '[
    (.[0].asset_name_ascii //"-" | @base64),
    .[0].fingerprint //"-",
    .[0].minting_tx_hash //"-",
    .[0].total_supply //0,
    .[0].mint_cnt //0,
    .[0].burn_cnt //0,
    .[0].creation_time //0,
    (.[0].minting_tx_metadata //"-" | @base64),
    (.[0].token_registry_metadata //"-" | @base64)
    ] | @tsv' <<< "${asset_info}")

    read -ra asset_info_arr <<< ${asset_info_tsv}

    a_asset_name_ascii=$(base64 -d <<< ${asset_info_arr[0]})
    a_fingerprint=${asset_info_arr[1]}
    a_minting_tx_hash=${asset_info_arr[2]}
    a_total_supply=${asset_info_arr[3]}
    a_mint_cnt=${asset_info_arr[4]}
    a_burn_cnt=${asset_info_arr[5]}
    a_creation_time=${asset_info_arr[6]}
    a_minting_tx_metadata=$(base64 -d <<< ${asset_info_arr[7]})
    a_token_registry_metadata=$(base64 -d <<< ${asset_info_arr[8]})
  fi
}

# Command     : selectPolicy [mode] [file1 file2 ...]
# Description : A helper function to select a Multi-Asset policy
# Parameters  : fileX  >  array of files required to exist in policy folder for it to be selectable
# Return      : populates ${policy_name} variable with selected policy
selectPolicy() {
  policy_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${ASSET_FOLDER}"; then return 1; fi
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if policy folder contain required files
      [[ -f "${ASSET_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${ASSET_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        policy_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        policy_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
      continue
    fi
    policy_dirs+=("${dir}")
  done
  if [[ ${#policy_dirs[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No policies available that can be selected! Required files:\n$(printf '%b\n' "$@")"
    [[ ${enc_req_files} -gt 0 ]] && println DEBUG "\n${FG_YELLOW}* Encrypted policies found but not listed *${NC}"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && println DEBUG "${FG_YELLOW}encrypted policies found but NOT listed, please decrypt to show${NC}"
  selectDir "policy" "${policy_dirs[@]}" || return $? # ${dir_name} populated by selectDir function
  policy_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : selectAsset
# Description : A helper function to select a Multi-Asset minted on device
# Return      : populates ${policy_dir}, ${asset_name} & ${asset_file} variables
selectAsset() {
  asset_list=() # <policy_id>.<asset_name>
  if ! getDirs "${ASSET_FOLDER}"; then return 1; fi
  for dir in "${dirs[@]}"; do
    if [[ $(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.asset' -print0 | wc -c) -gt 0 ]]; then
      while IFS= read -r -d '' asset; do
        asset_file=${asset##*/}
        asset_list+=("${dir}/${asset_file%%.*}")
      done < <(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.asset' -print0 | sort -z)
    fi
  done
  if [[ ${#asset_list[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No assets found on disk!"
    return 1
  fi
  selectDir "asset" "${asset_list[@]}" || return $? # ${dir_name} populated by selected value
  policy_dir="${dir_name%%/*}"
  asset_name="${dir_name##*/}"
  asset_file="${ASSET_FOLDER}/${policy_dir}/${asset_name}.asset"
}

# Command     : getPasswordCust [optional: confirm]
# Description : Get password from user on STDIN
# Parameters  : confirm  >  [optional] force user to provide password twice for confirmation
# Return      : populates ${password} variable, make sure to unset variable when done
getPasswordCust() {
  getPassword 8 $1
  return_code=$?
  return ${return_code}
}

# Command     : encryptFile [file] [password]
# Description : Encrypt file with GPG
# Parameters  : file      >  Path for file to encrypt, will get a new .gpg file extention added to filename
#             : password  >  Password to encrypt file with
encryptFile() {
  echo "${2}" | gpg --symmetric --yes --batch --cipher-algo AES256 --passphrase-fd 0 --output "${1}.gpg" "${1}" &>/dev/null && \
  safeDel "${1}" >/dev/null || {
    println ERROR "${FG_RED}ERROR${NC}: failed to encrypt ${1}"
    return 1
  }
  println DEBUG "${1} successfully encrypted"
}


# Command     : decryptFile [file] [password]
# Description : Decrypt file with GPG
# Parameters  : file      >  Path for file to decrypt, file extension .gpg required
#             : password  >  Password to decrypt file with
decryptFile() {
  echo "${2}" | gpg --decrypt --batch --yes --passphrase-fd 0 --output "${1%.*}" "${1}" &>/dev/null && \
  rm -f "${1}" || {
    println ERROR "${FG_RED}ERROR${NC}: failed to decrypt ${1}"
    return 1
  }
  println DEBUG "${1} successfully decrypted"
}

# Command     : unlockFile [file]
# Description : Unlock/remove write protection from file
# Parameters  : file      >  Path for file to unlock
unlockFile() {
  if [[ ${ENABLE_CHATTR} = true && $(lsattr -R "$1") =~ -i- ]]; then
    sudo chattr -i "${1}"
  fi
  chmod 600 "${1}"
}

# Command     : lockFile [file]
# Description : Lock/write protect file with chattr if enabled and Linux file permissions
# Parameters  : file      >  Path for file to lock
lockFile() {
  chmod 400 "$1"
  if [[ ${ENABLE_CHATTR} = true && ! $(lsattr -R "$1") =~ -i- ]]; then
    sudo chattr +i "$1"
  fi
}

# Command     : waitNewBlockCreated [optional: silent]
# Description : Wait for a new block to be created
# Parameters  : silent  >  any argument to function will prevent DEBUG output to tty
waitNewBlockCreated() {
  counter=${TIMEOUT_NO_OF_SLOTS}
  [[ $# -eq 0 ]] && println DEBUG "Waiting for new block to be created (timeout = ${counter} slots, $(( counter * SLOT_LENGTH ))s)"
  [[ $# -eq 0 ]] && println DEBUG "${FG_BLUE}INFO${NC}: press any key to cancel and return (won't stop transaction)"
  getNodeMetrics
  initialTip=${slotnum}
  actualTip=${slotnum}

  while [[ ${actualTip} -eq ${initialTip} ]]; do
    read -r -n 1 -s -t 5 abort
    if [[ $? -eq 0 ]]; then
      println "${FG_YELLOW}WARN${NC}: aborted!! transaction still in queue!"
      return 1
    fi
    getNodeMetrics
    actualTip=${slotnum}
    counter=$((counter - SLOT_LENGTH))
    if [ ${counter} -lt ${SLOT_LENGTH} ]; then
      println "${FG_YELLOW}WARN${NC}: waited $(( TIMEOUT_NO_OF_SLOTS * SLOT_LENGTH )) secs and no new block created"
      return 1
    fi
  done
  println LOG "New block was created - ${actualTip}"
}

# Command     : verifyTx [address]
# Description : Verify that the transaction was successfully registered by checking address balance against $newBalance
# Parameters  : address  >  the address to compare with
verifyTx() {
  if [[ -n ${KOIOS_API} && -n ${tx_id} ]]; then
    println DEBUG "Waiting for transaction to be seen on chain"
    println DEBUG "Id: ${tx_id}"
    println DEBUG "${FG_BLUE}INFO${NC}: press any key to cancel and return (won't stop transaction)"
    while :; do
      read -r -n 1 -s -t 5 abort
      if [[ $? -eq 0 ]]; then
        println "\n${FG_YELLOW}WARN${NC}: aborted!! transaction still in queue!"
        return 1
      fi
      println ACTION "curl -sSL -f -X POST -H \"Content-Type: application/json\" -H \"accept: text/csv\" -d '{\"_tx_hashes\":[\"${tx_id}\"]' ${KOIOS_API}/tx_status?select=num_confirmations"
      ! num_confirmations=$(curl -sSL -f -X POST -H "Content-Type: application/json" -H "accept: text/csv" -d '{"_tx_hashes":["'${tx_id}'"]}' "${KOIOS_API}/tx_status?select=num_confirmations" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${num_confirmations}\n" && return 1 # print error and return
      num_confirmations=$(tail -n +2 <<< ${num_confirmations})
      [[ -n "${num_confirmations}" ]] && { println DEBUG "\nTx put on chain !!"; break; } || printf .
    done
  else
    if ! waitNewBlockCreated; then return 1; fi
    getAddressBalance ${1} true
    while [[ ${lovelace} -ne ${newBalance} ]]; do
      println DEBUG "${FG_YELLOW}WARN${NC}: Balance mismatch, transaction not included in latest block... waiting for next block!"
      println LOG "$(formatLovelace ${lovelace}) != $(formatLovelace ${newBalance})"
      if ! waitNewBlockCreated "silent"; then return 1; fi
      getAddressBalance ${1} true
    done
    return 0
  fi
}

# Command     : getPayAddress [wallet name]
# Description : create and save payment address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${pay_addr}
getPayAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_addr_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_ADDR_FILENAME}"
  [[ -f ${payment_addr_file} ]] && pay_addr=$(cat "${payment_addr_file}") && return 0
  pay_addr=""
  if [[ -f "${payment_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file ${payment_vk_file} --out-file ${payment_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      pay_addr=$(cat "${payment_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during payment address creation!\n${stdout}"
    fi
  fi
  return 1
}

# Command     : getBaseAddress [wallet name] | [payment.vkey] [stake.vkey]
# Description : create, store and save base address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${base_addr}
getBaseAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_script_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  base_addr_file="${WALLET_FOLDER}/${1}/${WALLET_BASE_ADDR_FILENAME}"
  [[ -f ${base_addr_file} ]] && base_addr=$(cat "${base_addr_file}") && return 0
  base_addr=""
  if [[ -f "${payment_vk_file}" && -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file ${payment_vk_file} --stake-verification-key-file ${stake_vk_file} --out-file ${base_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file "${payment_vk_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      base_addr=$(cat "${base_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${stdout}"
    fi
  elif [[ -f "${payment_script_file}" && -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-script-file ${payment_script_file} --stake-verification-key-file ${stake_vk_file} --out-file ${base_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-script-file "${payment_script_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      base_addr=$(cat "${base_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${stdout}"
    fi
  elif [[ $# -eq 2 && -f "${1}" && -f "${2}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file ${1} --stake-verification-key-file ${2} ${NETWORK_IDENTIFIER}"
    if base_addr=$(${CCLI} ${NETWORK_ERA} address build --payment-verification-key-file "${1}" --stake-verification-key-file "${2}" ${NETWORK_IDENTIFIER} 2>&1); then
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during base address creation!\n${base_addr}"
    fi
  fi
  return 1
}

# Command     : getRewardAddress [wallet name]
# Description : create, store and save reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_addr}
getRewardAddress() {
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_addr_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_ADDR_FILENAME}"
  [[ -f ${stake_addr_file} ]] && reward_addr=$(cat "${stake_addr_file}") && return 0
  reward_addr=""
  if [[ -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file ${stake_vk_file} --out-file ${stake_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      reward_addr=$(cat "${stake_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during reward address creation!\n${stdout}"
    fi
  elif [[ -f "${1}" ]]; then
    getRewardAddressFromKey ${1}
    return $?
  fi
  return 1
}

# Command     : getRewardAddressFromKey [stake vkey]
# Description : get reward address from a stake key
# Parameters  : stake key  >  path to stake.vkey file
# Return      : populates ${reward_addr}
getRewardAddressFromKey() {
  println ACTION "${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file ${1} ${NETWORK_IDENTIFIER}"
  if ! reward_addr=$(${CCLI} ${NETWORK_ERA} stake-address build --stake-verification-key-file "${1}" ${NETWORK_IDENTIFIER} 2>&1); then
    println LOG "\n${FG_RED}ERROR${NC}: failure during reward address creation!\n${base_addr}"
    return 1
  fi
}

# Command     : getPayScriptAddress [wallet name]
# Description : create, store and save multi-sig payment script address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${pay_script_addr}
getPayScriptAddress() {
  payment_script_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}"
  payment_script_addr_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_ADDR_FILENAME}"
  [[ -f ${payment_script_addr_file} ]] && pay_script_addr=$(cat "${payment_script_addr_file}") && return 0
  unset pay_script_addr
  if [[ -f "${payment_script_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address build --payment-script-file ${payment_script_file} --out-file ${payment_script_addr_file} ${NETWORK_IDENTIFIER}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address build --payment-script-file "${payment_script_file}" --out-file "${payment_script_addr_file}" ${NETWORK_IDENTIFIER} 2>&1); then
      pay_script_addr=$(cat "${payment_script_addr_file}")
      return 0
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during payment script address creation!\n${stdout}"
    fi
  fi
  return 1
}

# Command     : getCredentials [wallet name]
# Description : create and save wallet credentials (key hash) for payment and stake keys
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${pay_cred} & ${stake_cred}
getCredentials() {
  payment_cred_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_CRED_FILENAME}"
  stake_cred_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_CRED_FILENAME}"
  [[ -f ${payment_cred_file} && -f ${stake_cred_file} ]] && pay_cred=$(cat "${payment_cred_file}") && stake_cred=$(cat "${stake_cred_file}") && return 0
  unset pay_cred stake_cred
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  if [[ -f "${payment_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} address key-hash --payment-verification-key-file ${payment_vk_file} --out-file ${payment_cred_file}"
    if stdout=$(${CCLI} ${NETWORK_ERA} address key-hash --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_cred_file}" 2>&1); then
      pay_cred=$(cat "${payment_cred_file}")
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during payment key hash creation!\n${stdout}"
      return 1
    fi
  fi
  if [[ -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} stake-address key-hash --stake-verification-key-file ${stake_vk_file} --out-file ${stake_cred_file}"
    if stdout=$(${CCLI} ${NETWORK_ERA} stake-address key-hash --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_cred_file}" 2>&1); then
      stake_cred=$(cat "${stake_cred_file}")
    else
      println LOG "\n${FG_RED}ERROR${NC}: failure during stake key hash creation!\n${stdout}"
      return 1
    fi
  fi
}

# Command     : getAddressInfo [address]
# Description : get address info from from node
# Parameters  : address  >  the wallet address to query
# Return      : populates ${address_info}
getAddressInfo() {
  println ACTION "${CCLI} ${NETWORK_ERA} address info --address $1"
  if ! address_info=$(${CCLI} ${NETWORK_ERA} address info --address $1 2>&1); then
    println LOG "\n${FG_RED}ERROR${NC}: failure during reward address creation!\n${base_addr}"
    return 1
  fi
}

# Command     : getBalance [address]
# Description : check balance for provided address
# Parameters  : address  >  the wallet address to query
getBalance() {
  declare -gA utxos=(); declare -gA assets=()
  assets["lovelace"]=0; utxo_cnt=0
  asset_name_maxlen=5; asset_amount_maxlen=12
  tx_in=""
  
  if [[ -z ${1} ]] || ! utxo_raw=$(${CCLI} ${NETWORK_ERA} query utxo ${NETWORK_IDENTIFIER} --address "${1}"); then return 1; fi
  [[ -z ${utxo_raw} ]] && return
  
  while IFS= read -r line; do
    IFS=' ' read -ra utxo_entry <<< "${line}"
    [[ ${#utxo_entry[@]} -lt 4 ]] && continue
    ((utxo_cnt++))
    tx_in+=" --tx-in ${utxo_entry[0]}#${utxo_entry[1]}"
    if [[ ${utxo_entry[3]} = "lovelace" ]]; then
      utxos["${utxo_entry[0]}#${utxo_entry[1]}. ADA"]=${utxo_entry[2]} # Space added before 'ADA' for sort to place it first
      assets["lovelace"]=$(( ${assets["lovelace"]:-0} + utxo_entry[2] ))
      idx=5
    else
      utxos["${utxo_entry[0]}#${utxo_entry[1]}. ADA"]=0 # Space added before 'ADA' for sort to place it first
      assets["lovelace"]=0
      idx=2
    fi
    if [[ ${#utxo_entry[@]} -gt "${idx}" ]]; then
      while [[ ${#utxo_entry[@]} -gt ${idx} ]]; do
        asset_amount=${utxo_entry[${idx}]}
        if ! isNumber "${asset_amount}"; then break; fi
        asset_hash_name="${utxo_entry[$((idx+1))]}"
        IFS='.' read -ra asset <<< "${asset_hash_name}"
        tname="$(hexToAscii ${asset[1]})"
        tname="${tname//[![:print:]]/}"
        [[ ${#asset[@]} -eq 2 && ${#tname} -gt ${asset_name_maxlen} ]] && asset_name_maxlen=${#tname}
        asset_amount_fmt="$(formatAsset ${asset_amount})"
        [[ ${#asset_amount_fmt} -gt ${asset_amount_maxlen} ]] && asset_amount_maxlen=${#asset_amount_fmt}
        assets["${asset_hash_name}"]=$(( ${assets["${asset_hash_name}"]:-0} + asset_amount ))
        utxos["${utxo_entry[0]}#${utxo_entry[1]}.${asset_hash_name}"]=${asset_amount}
        idx=$(( idx + 3 ))
      done
    fi
  done <<< "${utxo_raw}"

  [[ ${asset_name_maxlen} -ne 5 ]] && asset_name_maxlen=$(( asset_name_maxlen / 2 ))
  lovelace_fmt="$(formatLovelace ${assets["lovelace"]})"
  [[ ${#lovelace_fmt} -gt ${asset_amount_maxlen} ]] && asset_amount_maxlen=${#lovelace_fmt}
}

# Command     : getBalanceKoios parse_assets
# Description : check balance for provided addresses using Koios API
# Parameters  : parse_assets  >  [true|false] should additional assets on utxo be parsed or not (default=true)
getBalanceKoios() {
  # generate different arrays using key constructed in format: <address>,<additional fields...>
  # Ex: ( [addr123,lovelace]=1000 [addr456,policy.name]=500 )
  # Its assumed that an array called addr_list has been populated with all addresses to fetch balance for

  declare -gA utxos=(); declare -gA utxos_cnt=(); declare -gA assets=(); declare -gA tx_in_arr=(); declare -gA asset_name_maxlen_arr=(); declare -gA asset_amount_maxlen_arr=()

  if [[ -n ${KOIOS_API} && -n ${addr_list+x} ]]; then
    printf -v addr_list_joined '\"%s\",' "${addr_list[@]}"
    [[ $1 != false ]] && extended=true || extended=false
    println ACTION "curl -sSL -f -X POST -H \"Content-Type: application/json\" -H \"accept: text/csv\" -d '{\"_addresses\":[${addr_list_joined%,}],\"_extended\":${extended}}' ${KOIOS_API}/address_utxos?select=address,tx_hash,tx_index,value,asset_list"
    ! address_utxo_list=$(curl -sSL -f -X POST -H "Content-Type: application/json" -H "accept: text/csv" -d '{"_addresses":['${addr_list_joined%,}'],"_extended":'${extended}'}' "${KOIOS_API}/address_utxos?select=address,tx_hash,tx_index,value,asset_list" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${address_utxo_list}\n" && return 1 # print error and return
    [[ -z ${address_utxo_list} ]] && return
    while IFS=',' read -r _address _tx_hash _tx_index _value _asset_list; do
      [[ ${_address} = address ]] && continue # header line
      index_prefix="${_address},"
      assets["${index_prefix}lovelace"]=$(( ${assets["${index_prefix}lovelace"]:-0} + _value ))
      utxos["${index_prefix}${_tx_hash}#${_tx_index}. ADA"]=${_value}
      utxos_cnt["${_address}"]=$(( ${utxos_cnt["${_address}"]:-0} + 1 ))
      tx_in_arr["${_address}"]="${tx_in_arr["${_address}"]} --tx-in ${_tx_hash}#${_tx_index}"
      if [[ $1 != false ]]; then
        asset_list_unescaped=${_asset_list:1: -1} # remove first and last char (quotation)
        asset_list_unescaped=$(sed 's/""/"/g' <<< "${asset_list_unescaped}") # remove all double quotes, sed seems to perform better than bash string manipulation
        while IFS=',' read -r _policy_id _asset_name _quantity; do
          tname="$(hexToAscii ${_asset_name})"
          tname="${tname//[![:print:]]/}"
          [[ ${#tname} -gt ${asset_name_maxlen_arr["${_address}"]:-5} ]] && asset_name_maxlen_arr["${_address}"]=${#tname}
          asset_amount_fmt="$(formatAsset ${_quantity})"
          [[ ${#asset_amount_fmt} -gt ${asset_amount_maxlen_arr["${_address}"]:-12} ]] && asset_amount_maxlen_arr["${_address}"]=${#asset_amount_fmt}
          assets["${index_prefix}${_policy_id}.${_asset_name}"]=$(( ${assets["${index_prefix}${_policy_id}.${_asset_name}"]:-0} + _quantity ))
          utxos["${index_prefix}${_tx_hash}#${_tx_index}.${_policy_id}.${_asset_name}"]=${_quantity}
        done < <( jq -cr '.[] | "\(.policy_id),\(.asset_name),\(.quantity)"' <<< "${asset_list_unescaped}" )
      fi
    done <<< "${address_utxo_list}"
  fi
}

# Command     : getWalletBalance [wallet name] [force] [base] [pay] [asset]
# Description : get balance for wallet
# Parameters  : force  >  optional: [true|false] force update of balance (default = false)
#             : base   >  optional: [true|false] get base address balance (default = true)
#             : pay    >  optional: [true|false] get payment address balance (default = true)
#             : asset  >  optional: [true|false] fetch additional koios asset data (default = false)
getWalletBalance() {
  addr_list=()
  declare -gA base_assets=(); declare -gA pay_assets=()
  [[ $2 = true ]] && declare -gA balances=()
  [[ $5 = true ]] && asset_info=true || asset_info=false
  if [[ $3 != false ]] && getBaseAddress $1 && [[ -n ${base_addr} ]]; then
    if [[ -v balances[${base_addr}] ]]; then
      base_lovelace=${balances[${base_addr}]}
    else
      if [[ -n ${KOIOS_API} ]]; then
        addr_list+=(${base_addr})
      else
        getBalance ${base_addr}
        base_lovelace=${assets[lovelace]:-0}
        for idx in "${!assets[@]}"; do base_assets[${idx}]=${assets[${idx}]}; done
      fi
    fi
  else
    base_lovelace=0
  fi
  if [[ $4 != false ]] && getPayAddress $1 && [[ -n ${pay_addr} ]]; then
    if [[ -v balances[${pay_addr}] ]]; then
      pay_lovelace=${balances[${pay_addr}]}
    else
      if [[ -n ${KOIOS_API} ]]; then
        addr_list+=(${pay_addr})
      else
        getBalance ${pay_addr}
        pay_lovelace=${assets[lovelace]:-0}
        for idx in "${!assets[@]}"; do pay_assets[${idx}]=${assets[${idx}]}; done
      fi
    fi
  else
    pay_lovelace=0
  fi
  if [[ ${#addr_list[@]} -gt 0 ]]; then
    getBalanceKoios ${asset_info}
    if [[ -n ${base_addr} ]]; then
      base_lovelace=${assets["${base_addr},lovelace"]:-0}
      for idx in "${!assets[@]}"; do [[ ${idx} != "${base_addr},"* ]] && continue; base_assets[${idx#*,}]=${assets[${idx}]}; done
    fi
    if [[ -n ${pay_addr} ]]; then
      pay_lovelace=${assets["${pay_addr},lovelace"]:-0}
      for idx in "${!assets[@]}"; do [[ ${idx} != "${pay_addr},"* ]] && continue; pay_assets[${idx#*,}]=${assets[${idx}]}; done
    fi
  fi
}

# Command     : getAddressBalance [address] [force] [asset]
# Description : get balance for address
# Parameters  : force  >  optional: [true|false] force update of balance (default = false)
#             : asset  >  optional: [true|false] fetch additional koios asset data (default = false)
getAddressBalance() {
  [[ $2 = true ]] && declare -gA balances=()
  [[ $3 = true ]] && asset_info=true || asset_info=false
  if [[ -n ${1} ]]; then
    if [[ -v balances[${1}] ]]; then
      lovelace=${balances[${1}]}
    else
      if [[ -n ${KOIOS_API} ]]; then
        addr_list=(${1})
        getBalanceKoios ${asset_info}
        lovelace=${assets["${1},lovelace"]:-0}
      else
        getBalance ${1}
        lovelace=${assets[lovelace]:-0}
      fi
    fi
  else
    lovelace=0
  fi
}

# Command     : getAssetsTxOut [PolicyID.AssetName] [Amount]
# Description : generate tx out string for multi-assets in wallet
#               getBalance assumed to be run before calling this function
#               address variable assumed to be set to selected wallet bech32 address
# Parameters  : PolicyID.AssetName  >  optional: Adjust balance for this asset before generating output
#               Amount              >  optional: The amount to adjust balance
# Return      : populates ${assets_tx_out}
getAssetsTxOut() {
  assets_tx_out=""
  if [[ $# -eq 2 ]]; then
    old_value=assets[$1]
    assets[$1]=$(( old_value + $2 ))
  fi
  for idx in "${!assets[@]}"; do
    [[ ${idx} = *lovelace ]] && continue
    [[ ${assets[${idx}]} -gt 0 ]] && assets_tx_out+="+${assets[${idx}]} ${idx#*,}"
  done
}

# Command     : getMinUTxO [string]
# Description : calculate minimum balance needed in transaction output to be valid
#             : string as passed to --tx-out parameter
# Return      : populates ${min_utxo_out}
getMinUTxO() {
  unset min_utxo_out
  min_utxo_args=(
    ${NETWORK_ERA}
    transaction calculate-min-required-utxo
    --protocol-params-file "${TMP_DIR}"/protparams.json
    --tx-out "$1"
  )
  println ACTION "${CCLI} ${min_utxo_args[*]}"
  if ! stdout=$(${CCLI} "${min_utxo_args[@]}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during min utxo calculation!\n${stdout}"
    return 1
  fi
  min_utxo_out=$([[ ${stdout} =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
}

# Command     : getWalletRewards [wallet name] [force]
# Description : check balance of reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_lovelace}
getWalletRewards() {
  reward_lovelace=-1
  if [[ $2 = true ]]; then
    declare -gA rewards_available=(); declare -gA reward_status=(); declare -gA reward_pool=();
  fi
  if isWalletRegistered $1; then
    reward_lovelace=0
    if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
      for reward_entry in $(jq -r '.[] | @base64' <<< "${stake_address_info}"); do
        _jq() { base64 -d <<< ${reward_entry} | jq -r "${1}"; }
        reward_lovelace=$(( reward_lovelace + $(_jq '.rewardAccountBalance //0') ))
      done
    else
      reward_lovelace=${rewards_available[${reward_addr}]:-0}
    fi
  fi
}

# Command     : getRewardInfoKoios
# Description : check status and rewards for provided reward addresses using Koios API
getRewardInfoKoios() {
  # generate different arrays using reward address as key, rewards available, status and delegated pool if any
  # Its assumed that an array called reward_addr_list has been populated with all reward addresses to fetch data for

  declare -gA rewards_available=(); declare -gA reward_status=(); declare -gA reward_pool=();

  # set defaults
  for _reward_addr in "${reward_addr_list[@]}"; do
    reward_status["${_reward_addr}"]="not registered"
    rewards_available["${_reward_addr}"]=0
    unset 'reward_pool[${_reward_addr}]'
  done

  if [[ -n ${KOIOS_API} && -n ${reward_addr_list+x} ]]; then
    printf -v addr_list_joined '\"%s\",' "${reward_addr_list[@]}"
    println ACTION "curl -sSL -f -X POST -H \"Content-Type: application/json\" -H \"accept: text/csv\" -d '{\"_stake_addresses\":[${addr_list_joined%,}]}' ${KOIOS_API}/account_info?select=stake_address,status,delegated_pool,rewards_available"
    ! account_info_list=$(curl -sSL -f -X POST -H "Content-Type: application/json" -H "accept: text/csv" -d '{"_stake_addresses":['${addr_list_joined%,}']}' "${KOIOS_API}/account_info?select=stake_address,status,delegated_pool,rewards_available" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${account_info_list}\n" && return 1 # print error and return
    [[ -z ${account_info_list} ]] && return
    while IFS=',' read -r stake_address status delegated_pool rewards_available; do
      [[ ${stake_address} = stake_address ]] && continue # header line
      reward_status["${stake_address}"]="${status}"
      rewards_available["${stake_address}"]="${rewards_available}"
      [[ -n ${delegated_pool} ]] && reward_pool["${stake_address}"]="${delegated_pool}"
    done <<< "${account_info_list}"
  fi
}

# Command     : getRewardsFromAddr [stake address]
# Description : check balance of reward address
# Parameters  : stake address  >  the address from stake.vkey
# Return      : populates ${reward_lovelace}
getRewardsFromAddr() {
  reward_lovelace=0
  println ACTION "${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address ${1}"
  ! stake_address_info=$(${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address ${1}) && println "ERROR" "\n${FG_RED}NODE CLI ERROR${NC}: ${stake_address_info}\n" && return 1 # print error and return
  for reward_entry in $(jq -r '.[] | @base64' <<< "${stake_address_info}"); do
    _jq() { base64 -d <<< ${reward_entry} | jq -r "${1}"; }
    reward_lovelace=$(( reward_lovelace + $(_jq '.rewardAccountBalance //0') ))
  done
}

# Command     : isWalletRegistered [wallet name]
# Description : check if wallet is registered on chain
# Parameters  : wallet name  >  the name of the wallet
isWalletRegistered() {
  if getRewardAddress $1; then
    if [[ -n ${KOIOS_API} ]]; then
      [[ ! -v "reward_status[${reward_addr}]" ]] && reward_addr_list=( ${reward_addr} ) && getRewardInfoKoios
      [[ ${reward_status[${reward_addr}]} = registered ]] && return 0
    else
      println ACTION "${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address ${reward_addr}"
      ! stake_address_info=$(${CCLI} ${NETWORK_ERA} query stake-address-info ${NETWORK_IDENTIFIER} --address ${reward_addr}) && println "ERROR" "\n${FG_RED}NODE CLI ERROR${NC}: ${stake_address_info}\n" && return 1 # print error and return
      [[ -n "${stake_address_info}" && $(jq -r 'length' <<< ${stake_address_info}) -gt 0 ]] && return 0
    fi
  fi
  return 1
}

# Command     : getWalletType [wallet name]
# Description : check if wallet is a hardware wallet, 0=yes, 1=cli, 2=cli & encrypted, 3=signing keys missing, 4=verification keys missing, 5=multi-sig
# Parameters  : wallet name  >  the name of the wallet
getWalletType() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}"
  payment_script_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}"
  if [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}" && -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}" ]]; then # CNTools wallet
    if [[ $(jq -r '.description' "${payment_vk_file}") = *"Hardware"* ]]; then
      payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_PAY_SK_FILENAME}"
      stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_STAKE_SK_FILENAME}"
      [[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]] && return 3 || return 0
    elif [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}.gpg" || -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}.gpg" ]]; then
      return 2
    else
      [[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]] && return 3 || return 1
    fi
  elif [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_SCRIPT_FILENAME}" && -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}" ]]; then # CNTools multi-sig wallet
    return 5
  else
    return 4
  fi
}

# Command     : getPoolType [pool name]
# Description : check if pool is a hardware pool, 0=yes, 1=cli, 2=cli & encrypted, 3=signing keys missing, 4=verification keys missing
# Parameters  : pool name  >  the name of the pool
getPoolType() {
  pool_coldkey_vk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}"
  pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}"
  if [[ -f "${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}" ]]; then # CNTools pool
    if [[ $(jq -r '.description' "${pool_coldkey_vk_file}") = *"Hardware"* ]]; then
      pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_HW_COLDKEY_SK_FILENAME}"
      ([[ ${op_mode} = "online" && ( ! -f ${pool_coldkey_sk_file} ) ]]) && return 3 || return 0
    elif [[ -f "${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}.gpg" ]]; then
      return 2
    else
      ([[ ${op_mode} = "online" && ( ! -f ${pool_coldkey_sk_file} ) ]]) && return 3 || return 1
    fi
  else
    return 4
  fi
}

# Command     : getTTL
# Description : query node for slot tip and calculate/get TTL from input depending on op_mode
getTTL() {
  tip_ref=$(getSlotTipRef)
  if [[ ${op_mode} = "hybrid" ]]; then
    println DEBUG "\nHow long do you want the transaction to be valid?"
    getAnswerAnyCust ttl_enter "TTL (in seconds, default: 1800/30min)"
    ttl_enter=${ttl_enter:-1800}
    if ! isNumber ${ttl_enter}; then
      println ERROR "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}"
      return 1
    fi
    ttl=$(( tip_ref + (ttl_enter/SLOT_LENGTH) ))
  else
    ttl=$(( tip_ref + (TX_TTL/SLOT_LENGTH) ))
  fi
  println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl}"
}

# Command     : buildOfflineJSON [type]
# Description : construct a json containing all data for offline signing
# Parameters  : type  >  type of transaction, e.g 'payment'
buildOfflineJSON() {
  offlineJSON="{}"
  if ! offlineJSON=$(jq ". += { id: \"$(date +%s)\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { type: \"${1}\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-created\": \"$(date --iso-8601=s)\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-expire\": \"$(date --iso-8601=s --date="@$(($(date +%s)+ttl_enter))")\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { ttl: \"${ttl}\" }" <<< ${offlineJSON}); then return 1; fi
}

# Command     : registerStakeWallet [wallet name] [optional: skip validation]
# Description : Register stake keys on chain and move funds from payment address to payment base address
# Parameters  : wallet name      >  the name of the wallet
# Parameters  : skip validation  >  [optional] [true|false] if true, skip wallet registration check
registerStakeWallet() {

  wallet_name=$1
  wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if [[ -z $2 || $2 = "false" ]]; then
    println DEBUG "Wallet ${FG_GREEN}${wallet_name}${NC} not registered on chain"
    waitToProceed "press any key to continue with registration"
  fi

  stake_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_VK_FILENAME}"
  stake_cert_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_CERT_FILENAME}"
  
  println ACTION "${CCLI} ${NETWORK_ERA} stake-address registration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_cert_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} stake-address registration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_cert_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during stake registration certificate creation!\n${stdout}"; return 1
  fi

  if ! getTTL; then return 1; fi

  println LOG "Key Deposit is ${KEY_DEPOSIT}"

  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${stake_cert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi
  
  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1
  
  newBalance=$(( base_lovelace - min_fee - KEY_DEPOSIT ))
  println LOG "New balance after tx fee and key deposit is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${KEY_DEPOSIT}))"

  if [[ ${base_lovelace} -lt $(( min_fee + KEY_DEPOSIT )) ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee and key deposit!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee + KEY_DEPOSIT )))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and key deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${stake_cert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"$(( min_fee + KEY_DEPOSIT ))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
  echo
  if ! verifyTx ${base_addr}; then return 1; fi
  echo

  reward_lovelace=0
}

# Command     : deregisterStakeWallet
# Description : Deregister stake keys/wallet from chain, key deposit fee returned to wallets base address
deregisterStakeWallet() {

  wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  stake_dereg_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_DEREG_FILENAME}"
  println ACTION "${CCLI} ${NETWORK_ERA} stake-address deregistration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_dereg_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} stake-address deregistration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_dereg_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during stake deregistration certificate creation!\n${stdout}"; return 1
  fi

  if ! getTTL; then return 1; fi
  
  println LOG "Key Deposit is ${KEY_DEPOSIT}"

  getAssetsTxOut

  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${stake_dereg_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1

  newBalance=$(( base_lovelace + KEY_DEPOSIT - min_fee ))
  println LOG "New balance after returned key deposit and subtracted tx fee is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${base_lovelace}) + $(formatLovelace ${KEY_DEPOSIT}) - $(formatLovelace ${min_fee}))"
  
  if [[ $(( ${base_lovelace} + KEY_DEPOSIT )) -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee - KEY_DEPOSIT )))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and returned key deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${stake_dereg_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"amount-returned\": \"${KEY_DEPOSIT}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : sendAssets
# Description : send Assets from source to destination
#             : can also be used to defrag address by sending all to self
#             : supports fee to be payed by sender(default) or receiver by reducing amount to send
sendAssets() {

  [[ $(cat "${WALLET_FOLDER}/${s_wallet}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${s_addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${s_addr}]}
    tx_in=${tx_in_arr[${s_addr}]}
  fi

  if ! getTTL; then return 1; fi

  if [[ -n ${metafile} && -f ${metafile} ]]; then
    metafile_param="--json-metadata-no-schema --metadata-json-file ${metafile}"
  else
    metafile_param=""
  fi

  [[ ${#assets_left[@]} -eq 0 ]] && outCount=1 || outCount=2
  
  assets_tx_out_s=""
  assets_tx_out_d=""
  for idx in "${!assets_left[@]}"; do
    [[ ${idx} = "lovelace" ]] && continue
    [[ ${assets_left[${idx}]} -gt 0 ]] && assets_tx_out_s+="+${assets_left[${idx}]} ${idx}"
  done
  for idx in "${!assets_to_send[@]}"; do
    [[ ${idx} = "lovelace" ]] && continue
    [[ ${assets_to_send[${idx}]} -gt 0 ]] && assets_tx_out_d+="+${assets_to_send[${idx}]} ${idx}"
  done

  build_args=(
    ${tx_in}
    --invalid-hereafter ${ttl}
    --fee 0
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx0.tmp
  )
  if [[ ${outCount} -eq 1 ]]; then
    build_args+=( --tx-out "${d_addr}+0${assets_tx_out_d}" )
  else
    build_args+=( --tx-out "${s_addr}+0${assets_tx_out_s}" --tx-out "${d_addr}+0${assets_tx_out_d}" )
  fi

  if ! buildTx; then return 1; fi
  
  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} ${outCount} 1 || return 1
  
  build_args=(
    ${tx_in}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx.raw
  )
  
  if [[ ${outCount} -eq 1 ]]; then # all assets to destination, nothing to return
    newBalance=0
    tx_out="${d_addr}+$(( ${assets_to_send[lovelace]} - min_fee ))${assets_tx_out_d}"
    getMinUTxO "${tx_out}" || return 1
    if [[ ${assets_to_send[lovelace]} -lt ${min_utxo_out} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in address ( $(formatLovelace ${assets_to_send[lovelace]}) < $(formatLovelace ${min_utxo_out}) )"
      println ERROR "Top up wallet with enough ADA to cover minimum UTxO balance"
      return 1
    fi
    build_args+=( --tx-out "${tx_out}" )
  else
    if [[ ${include_fee} = "no" ]]; then
      newBalance=$(( ${assets[${index_prefix}lovelace]} - ${assets_to_send[lovelace]} - min_fee ))
      tx_out_d="${d_addr}+${assets_to_send[lovelace]}${assets_tx_out_d}"
    else
      newBalance=$(( ${assets[${index_prefix}lovelace]} - ${assets_to_send[lovelace]} ))
      tx_out_d="${d_addr}+$(( ${assets_to_send[lovelace]} - min_fee ))${assets_tx_out_d}"
    fi
    getMinUTxO "${tx_out_d}"
    min_utxo_out_d=${min_utxo_out}
    build_args+=( --tx-out "${tx_out_d}" )
    
    tx_out_s="${s_addr}+${newBalance}${assets_tx_out_s}"
    getMinUTxO "${tx_out_s}"
    min_utxo_out_s=${min_utxo_out}
    build_args+=( --tx-out "${tx_out_s}" )
    
    if [[ ${newBalance} -lt ${min_utxo_out_s} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA left in source address ( $(formatLovelace ${newBalance}) < $(formatLovelace ${min_utxo_out_s}) )"
      println ERROR "Send all ADA or top up wallet with enough ADA to cover minimum UTxO balance"
      return 1
    elif [[ ${assets_to_send[lovelace]} -lt ${min_utxo_out_d} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, requires ${FG_LBLUE}$(formatLovelace ${min_utxo_out_d})${NC} ADA to be sent along!"
      return 1
    fi
  fi
  
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Payment"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${s_wallet}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"source-address\": \"${s_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"destination-address\": \"${d_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { "assets": [] }" <<< ${offlineJSON}); then return 1; fi
    for idx in "${!assets_to_send[@]}"; do
      [[ ${assets_to_send[${idx}]} -gt 0 ]] && if ! offlineJSON=$(jq "."assets" += [{ asset: \"${idx}\", amount: \"${assets_to_send[${idx}]}\" }]" <<< ${offlineJSON}); then return 1; fi
    done
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${s_wallet}' payment signing key\", vkey: $(jq -c . "${s_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Source Wallet ${FG_GREEN}${s_wallet} ${FG_LGRAY}$(basename ${s_payment_sk_file})${NC}"  
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${s_payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : Delegate
# Description : Register pool with pledge on chain
delegate() {

  wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if ! getTTL; then return 1; fi
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_delegcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1

  newBalance=$(( base_lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) )"
  
  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_delegcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Delegation"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-id\": \"${pool_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${pool_name} != "${pool_id}" ]]; then
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : withdrawRewards
# Description : withdraw rewards earned and send to wallet base address
withdrawRewards() {

  wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi

  if ! getTTL; then return 1; fi
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1

  newBalance=$(( base_lovelace - min_fee + reward_lovelace ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $((min_fee - reward_lovelace)))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and withdrawal, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --withdrawal ${reward_addr}+${reward_lovelace}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Rewards Withdrawal"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { rewards: \"${reward_lovelace}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : registerPool
# Description : Register pool with pledge on chain
registerPool() {

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi
  
  if ! getTTL; then return 1; fi
  
  println LOG "Pool Deposit is ${POOL_DEPOSIT}"
  
  owner_delegation_cert=""
  [[ ${delegate_owner_wallet} = 'Y' ]] && owner_delegation_cert="--certificate-file ${owner_delegation_cert_file}"
  
  witness_count=$(( 2 + ${#owner_wallets[@]} )) # owner payment + cold + multi-owners(main owner included)
  
  owner_delegation_cert=""
  if [[ ${delegate_owner_wallet} = 'Y' ]]; then
    owner_delegation_cert="${owner_delegation_cert_file}"
  fi
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )
  [[ -n ${owner_delegation_cert} ]] && build_args+=( --certificate-file "${owner_delegation_cert}" )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_count} || return 1
  
  newBalance=$(( base_lovelace - min_fee - POOL_DEPOSIT ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${POOL_DEPOSIT}) )"
  
  if [[ ${base_lovelace} -lt $(( min_fee + POOL_DEPOSIT )) ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee and pool registration deposit!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee + POOL_DEPOSIT )))${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee and pool registration deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )
  [[ -n ${owner_delegation_cert} ]] && build_args+=( --certificate-file "${owner_delegation_cert}" )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  for index in "${!owner_wallets[@]}"; do
    stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
    [[ $(jq .description "${stake_vk_file}") = *Hardware* ]] && needHWCLI=true && break
  done
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": \"${pledge_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": \"${cost_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"$(( min_fee + POOL_DEPOSIT ))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      if [[ ${index} -eq 0 ]]; then
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${owner_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
      stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    done
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { witness: [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}${POOL_COLDKEY_SK_FILENAME}${NC}" 
    println DEBUG "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_LGRAY}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}" 
    for index in "${!owner_wallets[@]}"; do
      [[ ${index} -eq 0 ]] && continue # skip main owner
      println DEBUG "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
    done
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  multi_owner_keys=()
  for index in "${!owner_wallets[@]}"; do
    [[ ${index} -eq 0 ]] && continue # skip main owner
    getWalletType ${owner_wallets[${index}]}
    multi_owner_keys+=( "${stake_sk_file}" )
  done
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : modifyPool
# Description : Register pool with pledge on chain
modifyPool() {

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    utxo_cnt=${utxos_cnt[${base_addr}]}
    tx_in=${tx_in_arr[${base_addr}]}
  fi
  
  if ! getTTL; then return 1; fi

  witness_count=$(( 2 + ${#owner_wallets[@]} )) # owner payment + cold + multi-owners(main owner included)
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 ${witness_count} || return 1
  
  newBalance=$(( base_lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${base_lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${base_lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  for index in "${!owner_wallets[@]}"; do
    stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
    [[ $(jq .description "${stake_vk_file}") = *Hardware* ]] && needHWCLI=true && break
  done
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Update"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": \"${pledge_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": \"${cost_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      if [[ ${index} -eq 0 ]]; then
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${owner_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
      stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    done
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { witness: [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}${POOL_COLDKEY_SK_FILENAME}${NC}"
    println DEBUG "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_LGRAY}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
    for index in "${!owner_wallets[@]}"; do
      [[ ${index} -eq 0 ]] && continue # skip main owner
      println DEBUG "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
    done
    return 2 # return as failed to stop main processing and return to home menu
  fi

  multi_owner_keys=()
  for index in "${!owner_wallets[@]}"; do
    [[ ${index} -eq 0 ]] && continue # skip main owner
    getWalletType ${owner_wallets[${index}]}
    multi_owner_keys+=( "${stake_sk_file}" )
  done

  if ! witnessTx "${TMP_DIR}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : deRegisterPool
# Description : Retire pool
deRegisterPool() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  if ! getTTL; then return 1; fi

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in ${!assets[@]}; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
  fi

  getAssetsTxOut

  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_deregcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1

  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi

  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_deregcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  pay_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_VK_FILENAME}"
  [[ $(jq .description "${pay_vk_file}") = *Hardware* ]] && needHWCLI=true
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -f "${POOL_FOLDER}/${pool_name}/poolmeta.json" ]]; then
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"$(jq -r .name "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"$(jq -r .ticker "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"\" }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"retire-epoch\": \"${epoch_enter}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}$(basename ${pool_coldkey_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi

  getWalletType ${wallet_name}

  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${pool_coldkey_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi

}

# Command     : rotatePoolKeys
# Description : Rotate pool's KES keys
# parameters  : $1 = cold counter (offline mode)
rotatePoolKeys() {

  # cold keys
  if getPoolType ${pool_name}; then needHWCLI="true"; else needHWCLI="false" ;fi

  # generated files
  pool_hotkey_vk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_VK_FILENAME}"
  pool_hotkey_sk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_SK_FILENAME}"
  pool_opcert_counter_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_COUNTER_FILENAME}"
  pool_saved_kes_start="${POOL_FOLDER}/${pool_name}/${POOL_CURRENT_KES_START}"
  pool_opcert_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_FILENAME}"

  if [[ ! -f ${pool_coldkey_vk_file} ]]; then # lets re-generate it from cold signing key
    println ACTION "${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file ${pool_coldkey_sk_file} --verification-key-file ${pool_coldkey_vk_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} key verification-key --signing-key-file "${pool_coldkey_sk_file}" --verification-key-file "${pool_coldkey_vk_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during cold verification key creation!\n${stdout}"; return 1
    fi
    println ACTION "jq '.description = \"Stake Pool Operator Verification Key\"' ${pool_coldkey_vk_file}"
    if ! stdout=$(jq '.description = "Stake Pool Operator Verification Key"' "${pool_coldkey_vk_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during cold verification key description update!\n${stdout}"; return 1
    else
      jq <<< ${stdout} > "${pool_coldkey_vk_file}"
    fi
  fi

  current_kes_period=$(getCurrentKESperiod)
  echo "${current_kes_period}" > ${pool_saved_kes_start}

  println ACTION "${CCLI} ${NETWORK_ERA} node key-gen-KES --verification-key-file ${pool_hotkey_vk_file} --signing-key-file ${pool_hotkey_sk_file}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} node key-gen-KES --verification-key-file "${pool_hotkey_vk_file}" --signing-key-file "${pool_hotkey_sk_file}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during KES key creation!\n${stdout}"; return 1
  fi

  p_opcert=""
  if [[ $# -eq 1 ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value $1 --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value $1 --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate counter creation!\n${stdout}"; return 1
    fi
  elif [[ -n ${KOIOS_API} ]]; then
    ! getPoolID "${pool_name}" && println "ERROR" "\n${FG_RED}ERROR${NC}: failed to get pool ID!\n" && return 1
    println ACTION "curl -sSL -f -X POST -H \"Content-Type: application/json\" -d '{\"_pool_bech32_ids\":[\"${pool_id_bech32}\"]}' ${KOIOS_API}/pool_info"
    ! pool_info=$(curl -sSL -f -X POST -H "Content-Type: application/json" -d '{"_pool_bech32_ids":["'${pool_id_bech32}'"]}' "${KOIOS_API}/pool_info" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${pool_info}\n" && p_opcert="" # print error but ignore
    if old_counter_nbr=$(jq -er '.[0].op_cert_counter' <<< "${pool_info}" 2>/dev/null); then
      new_counter_nbr=$(( old_counter_nbr + 1 ))
    else
      new_counter_nbr=0 # null returned = no block on chain for this pool
    fi
    println ACTION "${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate counter creation!\n${stdout}"; return 1
    fi
  elif [[ -f ${pool_opcert_file} ]]; then
    println ACTION "${CCLI} ${NETWORK_ERA} query kes-period-info --op-cert-file ${pool_opcert_file} ${NETWORK_IDENTIFIER}"
    if ! kes_period_info=$(${CCLI} ${NETWORK_ERA} query kes-period-info --op-cert-file "${pool_opcert_file}" ${NETWORK_IDENTIFIER}); then
      println "ERROR" "\n${FG_RED}ERROR${NC}: failed to grab counter from node: [${kes_period_info}]\n" && return 1
    fi
    if old_counter_nbr=$(awk '/{/,0' <<< "${kes_period_info}" | jq -er '.qKesNodeStateOperationalCertificateNumber' 2>/dev/null); then
      new_counter_nbr=$(( old_counter_nbr + 1 ))
    else
      new_counter_nbr=0 # null returned = no block on chain for this pool
    fi
    println ACTION "${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate counter creation!\n${stdout}"; return 1
    fi
  else
    println "ERROR" "\n${FG_RED}ERROR${NC}: op cert file missing and Koios disabled/unavailable. Unable to get current on-chain counter value!\n" && return 1
  fi

  if [[ ${needHWCLI} = true ]]; then
    if ! unlockHWDevice "issue the opcert"; then return 1; fi
    println ACTION "cardano-hw-cli node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --hw-signing-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}"
    if ! stdout=$(cardano-hw-cli node issue-op-cert \
    --kes-verification-key-file "${pool_hotkey_vk_file}" \
    --hw-signing-file "${pool_coldkey_sk_file}" \
    --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" \
    --kes-period "${current_kes_period}" \
    --out-file "${pool_opcert_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during hardware operational certificate creation!\n${stdout}"; return 1
    fi
  else
    println ACTION "${CCLI} ${NETWORK_ERA} node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --cold-signing-key-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}"
    if ! stdout=$(${CCLI} ${NETWORK_ERA} node issue-op-cert --kes-verification-key-file "${pool_hotkey_vk_file}" --cold-signing-key-file "${pool_coldkey_sk_file}" --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" --kes-period "${current_kes_period}" --out-file "${pool_opcert_file}" 2>&1); then
      println ERROR "\n${FG_RED}ERROR${NC}: failure during operational certificate creation!\n${stdout}"; return 1
    fi
  fi

  chmod 700 ${POOL_FOLDER}/${pool_name}/*

  unset remaining_kes_periods
  kesExpiration ${current_kes_period}
}

# Command     : sendMetadata
# Description : post metadata file on chain using specified wallet to pay for the transaction fee
sendMetadata() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  if [[ ${metatype} = "no-schema" ]]; then
    metafile_param="--json-metadata-no-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "detailed-schema" ]]; then
    metafile_param="--json-metadata-detailed-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "cbor" ]]; then
    metafile_param="--metadata-cbor-file ${metafile}"
  else
    println ERROR "${FG_RED}ERROR${NC}: unknown metadata type '${metatype}'"
    return 1
  fi

  if ! getTTL; then return 1; fi

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in ${!assets[@]}; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
  fi

  getAssetsTxOut

  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 1 || return 1
  
  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Metadata"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : mintAsset
# Description : mint a custom asset using specified wallet to pay for the transaction fee
mintAsset() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in ${!assets[@]}; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    index_prefix="${addr},"
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
    unset index_prefix
  fi

  if [[ ${policy_ttl} -eq 0 ]]; then 
    if ! getTTL; then return 1; fi
  else
    ttl=${policy_ttl}
    tip_ref=$(getSlotTipRef)
    println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl} based on policy expiration"
  fi
  
  [[ -z ${asset_name} ]] && asset_name_out="" || asset_name_out=".$(asciiToHex "${asset_name}")"
  getAssetsTxOut "${index_prefix}${policy_id}${asset_name_out}" "${assets_to_mint}"
  
  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --mint "${assets_to_mint} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee 0
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi
  
  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1

  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --mint "${assets_to_mint} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Asset Minting"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-name\": \"${policy_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-id\": \"${policy_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-name\": \"$(asciiToHex "${asset_name}") (${asset_name})\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-amount\": \"${assets_to_mint}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-minted\": \"${asset_minted}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Asset '${policy_sk_file}' policy signing key\", vkey: $(jq -c . "${policy_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Policy ${FG_GREEN}${policy_name} ${FG_LGRAY}$(basename ${policy_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${policy_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : burnAsset
# Description : burn custom assets on specified wallet
burnAsset() {

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in ${!assets[@]}; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    index_prefix="${addr},"
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
    unset index_prefix
  fi

  if [[ ${policy_ttl} -eq 0 ]]; then 
    if ! getTTL; then return 1; fi
  else
    ttl=${policy_ttl}
    tip_ref=$(getSlotTipRef)
    println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl} based on policy expiration"
  fi
  
  [[ -z ${asset_name} ]] && asset_name_out="" || asset_name_out=".${asset_name}"
  getAssetsTxOut "${index_prefix}${policy_id}${asset_name_out}" "-${assets_to_burn}"
  
  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --mint "-${assets_to_burn} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee 0
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1

  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"
  
  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --mint "-${assets_to_burn} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Asset Burning"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-name\": \"${policy_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-id\": \"${policy_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-name\": \"${asset_name} ($(hexToAscii ${asset_name}))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-amount\": \"${assets_to_burn}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-minted\": \"${asset_minted}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Asset '${policy_sk_file}' policy signing key\", vkey: $(jq -c . "${policy_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Policy ${FG_GREEN}${policy_name} ${FG_LGRAY}$(basename ${policy_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${policy_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : buildTx [build_args]
# Description : Helper function to build a raw transaction
#             : populate an array variable called 'build_args' with all data
# Parameters  : build_args  >  an array with all the arguments to assemble the transaction
buildTx() {
  println ACTION "${CCLI} ${NETWORK_ERA} transaction build-raw ${build_args[*]}"
  if ! stdout=$(${CCLI} ${NETWORK_ERA} transaction build-raw "${build_args[@]}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during transaction building!\n${stdout}"; return 1
  fi
}

# Command     : calcMinFee [rax tx file] 
# Description : Helper function to calculate minimum fee from a build transaction
# Parameters  : $1 = raw tx file > the transaction body file to use for calculating fee
#               $2 = Count of transaction inputs (spent txo count)
#               $3 = Count of transaction outputs
#               $4 = Count of witnesses required to sign the transaction
calcMinFee() {
  min_fee_args=(
    ${NETWORK_ERA}
    transaction calculate-min-fee
    --tx-body-file "$1"
    --tx-in-count $2
    --tx-out-count $3
    ${NETWORK_IDENTIFIER}
    --witness-count $4
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  if ! stdout=$(${CCLI} "${min_fee_args[@]}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: failure during minimum fee calculation!\n${stdout}"; return 1
  fi
  min_fee=$([[ ${stdout} =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) ADA"
}

# Command     : witnessTx [raw tx file] [signing keys ...]
# Description : Helper function to witness a raw transaction
# Parameters  : raw tx file   >  the transaction file to sign
#             : signing keys  >  list of signing keys to use when witnessing the transaction
witnessTx() {
  tx_raw="$1"
  shift
  tx_witness_files=()
  unset isHW
  for skey in "$@"; do
    [[ -z ${skey//[[:blank:]]/} ]] && continue
    if [[ ! -f "${skey}" ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: file not found: ${skey}"
      return 1
    elif [[ $(jq -r '.description' "${skey}") = *"Hardware"* ]]; then # HW signing key
      if [[ ${isHW} = 'Y' ]]; then
        # just add key and output to witness_command()
        tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
        hw_witness_command+=(
          --hw-signing-file "${skey}"
          --change-output-key-file "${skey}"
          --out-file "${tx_witness}"
        )
      else
        isHW=Y
        tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
        hw_witness_command=(
          cardano-hw-cli transaction witness
          --tx-file "${tx_raw}"
          --hw-signing-file "${skey}"
          --change-output-key-file "${skey}"
          --out-file "${tx_witness}"
          ${NETWORK_IDENTIFIER}
        )
      fi
    else
      tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
      witness_command=(
        ${CCLI} transaction witness
        --tx-body-file "${tx_raw}"
        --signing-key-file "${skey}"
        ${NETWORK_IDENTIFIER}
        --out-file "${tx_witness}"
      )
      println ACTION "${witness_command[@]}"
      if ! stdout=$("${witness_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during transaction signing !!\n${stdout}" && return 1; fi
    fi
    tx_witness_files+=( "${tx_witness}" )
  done

  # Special case for HW
  if [[ ${isHW} = 'Y' ]]; then
    if ! unlockHWDevice "witness the transaction"; then return 1; fi
    println ACTION "${hw_witness_command[@]}"
    if ! stdout=$("${hw_witness_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during hardware wallet signing !!\n${stdout}" && return 1; fi
  fi
}

# Command     : assembleTx [raw tx file]
# Description : Helper function to witnessTx for assembling a signed tx using witnesses from tx_witness_files[] array
assembleTx() {
  tx_raw="$1"
  tx_signed="${TMP_DIR}/tx.signed_$(date +%s)"
  if [[ ${#tx_witness_files[@]} -gt 0 ]]; then # assemble witness files and sign
    tx_witness_out=()
    for witness in "${tx_witness_files[@]}"; do
      [[ -z ${witness//[[:blank:]]/} || ! -s "${witness}" ]] && continue
      if [[ -f "${witness}" ]]; then
        tx_witness_out+=( "--witness-file ${witness}" )
      else
        println ERROR "\n${FG_RED}ERROR${NC}: witness file not found: ${witness}"
        return 1
      fi
    done
    sign_command=(
      ${CCLI} ${NETWORK_ERA} transaction assemble
      --tx-body-file "${tx_raw}"
      ${tx_witness_out[@]}
      --out-file "${tx_signed}"
    )
    println ACTION "${sign_command[@]}"
    if ! stdout=$("${sign_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during hardware wallet signing !!\n${stdout}" && return 1; fi
  else
    println ERROR "\n${FG_RED}ERROR${NC}: no witness files provided, unable to assemble tx!"
    return 1
  fi
}

# Command     : submitTx [signed tx file]
# Description : Helper function to submit signed transaction file
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTx() {
  tx_signed="$1"
  answer=0
  while true; do
    if [[ ${CNTOOLS_MODE} = "LOCAL" ]]; then
      submitTxNode ${tx_signed} && break
    else
      submitTxKoiosOgmios ${tx_signed} && break
    fi
    tput sc
    println DEBUG "\nRetry transaction submit?"
    select_opt "[y] Yes" "[n] No"
    answer=$?
    tput rc && tput ed
    case ${answer} in
      0) : ;;
      1) break ;;
    esac
  done
  return ${answer}
}

# Command     : submitTxNode [signed tx file]
# Description : Helper function to submit signed transaction file using local node
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTxNode() {
  submit_command=(
    ${CCLI} ${NETWORK_ERA} transaction submit
    --tx-file "$1"
    ${NETWORK_IDENTIFIER}
  )
  println ACTION "${submit_command[@]}"
  if ! stdout=$("${submit_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: Transaction submit failed !!\n${stdout}"; return 1; fi
}

# Command     : getTxId [tx file]
# Description : Helper function to calculate transaction id
# Parameters  : signed tx file   >  the signed transaction file to submit
# Info        : tx_id set to hash of transaction body
getTxId() {
  txid_command=(
    ${CCLI} transaction txid
    --tx-file "$1"
  )
  println ACTION "${txid_command[@]}"
  if ! tx_id=$("${txid_command[@]}" 2>&1); then println ERROR "\n${FG_RED}ERROR${NC}: during transaction hashing !!\n${tx_id}" && return 1; fi
}

# Command     : submitTxKoiosSubmitAPI [signed tx file]
# Description : Helper function to submit signed transaction file using koios submitapi endpoint
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTxKoiosSubmitAPI() {
  getTxId $1 || return $?
  cborHex=$(jq -er '.cborHex' "$1" 2>/dev/null) || { println ERROR "\n${FG_RED}ERROR${NC}: Invalid tx file format, 'cborHex' missing in: $1"; return 1; }
  txdata="$(mktemp "${TMP_DIR}/tx.signed_XXXXXXXXXX")"
  xxd -p -r <<< ${cborHex} > ${txdata}
  println ACTION "curl -sfSL -X POST -H \"Content-Type: application/cbor\" --data-binary @${txdata} \"${KOIOS_API}/submittx\""
  if ! stdout=$(curl -sfSL -X POST -H "Content-Type: application/cbor" --data-binary @${txdata} "${KOIOS_API}/submittx" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction submit failed !!\n${stdout}"; return 1
  fi
  println LOG "Submit result: ${stdout}"
}

# Command     : submitTxKoiosOgmios [signed tx file]
# Description : Helper function to submit signed transaction file using koios submitapi endpoint
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTxKoiosOgmios() {
  getTxId $1 || return $?
  cborHex=$(jq -er '.cborHex' "$1" 2>/dev/null) || { println ERROR "\n${FG_RED}ERROR${NC}: Invalid tx file format, 'cborHex' missing in: $1"; return 1; }
  jsonrpc=$(jq -n -c --arg cbor "${cborHex}" '{jsonrpc: "2.0", method: "submitTransaction", params: {transaction: {cbor: $cbor}}}')
  unset ogmios_error
  println ACTION "curl -sSL -X POST  -H \"accept: application/json\" -H \"Content-Type: application/json\" -d \"${jsonrpc}\" \"${KOIOS_API}/ogmios/\""
  stdout=$(curl -sSL -X POST  -H "accept: application/json" -H "Content-Type: application/json" -d "${jsonrpc}" "${KOIOS_API}/ogmios/" 2>&1)
  if [[ -z ${stdout} ]] || ogmios_error=$(jq -er '.error //empty' <<< "${stdout}") || ! jq -er '.result //empty' <<< "${stdout}" &>/dev/null; then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction submit failed !!"
    if [[ -n ${ogmios_error} ]]; then
      jq -r . <<< "${ogmios_error}"
      println LOG $(jq -rc . <<< "${ogmios_error}")
    else
      println ERROR "Submit API error: ${stdout}"
    fi
    return 1
  fi
  ogmios_res=$(jq -erc '.result' <<< "${stdout}") && println LOG "Submit result: ${ogmios_res}"
}

# Command     : transformRawTx [raw tx file]
# Description : Transform raw tx to be in canonical order for HW wallets 
# Parameters  : raw tx file  >  path to raw tx to correct
transformRawTx() {
  tx_raw="$1"
  tx_raw_tmp="$(mktemp "${TMP_DIR}/tx.raw_XXXXXXXXXX")"
  println ACTION "cardano-hw-cli transaction transform --tx-file ${tx_raw} --out-file ${tx_raw_tmp}"
  if ! stdout=$(cardano-hw-cli transaction transform --tx-file "${tx_raw}" --out-file "${tx_raw_tmp}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction transform failed !!\n${stdout}"; return 1
  fi
  println ACTION "mv ${tx_raw_tmp} ${tx_raw}"
  if ! stdout=$(mv "${tx_raw_tmp}" "${tx_raw}" 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: Transaction transform failure moving temporary file to ${tx_raw} !!\n${stdout}"; return 1
  fi
}

# Command     : unlockHWDevice [action]
# Description : Directions to unlock and open HW device
# Parameters  : action  >  message for action to be taken
unlockHWDevice() {
  if ! HWCLIversionCheck; then waitToProceed && return 1; fi
  waitToProceed "${FG_BLUE}INFO${NC}: please connect and unlock hardware device" "\n  ${FG_YELLOW}Ledger${NC} - Unlock with pin and open Cardano app" "\n  ${FG_YELLOW}Trezor${NC} - Make sure trezor bridge is installed (https://wallet.trezor.io/#/bridge) " "\n\nwhen done, press any key to continue"
  println ACTION "cardano-hw-cli device version"
  if ! device_app=$(cardano-hw-cli device version 2>&1); then
    println ERROR "\n${FG_RED}ERROR${NC}: accessing hardware device failed !!\n${device_app}"; return 1
  fi
  device_app_vendor="$(cut -d' ' -f1 <<< "${device_app}")"
  device_app_version="$(cut -d' ' -f4 <<< "${device_app}")"
  println LOG "hardware device: vendor=${device_app_vendor} version=${device_app_version}"
  if [[ ! ${device_app_version} =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    println ERROR "${FG_RED}ERROR${NC}: unable to identify connected hardware device, is the device plugged in and unlocked?"
    println ERROR "Make sure device is seen by OS using tools like lsusb etc and is working correctly"
    waitToProceed && return 1
  elif [[ ${device_app_vendor} = Ledger ]]; then
    if ! versionCheck "5.0.1" "${device_app_version}"; then
      println ERROR "${FG_RED}ERROR${NC}: Cardano app version installed on Ledger is ${FG_LGRAY}v${device_app_version}${NC}, minimum required app version is ${FG_GREEN}v5.0.1${NC} !!"
      return 1
    fi
  elif [[ ${device_app_vendor} = Trezor ]]; then
    if ! versionCheck "2.6.4" "${device_app_version}"; then
      println ERROR "${FG_RED}ERROR${NC}: Trezor firmware installed on device is ${FG_LGRAY}v${device_app_version}${NC}, minimum required version is ${FG_GREEN}v2.6.4${NC} !!"
      return 1
    fi
  else
    println ERROR "${FG_RED}ERROR${NC}: Unknown vendor: ${FG_LGRAY}${device_app_vendor}${NC} !!"
    return 1
  fi
  println DEBUG "\n${FG_BLUE}INFO${NC}: follow directions on hardware device to $1"
}

HWCLIversionCheck() {
  ! command -v "cardano-hw-cli" &>/dev/null && echo "cardano-hw-cli not found, please install using guild-deploy.sh with '-s w' option" && return 1
  println ACTION "cardano-hw-cli version"
  HWCLI_version="$(cardano-hw-cli version 2>/dev/null | head -n 1 | cut -d' ' -f6)"
  println LOG "cardano-hw-cli version: ${HWCLI_version}"
  if ! versionCheck "1.14.0" "${HWCLI_version}"; then
    println ERROR "${FG_RED}ERROR${NC}: Vacuumlabs cardano-hw-cli ${FG_LGRAY}v${HWCLI_version}${NC} installed on system, minimum required version is ${FG_GREEN}v1.14.0${NC} !!"
    println ERROR "Please run ${FG_LGRAY}guild-deploy.sh -s w${NC} to upgrade to the latest version."
    return 1
  fi
  return 0
}

# Command     : selectOpMode
# Description : Helper function to choose operational mode
selectOpMode() {
  println OFF "\nOnline mode  -  The default mode to use if all keys are available\n"\
		"Hybrid mode  -  1) Go through steps to build a transaction file"\
		"                2) Copy built tx file to offline computer"\
		"                3) Sign it using 'Sign Tx' with keys on offline computer"\
		"                   (CNTools started in offline mode '-o' without node connection)"\
		"                4) Copy the signed tx file back to online computer and submit using 'Submit Tx'\n"
  select_opt "[o] Online" "[h] Hybrid" "[Esc] Cancel"
  case $? in
    0) op_mode="online" ;;
    1) op_mode="hybrid" ;;
    2) return 1 ;;
  esac
}

# Command     : to_cbor
# Description : converts different majortypes and there values into a cborHexString
# Original src: SPO Scripts (https://github.com/gitmachtl/scripts/blob/master/cardano/testnet/00_common.sh#L979) 
to_cbor() {

  # ${1} type: unsigned, negative, bytes, string, array, map, tag
  # ${2} value: unsigned int value or hexstring for bytes

  local type=${1}
  local value="${2}"

  # majortypes
  #  unsigned      000x|xxxx       majortype 0     not limited, but above 18446744073709551615 (2^64), the numbers are represented via tag2 + bytearray
  #  bytes         010x|xxxx       majortype 2     limited to max. 65535 here
  #  array         100x|xxxx       majortype 4     limited to max. 65535 here
  #  map           101x|xxxx       majortype 5     limited to max. 65535 here
  # extras - not used yet but implemented for the future
  #  negative    001x|xxxx    majortype 1    not limited, but below -18446744073709551616 (-2^64 -1), the numbers are represented via tag3 + bytearray
  #  string    011x|xxxx    majortype 3    limited to max. 65535 chars
  #  tag           110x|xxxx       majortype 6     limited to max. 65535 here

  case ${type} in
    #unsigned - input is an unsigned integer, range is selected via a bc query because bash can't handle big numbers
    unsigned )
      if [[ $(bc <<< "${value} < 24") -eq 1 ]]; then printf -v cbor "%02x" $((10#${value})) #1byte total value below 24
      elif [[ $(bc <<< "${value} < 256") -eq 1 ]]; then printf -v cbor "%04x" $((0x1800 + 10#${value})) #2bytes total: first 0x1800 + 1 lower byte value
      elif [[ $(bc <<< "${value} < 65536") -eq 1 ]]; then printf -v cbor "%06x" $((0x190000 + 10#${value})) #3bytes total: first 0x190000 + 2 lowerbytes value
      elif [[ $(bc <<< "${value} < 4294967296") -eq 1 ]]; then printf -v cbor "%10x" $((0x1A00000000 + 10#${value})) #5bytes total: 0x1A00000000 + 4 lower bytes value
      elif [[ $(bc <<< "${value} < 18446744073709551616") -eq 1 ]]; then local tmp="00$(bc <<< "obase=16;ibase=10;${value}+498062089990157893632")"; cbor="${tmp: -18}" #9bytes total: first 0x1B0000000000000000 + 8 lower bytes value
      #if value does not fit into an 8byte unsigned integer, the cbor representation is tag2(pos.bignum)+bytearray of the value
      else local cbor=$(to_cbor "tag" 2); local tmp="00$(bc <<< "obase=16;ibase=10;${value}")"; tmp=${tmp: -$(( (${#tmp}-1)/2*2 ))}; local cbor+=$(to_cbor "bytes" ${tmp}) #fancy calc to get a leading zero in the hex array if needed
      fi
      ;;
    #bytestring - input is a hexstring
    bytes )
      local bytesLength=$(( ${#value} / 2 ))  #bytesLength is length of value /2 because of hex encoding (2chars -> 1byte)
      if [[ ${bytesLength} -lt 24 ]]; then printf -v cbor "%02x${value}" $((0x40 + 10#${bytesLength})) #1byte total 0x40 + lower part value & bytearrayitself
      elif [[ ${bytesLength} -lt 256 ]]; then printf -v cbor "%04x${value}" $((0x5800 + 10#${bytesLength})) #2bytes total: first 0x4000 + 0x1800 + 1 lower byte value & bytearrayitself
      elif [[ ${bytesLength} -lt 65536 ]]; then printf -v cbor "%06x${value}" $((0x590000 + 10#${bytesLength})) #3bytes total: first 0x400000 + 0x190000 + 2 lower bytes value & bytearrayitself
      fi
      ;;
    #array - input is an unsigned integer
    array )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0x80 + 10#${value})) #1byte total 0x80 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0x9800 + 10#${value})) #2bytes total: first 0x8000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0x990000 + 10#${value})) #3bytes total: first 0x800000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    #map - input is an unsigned integer
    map )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0xA0 + 10#${value})) #1byte total 0xA0 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0xB800 + 10#${value})) #2bytes total: first 0xA000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0xB90000 + 10#${value})) #3bytes total: first 0xA00000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    ###
    ### the following types are not used in these scripts yet, but added to have a more complete function for the future
    ###
    #negative - input is a negative unsigned integer, range is selected via a bc query because bash can't handle big numbers
    negative )
      local value=$(bc <<< "${value//-/} -1") #negative representation in cbor is the neg. number as a pos. number minus 1, so a -500 will be represented as a 499
      if [[ $(bc <<< "${value} < 24") -eq 1 ]]; then printf -v cbor "%02x" $((0x20 + 10#${value})) #1byte total 0x20 value below 24
      elif [[ $(bc <<< "${value} < 256") -eq 1 ]]; then printf -v cbor "%04x" $((0x3800 + 10#${value})) #2bytes total: first 0x2000 + 0x1800 + 1 lower byte value
      elif [[ $(bc <<< "${value} < 65536") -eq 1 ]]; then printf -v cbor "%06x" $((0x390000 + 10#${value})) #3bytes total: first 0x200000 + 0x190000 + 2 lowerbytes value
      elif [[ $(bc <<< "${value} < 4294967296") -eq 1 ]]; then printf -v cbor "%10x" $((0x3A00000000 + 10#${value})) #5bytes total: 0x2000000000 + 0x1A00000000 + 4 lower bytes value
      elif [[ $(bc <<< "${value} < 18446744073709551616") -eq 1 ]]; then local tmp="00$(bc <<< "obase=16;ibase=10;${value}+1088357900348863545344")"; cbor="${tmp: -18}" #9bytes total: first 0x3B0000000000000000 + 8 lower bytes value
      #if value does not fit into an 8byte unsigned integer, the cbor representation is tag3(neg.bignum)+bytearray of the value
      else local cbor=$(to_cbor "tag" 3); local tmp="00$(bc <<< "obase=16;ibase=10;${value}")"; tmp=${tmp: -$(( (${#tmp}-1)/2*2 ))}; local cbor+=$(to_cbor "bytes" ${tmp}) #fancy calc to get a leading zero in the hex array if needed
      fi
      ;;
    #tag - input is an unsigned integer
    tag )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0xC0 + 10#${value})) #1byte total 0xC0 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0xD800 + 10#${value})) #2bytes total: first 0xC000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0xD90000 + 10#${value})) #3bytes total: first 0xC00000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    #textstring - input is a utf8-string
    string )
      local value=$(echo -ne "${value}" | xxd -p -c 65536 | tr -d '\n') #convert the given string into a hexstring and process it further like a bytearray
      local bytesLength=$(( ${#value} / 2 ))  #bytesLength is length of value /2 because of hex encoding (2chars -> 1byte)
      if [[ ${bytesLength} -lt 24 ]]; then printf -v cbor "%02x${value}" $((0x60 + 10#${bytesLength})) #1byte total 0x60 + lower part value & bytearrayitself
      elif [[ ${bytesLength} -lt 256 ]]; then printf -v cbor "%04x${value}" $((0x7800 + 10#${bytesLength})) #2bytes total: first 0x6000 + 0x1800 + 1 lower byte value & bytearrayitself
      elif [[ ${bytesLength} -lt 65536 ]]; then printf -v cbor "%06x${value}" $((0x790000 + 10#${bytesLength})) #3bytes total: first 0x600000 + 0x190000 + 2 lower bytes value & bytearrayitself
      fi
      ;;
  esac
  echo -n "${cbor^^}" #return the cbor in uppercase
}

# Command     : submitPoll
# Description : sign and submit a CIP-0094 poll answer
submitPoll() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"
  POOL_ID_HASH=$(cat ${POOL_FOLDER}/${pool_name}/${POOL_ID_FILENAME})

  if [[ ${CNTOOLS_MODE} = "LIGHT" ]]; then
    for key in ${!assets[@]}; do
      [[ ${key} != "${addr},"* ]] && unset 'assets[$key]'
    done
    utxo_cnt=${utxos_cnt[${addr}]}
    tx_in=${tx_in_arr[${addr}]}
  else
    getBalance ${addr}
  fi

  if ! getTTL; then return 1; fi

  getAssetsTxOut

  metafile_param="--metadata-cbor-file ${cborFile}"
  if [[ -n ${metafile} && -f ${metafile} ]]; then
    metafile_param+=" --json-metadata-no-schema --metadata-json-file ${metafile}"
  fi

  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    ${metafile_param}
    --required-signer-hash "${POOL_ID_HASH}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  calcMinFee "${TMP_DIR}"/tx0.tmp ${utxo_cnt} 1 2 || return 1

  newBalance=$(( lovelace - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough ADA in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${lovelace})${NC} ADA"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} ADA"
    return 1
  fi

  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}" || return 1
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} ADA left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} ADA required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    ${metafile_param}
    --required-signer-hash "${POOL_ID_HASH}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  pay_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_VK_FILENAME}"
  [[ $(jq .description "${pay_vk_file}") = *Hardware* ]] && needHWCLI=true
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Poll Cast"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-title\": \"${poll_title}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-txId\": \"${poll_txId}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-question\": \"${questionString}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-answer\": \"${optionString[${answer}]}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}$(basename ${pool_coldkey_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi

  getWalletType ${wallet_name}
  echo "Transaction Fee: $(formatLovelace ${min_fee}) ADA"
  println "\n# Do you want to publish this answer for pool ${pool_name} on ${NETWORK_NAME}?"
  select_opt "[n] No" "[y] Yes"
  case $? in
   1) if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${pool_coldkey_sk_file}"; then return 1; fi
      if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
      if ! submitTx "${tx_signed}"; then return 1; fi
      println "Poll ${FG_GREEN}${poll_txId}${NC} ballot casted to the network"
      waitToProceed && continue
  esac
}

# Command     : getPriceInfo
# Description : fetch current ADA price from coingecko in selected currency
getPriceInfo() {

  [[ -z ${CURRENCY_URL} ]] && return

  if ! price_info=$(curl -sSL -f -m 3 "${CURRENCY_URL}" 2>&1); then
    logln "ERROR" "${price_info}"
    return
  fi
  if ! jq -e ".cardano.${CURRENCY}" <<< ${price_info} &>/dev/null; then
    logln "ERROR" "invalid currency set, please check config!"
    return
  fi

  price_info_tsv=$(jq -r "[
  .cardano.${CURRENCY} //0,
  .cardano.${CURRENCY}_24h_change //0
  ] | @tsv" <<< "${price_info}")

  read -ra price_info_arr <<< ${price_info_tsv}

  price_now=${price_info_arr[0]}
  price_24h=$(LC_NUMERIC=C printf "%.2f" "${price_info_arr[1]}")
}

# Command     : getPriceString
# Description : construct the ada value price string in set currency from lovelace value
getPriceString() {
  unset price_str
  if [[ -n ${price_now} && $1 -ne 0 ]]; then
    ada_value=$(bc -l <<< "${price_now}*($1/1000000)")
    getDecimalPlaces ${ada_value}
    decimals=$?
    price_str=$(LC_NUMERIC=C printf " (${FG_LBLUE}%s${NC} ${CURRENCY^^})" "$(formatAsset $(LC_NUMERIC=C printf "%.${decimals}f" "${ada_value}"))")
  fi
}
