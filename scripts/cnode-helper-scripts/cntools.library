#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2086,SC2230,SC2206

############################################################
# Variables to keep counter for versions                   #
############################################################
# The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
# and this adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
# Any breaking changes (eg: that requires change of cntools.config, env or a change in priv folder would be considered breaking and will be exempt from auto-update)
CNTOOLS_MAJOR_VERSION=6
# Changes that can be applied without breaking existing functionality that can be applied from within CNTools
CNTOOLS_MINOR_VERSION=2
# Backwards compatible bug fixes. No additional functionality or major changes and can be applied from within CNTools
CNTOOLS_PATCH_VERSION=0
CNTOOLS_VERSION="${CNTOOLS_MAJOR_VERSION}.${CNTOOLS_MINOR_VERSION}.${CNTOOLS_PATCH_VERSION}"

############################################################
# Default config values                                    #
# overriden by values set in cntools.config                #
############################################################
[[ -z ${TMP_FOLDER} ]] && TMP_FOLDER=/tmp/cntools
[[ -z ${TIMEOUT_NO_OF_SLOTS} ]] && TIMEOUT_NO_OF_SLOTS=60
[[ -z ${TIMEOUT_LEDGER_STATE} ]] && TIMEOUT_LEDGER_STATE=300
[[ -z ${VERBOSITY} ]] && VERBOSITY=0
[[ -z ${SHELLEY_TRANS_FILENAME} ]] && SHELLEY_TRANS_FILENAME="${CNODE_HOME}/guild-db/shelley_trans_epoch"
[[ ${SHELLEY_TRANS_FILENAME} =~ ^${CNODE_HOME}/db/ ]] && mkdir -p "${CNODE_HOME}/guild-db" && SHELLEY_TRANS_FILENAME="${CNODE_HOME}/guild-db/shelley_trans_epoch"
[[ -z ${CNTOOLS_LOG} ]] && CNTOOLS_LOG="${CNODE_HOME}/logs/cntools-history.log"
[[ -z ${WALLET_SELECTION_FILTER_LIMIT} ]] && WALLET_SELECTION_FILTER_LIMIT=10
[[ -z ${KES_ALERT_PERIOD} ]] && KES_ALERT_PERIOD=172800 # default 2 days
[[ -z ${KES_WARNING_PERIOD} ]] && KES_WARNING_PERIOD=604800 # default 7 days
[[ -z ${ENABLE_CHATTR} ]] && ENABLE_CHATTR=true
[[ -z ${WALLET_FOLDER} ]] && WALLET_FOLDER="${CNODE_HOME}/priv/wallet"
[[ -z ${POOL_FOLDER} ]] && POOL_FOLDER="${CNODE_HOME}/priv/pool"
[[ -z ${WALLET_PAY_VK_FILENAME} ]] && WALLET_PAY_VK_FILENAME="payment.vkey"
[[ -z ${WALLET_PAY_SK_FILENAME} ]] && WALLET_PAY_SK_FILENAME="payment.skey"
[[ -z ${WALLET_PAY_ADDR_FILENAME} ]] && WALLET_PAY_ADDR_FILENAME="payment.addr"
[[ -z ${WALLET_BASE_ADDR_FILENAME} ]] && WALLET_BASE_ADDR_FILENAME="base.addr"
[[ -z ${WALLET_STAKE_VK_FILENAME} ]] && WALLET_STAKE_VK_FILENAME="stake.vkey"
[[ -z ${WALLET_STAKE_SK_FILENAME} ]] && WALLET_STAKE_SK_FILENAME="stake.skey"
[[ -z ${WALLET_STAKE_ADDR_FILENAME} ]] && WALLET_STAKE_ADDR_FILENAME="reward.addr"
[[ -z ${WALLET_STAKE_CERT_FILENAME} ]] && WALLET_STAKE_CERT_FILENAME="stake.cert"
[[ -z ${WALLET_STAKE_DEREG_FILENAME} ]] && WALLET_STAKE_DEREG_FILENAME="stake.dereg"
[[ -z ${WALLET_DELEGCERT_FILENAME} ]] && WALLET_DELEGCERT_FILENAME="delegation.cert"
[[ -z ${POOL_ID_FILENAME} ]] && POOL_ID_FILENAME="pool.id"
[[ -z ${POOL_HOTKEY_VK_FILENAME} ]] && POOL_HOTKEY_VK_FILENAME="hot.vkey"
[[ -z ${POOL_HOTKEY_SK_FILENAME} ]] && POOL_HOTKEY_SK_FILENAME="hot.skey"
[[ -z ${POOL_COLDKEY_VK_FILENAME} ]] && POOL_COLDKEY_VK_FILENAME="cold.vkey"
[[ -z ${POOL_COLDKEY_SK_FILENAME} ]] && POOL_COLDKEY_SK_FILENAME="cold.skey"
[[ -z ${POOL_OPCERT_COUNTER_FILENAME} ]] && POOL_OPCERT_COUNTER_FILENAME="cold.counter"
[[ -z ${POOL_OPCERT_FILENAME} ]] && POOL_OPCERT_FILENAME="op.cert"
[[ -z ${POOL_VRF_VK_FILENAME} ]] && POOL_VRF_VK_FILENAME="vrf.vkey"
[[ -z ${POOL_VRF_SK_FILENAME} ]] && POOL_VRF_SK_FILENAME="vrf.skey"
[[ -z ${POOL_CONFIG_FILENAME} ]] && POOL_CONFIG_FILENAME="pool.config"
[[ -z ${POOL_REGCERT_FILENAME} ]] && POOL_REGCERT_FILENAME="pool.cert"
[[ -z ${POOL_CURRENT_KES_START} ]] && POOL_CURRENT_KES_START="kes.start"
[[ -z ${POOL_DEREGCERT_FILENAME} ]] && POOL_DEREGCERT_FILENAME="pool.dereg"

############################################################
# library sourced by cntools with common taskes to perform #
############################################################

# Assumes that env has been sourced by calling script

# Command    : log [message]
# Description: Log message to file if activated in config
#              message is NOT outputed to STDOUT
# Parameters : message   >   The message
# Return     : null
# Examples of Usage:
#   >> log "Some log message"
log() {
  if [[ "${CNTOOLS_LOG}" != "" ]]; then
    message=$(echo $1 | sed -E 's/\\e\[[0-9;]{1,6}m/ ~~~ /g')
    echo "$(date "+%Y-%m-%dT%H:%M:%S%Z") : $message" >> ${CNTOOLS_LOG}
  fi
}


# Command    : waitForInput [optional: message]
# Description: wait for user keypress to continue
waitForInput() {
  ESC=$(printf "\033")
  local row=$(get_cursor_row)
  say ""
  if [[ -z $1 ]]; then
    message="press any key to return to home menu"
  else
    message="$1"
  fi
  read -rsn1 -p "${message}" key # get 1 character
  if [[ $key == $ESC ]]; then
    read -rsn2 key # read 2 more chars
  fi
  cursor_to ${row}
  tput ed
}


# Command    : say [message] [optional: verbosity] [optional: log]
# Description: Print message
# Parameters : message   >   The message
# Parameters : verbosity >   OPTIONAL: Output verbosity [0-2], see config file for details (default: 0)
# Parameters : log       >   OPTIONAL: The string 'log' to log message (default: no logging)
# Return     : message on STDOUT
# Examples of Usage:
#   >> say "Some message" 1 "log"
say() {
  if [[ -z $2 || $2 = "log" || $2 -le ${VERBOSITY} ]]; then
    echo -e "$1"
  fi
  if [[ $2 = "log" || $3 = "log" ]]; then
    log "$1"
  fi
}


# Command    : need_cmd [command]
# Description: Check if command is available, else print error
# Parameters : command   >   The command to check
# Return     : null
# Examples of Usage:
#   >> need_cmd "jq"
need_cmd() {
  if ! command -v "$1" > /dev/null 2>&1; then
    need_cmd_error="${FG_RED}ERROR${NC}: need '$1' (command not found)\ntry 'sudo apt install $1'\nplease install with your packet manager of choice(apt/yum etc..) and relaunch CNTools"
    waitForInput "press any key"
    return 1
  fi
}


# Command    : protectionPreRequisites
# Description: Check if needed protection prerequisites is available, else print error
# Parameters : null
# Return     : 1 on error
# Examples of Usage:
#   >> protectionPreRequisites
protectionPreRequisites() {
  if ! need_cmd "gpg" || \
     ! need_cmd "systemd-ask-password"; then
    return 1
  fi

  if ! need_cmd "chattr"; then 
    [[ ${ENABLE_CHATTR} = true ]] && say "chattr command not available but enabled in config, please disable in cntools.config and re-run CNTools" && return 1
  elif [[ ${ENABLE_CHATTR} = true ]]; then # chattr available and enabled, make sure sudo access to chattr is enabled
    touch "${TMP_FOLDER}"/test
    if ! sudo -n chattr -i "${TMP_FOLDER}"/test 2>&1; then
      rm -f "${TMP_FOLDER}"/test
      say ""
      say "${FG_YELLOW}WARN${NC}: Elevated privileges needed for chattr command used to write protect wallet and pool keys"
      say "Run the following command to add passwordless sudo access to chattr command for '$(whoami)' user"
      say ""
      say "echo \"$(whoami) ALL=NOPASSWD: $(command -v chattr)\" | sudo tee /etc/sudoers.d/cntools"
      waitForInput "press any key"
      return 1
    fi
    rm -f "${TMP_FOLDER}"/test
  fi
}

# Command    : safeDel [path]
# Description: unlock and use secure delete (srm) if available to delete file|dir
# Note       : srm mainly effective for traditional magnetic HDDs and non copy-on-write or journal file systems
safeDel() {
  path=$1
  [[ ${ENABLE_CHATTR} = true && -f "${path}" && $(lsattr -R "${path}") =~ -i- ]] && sudo chattr -i "${path}"
  command -v "srm" > /dev/null 2>&1 && delcommand='srm' || delcommand='rm'
  if "${delcommand}" -rf "${path}"; then
    say "Deleted: ${path}" "log"
  else
    say "${FG_RED}ERROR${NC}: delete failed for ${path}" 1>&2
    return 1
  fi
}


dialogSetup() {
  export DIALOGRC="${TMP_FOLDER}"/.dialogrc
  [[ ! -f ${DIALOGRC} ]] && cat << EOF > "${TMP_FOLDER}"/.dialogrc
# Types of values:
#
# Number     -  <number>
# String     -  "string"
# Boolean    -  <ON|OFF>
# Attribute  -  (foreground,background,highlight?)
# Set aspect-ration.
aspect = 0
# Set separator (for multiple widgets output).
separate_widget = ""
# Set tab-length (for textbox tab-conversion).
tab_len = 0
# Make tab-traversal for checklist, etc., include the list.
visit_items = OFF
# Shadow dialog boxes? This also turns on color.
use_shadow = OFF
# Turn color support ON or OFF
use_colors = OFF
# Screen color
screen_color = (BLACK,BLACK,OFF)
# Shadow color
shadow_color = (BLACK,BLACK,ON)
# Dialog box color
dialog_color = (BLACK,BLACK,OFF)
# Dialog box title color
title_color = (RED,BLACK,ON)
# Dialog box border color
border_color = (BLACK,BLACK,OFF)
# Active button color
button_active_color = (WHITE,BLACK,ON)
# Inactive button color
button_inactive_color = (BLACK,WHITE,OFF)
# Active button key color
button_key_active_color = button_active_color
# Inactive button key color
button_key_inactive_color = (RED,BLACK,OFF)
# Active button label color
button_label_active_color = (YELLOW,BLACK,OFF)
# Inactive button label color
button_label_inactive_color = (BLACK,WHITE,ON)
# Input box color
inputbox_color = button_inactive_color
# Input box border color
inputbox_border_color = button_inactive_color
# Item color
item_color = button_inactive_color
# Selected item color
item_selected_color = button_active_color
# Dialog box border2 color
border2_color = button_inactive_color
# Input box border2 color
inputbox_border2_color = button_inactive_color
EOF
}

# Command    : fileDialog [show help: 0=no|1=yes] [dialog title] [optional: start dir]
# Description: open a file dialog
fileDialog() {
  dialogSetup
  local firstrow=$(get_cursor_row)
  [[ -n $3 ]] && start_path="$3/" || start_path="/tmp/"
  if [[ $1 -eq 1 ]]; then
    say "\nFile Explorer:"
    say "  Tab        -  Select area to navigate"
    say "  Arrow keys -  Move up/down"
    say "  Space      -  Append the currently-selected item into the work-area"
    say "  Enter      -  OK and exit by default if not Cancel is selected"
  fi
  waitForInput "Press any key to open the file explorer"
  file=$(dialog --stdout --clear --keep-tite --title "$2" --fselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)))
  cursor_to ${firstrow}
  tput ed
}
# Command    : dirDialog [show help: 0=no|1=yes] [dialog title] [optional: start dir]
# Description: open a directory dialog
dirDialog() {
  dialogSetup
  local firstrow=$(get_cursor_row)
  [[ -n $3 ]] && start_path="$3/" || start_path="/tmp/"
  if [[ $1 -eq 1 ]]; then
    say "\nDirectory Explorer:"
    say "  Tab        -  Select area to navigate"
    say "  Arrow keys -  Move up/down"
    say "  Space      -  Append the currently-selected item into the work-area"
    say "  Enter      -  OK and exit by default if not Cancel is selected"
  fi
  waitForInput "Press any key to open the directory explorer"
  dir=$(dialog --stdout --clear --keep-tite --title "$2" --dselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)))
  cursor_to ${firstrow}
  tput ed
}


# Command    : selectOption [opt1] [opt2] ...
#
# Description: Create a bash menu to select one of the provided options
# Parameters : optX    >   a list of available options to choose from
# Return     : index of selected option
# Examples of Usage:
#   >> selectOption MyWallet1 MyWallet2 Cancel
#
# little helpers for terminal print control and key input
ESC=$(printf "\033")
cursor_blink_on()  { printf "$ESC[?25h"; }
cursor_blink_off() { printf "$ESC[?25l"; }
cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
print_option()     { printf "  $1 "; }
print_selected()   { printf " $ESC[7m $1 $ESC[27m$2"; }
get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
key_input()        { key2=""
                     read -rsn1 key1   # get 1 character
                     if [[ $key1 == $ESC ]]; then
                       read -rsn2 -t 0.3 key2 # read 2 more chars, 1s timeout
                     fi
                       if [[ $key2 = "[A" ]]; then echo up;
                     elif [[ $key2 = "[B" ]]; then echo down;
                     elif [[ $key1 = $ESC && $key2 = "" ]]; then echo Esc;
                     elif [[ $key1 = ""   ]]; then echo enter;
                     else echo $key1; fi; }
opt_shortcut()     { [[ "$1" =~ ^\[([[:alnum:]]+)\].* ]] && echo ${BASH_REMATCH[1]}; }
opt_firstchar()    { printf "${1:0:1}" | tr '[:upper:]' '[:lower:]'; }

selectOption() {  
  # initially print empty new lines (scroll down if at bottom of screen)
  printf "\n" && for opt; do printf "\n"; done

  # determine current screen position for overwriting the options
  local lastrow=$(get_cursor_row)
  local startrow=$(($lastrow - $# - 1))

  cursor_blink_off

  local shortcut_found="no"
  local selected=0
  while true; do
    # print options by overwriting the last lines
    local idx=0
    for opt; do
      opt_part2=""
      if [[ "$opt" =~ ^(.*)[[:space:]](\(.*) ]]; then
        opt_part1="${BASH_REMATCH[1]}"
        opt_part2=" ${BASH_REMATCH[2]}"
      else
        opt_part1="$opt"
      fi
      cursor_to $(($startrow + $idx))
      if [ $idx -eq $selected ]; then
        print_selected "$opt_part1" "$opt_part2"
      else
        print_option "$opt_part1$opt_part2"
      fi
      ((idx++))
    done

    [[ "${shortcut_found}" = "yes" ]] && break

    # user key control
    key_pressed=$(key_input)
    case ${key_pressed} in
      enter) break;;
      up)    ((selected--));
             if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
      down)  ((selected++));
             if [ $selected -ge $# ]; then selected=0; fi;;
      *)     # shortcut available for selected key?
             i=0
             for opt; do
               [[ ${key_pressed} = $(opt_shortcut "$opt") ]] && selected=${i} && shortcut_found="yes" && break
               ((i++))
             done
             # If no shortcut is found, lets see if it matches the first char of any of the options
             j=0
             for opt; do
               [[ "${shortcut_found}" != "yes" && ${key_pressed} = $(opt_firstchar "$opt") ]] && selected=${j} && break
               ((j++))
             done
             ;;
    esac
  done

  # clear menu
  cursor_to $startrow
  tput ed
  cursor_blink_on

  return $selected
}

function select_opt {
  local opts=( "$@" )
  selectOption "${opts[@]}" 1>&2
  local answer=$?
  say "Selected value: ${opts[${answer}]}"
  return $answer
}

# Command    : validIP [IP address]
# Description: A helper function to validate input for valid IPv4 address
# Parameters : IP address    >   the IPv4 address to validate
# Return     : 1 on success
# Examples of Usage:
#   >> validIP 123.123.123.123
#
function validIP()
{
  local  ip=$1
  local  stat=1

  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    OIFS=$IFS
    IFS='.'
    ip=($ip)
    IFS=$OIFS
    [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
    stat=$?
  fi
  return $stat
}


# Command    : getDirs [path to folder]
# Description: A helper function to get all subdirs for a directory
# Parameters : path to folder    >   full path to folder, subdirs of this folder returned
# Return     : populates ${dirs} array
# Examples of Usage:
#   >> getDirs /opt/cardano/cnode/priv/wallet
#
function getDirs {
  if [[ ! -d "$1" ]]; then
    say "${FG_RED}ERROR${NC}: Missing folder: $1" 0
    waitForInput && return 1
  fi
  dirs=()
  while IFS= read -r -d '' dir; do
    dirs+=("$(basename ${dir})")
  done < <(find "${1}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
  return 0
}

# Command    : selectDir [dir1 dir2 ...]
# Description: A helper function to selectOption() specifically for directory selection
# Parameters : array of dirs    >   array of dirs to include in selection, '[Esc] Cancel' option added to all selections
# Return     : populates ${dir_name} variable,
# Examples of Usage:
#   >> selectDir Wallet1 Wallet2 Wallet3
#
function selectDir {
  local type=$1 && shift
  dirs=("$@")
  dirs+=("[Esc] Cancel")
  selectOption "${dirs[@]}" 1>&2
  dir_name=${dirs[$?]}
  [[ "${dir_name}" = "[Esc] Cancel" ]] && return 1
  say "Selected ${type}: ${dir_name}"
}

# Command    : selectWallet [mode] [file1 file2 ...]
# Description: A helper function to selecrt a CNTools wallet
# Parameters : mode            >  a string containing some of the following: none|non-reg|reg|balance|delegate|reward
#                                 to be added next to wallet in selection menu
#              array of files  >  array of files required to exist in wallet folder for it to be selectable
# Return     : populates ${wallet_name} variable,
# Examples of Usage:
#   >> selectWallet wallet/MyWallet/payment.skey
#
function selectWallet {
  wallet_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${WALLET_FOLDER}"; then return 1; fi # dirs() array populated with all wallet folders
  if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" ]]; then
    wallet_count=${#dirs[@]}
    [[ ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]] && tput sc && say "Balance checking wallets..."
  fi
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if wallet is missing a required file and if so hide it
      [[ -f "${WALLET_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${WALLET_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" && ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then
      if [[ ${mode} = "non-reg" ]]; then
        if isWalletRegistered ${dir}; then continue; fi
      elif [[ ${mode} = "reg" ]]; then
        if ! isWalletRegistered ${dir}; then continue; fi
      fi
      if [[ ${mode} = "balance" || ${mode} = "non-reg" || ${mode} = "reg" ]]; then
        getBaseAddress ${dir}
        getPayAddress ${dir}
        getBalance ${base_addr}
        base_lovelace=${lovelace}
        getBalance ${pay_addr}
        pay_lovelace=${lovelace}
        if [[ ${base_lovelace} -gt 0 && ${pay_lovelace} -gt 0 ]]; then
          wallet_dirs+=("${dir} (Funds: ${FG_CYAN}$(formatLovelace ${base_lovelace})${NC} ADA | Enterprise Funds: ${FG_CYAN}$(formatLovelace ${pay_lovelace})${NC} ADA)")
        elif [[ ${pay_lovelace} -gt 0 ]]; then
          wallet_dirs+=("${dir} (Enterprise Funds: ${FG_CYAN}$(formatLovelace ${pay_lovelace})${NC} ADA)")
        else
          wallet_dirs+=("${dir} (Funds: ${FG_CYAN}$(formatLovelace ${base_lovelace})${NC} ADA)")
        fi
      elif [[ ${mode} = "delegate" ]]; then
        getBaseAddress ${dir}
        getBalance ${base_addr}
        if getRewardAddress ${dir}; then
          delegation_pool_id=$(${CCLI} shelley query stake-address-info ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address "${reward_addr}" | jq -r '.[0].delegation // empty')
          unset poolName
          if [[ -n ${delegation_pool_id} ]]; then
            while IFS= read -r -d '' pool; do
              getPoolID "$(basename ${pool})"
              if [[ "${pool_id_bech32}" = "${delegation_pool_id}" ]]; then
                poolName=$(basename ${pool}) && break
              fi
            done < <(find "${POOL_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
          fi
          if [[ -n ${poolName} ]]; then
            wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} ADA - ${FG_RED}delegated${NC} to ${FG_BLUE}${poolName}${NC})")
          elif [[ -n ${delegation_pool_id} ]]; then
            wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} ADA - ${FG_RED}delegated${NC} to external address)")
          else
            wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} ADA)")
          fi
        else
          wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} ADA)")
        fi
      elif [[ ${mode} = "reward" ]]; then
        getRewards ${dir}
        [[ ${reward_lovelace} -le 0 ]] && continue
        wallet_dirs+=("${dir} (Rewards: ${FG_CYAN}$(formatLovelace ${reward_lovelace})${NC} ADA)")
      fi
    else
      wallet_dirs+=("${dir}")
    fi
  done
  if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" ]]; then tput rc && tput ed; fi
  if [[ ${#wallet_dirs[@]} -eq 0 ]]; then
    if [[ ${mode} = "balance" ]]; then
      say "${FG_YELLOW}WARN${NC}: No wallets with funds available for selection!"
    elif [[ ${mode} = "delegate" ]]; then
      say "${FG_YELLOW}WARN${NC}: No wallets available that can be delegated or used as pool pledge/owner/reward wallet!"
    elif [[ ${mode} = "reward" ]]; then
      say "${FG_YELLOW}WARN${NC}: No wallets available that have rewards to withdraw!"
    else
      say "${FG_YELLOW}WARN${NC}: No wallets available for selection!"
    fi
    [[ ${enc_req_files} -gt 0 ]] && say "Encrypted wallets not listed, please decrypt wallet first if encrypted"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && say "${FG_YELLOW}encrypted wallets found but NOT listed, please decrypt to select${NC}"
  if ! selectDir "wallet" "${wallet_dirs[@]}"; then return 1; fi # ${dir_name} populated by selectDir function
  wallet_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command    : selectPool [mode] [file1 file2 ...]
# Description: A helper function to selecrt a CNTools pool
# Parameters : mode            >  a string containing some of the following: reg|non-reg
#              array of files  >  array of files required to exist in pool folder for it to be selectable
# Return     : populates ${pool_name} variable,
# Examples of Usage:
#   >> selectPool pool/MyPool/cold.skey
#
function selectPool {
  pool_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${POOL_FOLDER}"; then return 1; fi # dirs() array populated with all pool folders
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if pool is missing a required file and if so hide it
      [[ -f "${POOL_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${POOL_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "non-reg" ]]; then
      [[ -f "${POOL_FOLDER}/${dir}/${POOL_REGCERT_FILENAME}" ]] && continue
    elif [[ ${mode} = "reg" ]]; then
      [[ ! -f "${POOL_FOLDER}/${dir}/${POOL_REGCERT_FILENAME}" ]] && continue
    fi
    pool_dirs+=("${dir}")
  done
  if [[ ${#pool_dirs[@]} -eq 0 ]]; then
    say "${FG_YELLOW}WARN${NC}: No pools available that can be selected!"
    [[ ${enc_req_files} -gt 0 ]] && say "* Encrypted pools not listed *"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && say "${FG_YELLOW}encrypted pools found but NOT listed, please decrypt to show${NC}"
  if ! selectDir "pool" "${pool_dirs[@]}"; then return 1; fi # ${dir_name} populated by selectDir function
  pool_name="${dir_name}"
}


# Command    : getPassword [optional:confirm]
# Description: Get password from user on STDIN
# Parameters : confirm   >   Optional parameter, force user provide password twise to confirm
# Return     : populates $password variable, make sure to unset variable when done
# Examples of Usage:
#   >> local userPassword=$(getPassword confirm)
getPassword() {
  while true; do
    say "Enter key password (length >= 8)"
    password=$(systemd-ask-password "Password:")
    if [ ${#password} -lt 8 ]; then
      say ""
      say "${FG_RED}ERROR${NC}: password length too short, please use a minimum of 8 characters."
      say ""
      read -r -n 1 -s -p "Press q to abort or any other key to retry" abort
      [[ ${abort} = "q" ]] && unset password && return 1
      say "\n"
      continue
    fi
    if [[ "$1" = "confirm" ]]; then
      local checkPassword=$(systemd-ask-password "Confirm: ")
      if [[ "${password}" != "${checkPassword}" ]]; then
        say ""
        say "${FG_RED}ERROR${NC}: password missmatch!"
        say ""
        read -r -n 1 -s -p "Press q to abort or any other key to retry" abort
        [[ ${abort} = "q" ]] && unset password && return 1
        say "\n"
      else
        say "" && return
      fi
    else
      say "" && return
    fi
  done
}


# Command    : encryptFile [file] [password]
# Description: Encrypt file with GPG
# Parameters : file       >   Path for file to encrypt
#                             will get a new .gpg file extention added to filename
#              password   >   Password to encrypt file with
# Return     : null on successful execution
# Examples of Usage:
#   >> encryptFile "$CNODE_HOME/priv/wallet/MyWallet/SigningKeyShelley.skey"
encryptFile() {
  echo "${2}" | gpg --symmetric --yes --batch --cipher-algo AES256 --passphrase-fd 0 --output "${1}.gpg" "${1}" >/dev/null && \
  safeDel "${1}" >/dev/null || {
    say "${FG_RED}ERROR${NC}: failed to encrypt ${1}"
    return 1
  }
  say "${1} successfully encrypted" "log"
}


# Command    : decryptFile [file] [password]
# Description: Decrypt file with GPG
# Parameters : file       >   Path for file to decrypt
#                             file extension .gpg required
#              password   >   Password to decrypt file with
# Return     : null on successful execution
# Examples of Usage:
#   >> decryptFile "$CNODE_HOME/priv/wallet/MyWallet/SigningKeyShelley.skey"
decryptFile() {
  echo "${2}" | gpg --decrypt --batch --yes --passphrase-fd 0 --output "${1%.*}" "${1}" >/dev/null && \
  rm -f "${1}" || {
    say "${FG_RED}ERROR${NC}: failed to decrypt ${1}"
    return 1
  }
  say "${1} successfully decrypted" "log"
}


# Command    : getNodeMetrics
# Description: Get latest metrics from the node
# Return     : populates ${node_metrics} variable
getNodeMetrics() {
  node_metrics=$(curl -s -m ${EKG_TIMEOUT} -H 'Accept: application/json' "http://${EKG_HOST}:${EKG_PORT}/" 2>/dev/null)
}

# Command    : getBlockTip
# Description: Get latest block number
# Return     : string with tip on STDOUT
getBlockTip() {
  getNodeMetrics
  jq '.cardano.node.ChainDB.metrics.blockNum.int.val //0' <<< "${node_metrics}"
}
# Command    : getSlotTip
# Description: Get latest slot number
# Return     : string with tip on STDOUT
getSlotTip() {
  getNodeMetrics
  jq '.cardano.node.ChainDB.metrics.slotNum.int.val //0' <<< "${node_metrics}"
}
# Command    : getSlotTipRef
# Description: Offline calculation of reference tip
# Return     : string with tip on STDOUT
getSlotTipRef() {
  current_time_sec=$(date -u +%s)
  if [[ "${PROTOCOL_IDENTIFIER}" = "--cardano-mode" ]]; then
    # Combinator network
    byron_slots=$(( $(cat $SHELLEY_TRANS_FILENAME) * BYRON_EPOCH_LENGTH )) # since this point will only be reached once we're in Shelley phase
    byron_end_time=$(( BYRON_GENESIS_START_SEC + ( $(cat $SHELLEY_TRANS_FILENAME) * BYRON_EPOCH_LENGTH * BYRON_SLOT_LENGTH ) ))
    if [[ "${current_time_sec}" -lt "${byron_end_time}" ]]; then
      # In Byron phase
      echo $(( ( current_time_sec - BYRON_GENESIS_START_SEC ) / BYRON_SLOT_LENGTH ))
    else
      # In Shelley phase
      echo $(( byron_slots + (( current_time_sec - byron_end_time ) / SLOT_LENGTH ) ))
    fi
  else
    # Shelley Mode only, no Byron slots
    echo $(( ( current_time_sec - SHELLEY_GENESIS_START_SEC ) / SLOT_LENGTH ))
  fi
}
# Command    : getSlotTipDiff
# Description: Get difference between current node slot tip and calculated tip based on genesis file
# Return     : diff on STDOUT
getSlotTipDiff() {
  tip_ref=$(getSlotTipRef)
  tip_node=$(getSlotTip)
  echo $(( tip_ref - tip_node ))
}

# Command    : slotInterval
# Description: Calculate expected interval between blocks
slotInterval() {
  [[ $(echo "${DECENTRALISATION} < 0.5" | bc) -eq 1 ]] && local d=0.5 || local d=${DECENTRALISATION}
  echo "(${SLOT_LENGTH} / ${ACTIVE_SLOTS_COEFF} / ${d}) + 0.5" | bc -l | awk '{printf "%.0f\n", $1}'
}

# Command    : getEpoch
# Description: Offline calculation of current epoch based on genesis file
# Return     : current epoch on STDOUT
getEpoch() {
  current_time_sec=$(date -u +%s)
  if [[ "${PROTOCOL_IDENTIFIER}" == "--cardano-mode" ]]; then
    byron_end_time=$(( BYRON_GENESIS_START_SEC + ( $(cat $SHELLEY_TRANS_FILENAME) * BYRON_EPOCH_LENGTH * BYRON_SLOT_LENGTH ) ))
    echo $(( $(cat $SHELLEY_TRANS_FILENAME) + ( (current_time_sec - byron_end_time) / SLOT_LENGTH / EPOCH_LENGTH ) ))
  else
    echo $(( (current_time_sec - SHELLEY_GENESIS_START_SEC) / SLOT_LENGTH / EPOCH_LENGTH ))
  fi
}
# Command    : getTimeUntilNextEpoch
# Description: Offline calculation of time until next epoch
# Return     : time left in hh:mm:ss
timeUntilNextEpoch() {
  current_epoch=$(getEpoch)
  current_time_sec=$(date -u +%s)
  if [[ "${PROTOCOL_IDENTIFIER}" = "--cardano-mode" ]]; then
    showTimeLeft $(( ($(cat $SHELLEY_TRANS_FILENAME) * BYRON_SLOT_LENGTH * BYRON_EPOCH_LENGTH) + ( ( current_epoch + 1 - $(cat $SHELLEY_TRANS_FILENAME) ) * SLOT_LENGTH * EPOCH_LENGTH ) - current_time_sec + BYRON_GENESIS_START_SEC ))
  else
    showTimeLeft $(( ( ( ( (current_time_sec - SHELLEY_GENESIS_START_SEC) / SLOT_LENGTH / EPOCH_LENGTH ) + 1 ) * SLOT_LENGTH * EPOCH_LENGTH ) - current_time_sec + SHELLEY_GENESIS_START_SEC ))
  fi
}

# Command    : getCurrentKESperiod
# Description: Offline calculation of current KES period based on reference tip
getCurrentKESperiod() {
  tip_ref=$(getSlotTipRef)
  current_kes_period=$(( tip_ref / SLOTS_PER_KES_PERIOD ))
}

# Command    : kesExpiration [Pool KES start period]
#
# Description: Calculate KES expiration
# Parameters : Pool KES start period    >   KES start stored in POOL_CURRENT_KES_START file for pool in question
# Return     : expiration date can be accessed through variable ${expiration_date} after function has been executed
kesExpiration() {
  if [[ -z "${1##*[!0-9]*}" ]]; then
    say "${FG_RED}ERROR${NC}: KES start period must be an integer number [$1]"
    return 1
  fi
  pool_kes_start_period=$1
  getCurrentKESperiod
  remaining_kes_periods=$(( MAX_KES_EVOLUTIONS - ( current_kes_period - pool_kes_start_period ) ))
  current_time_sec=$(date -u +%s)
  expiration_time_sec=$(( current_time_sec - ( SLOT_LENGTH * (tip_ref % SLOTS_PER_KES_PERIOD) ) + ( SLOT_LENGTH * SLOTS_PER_KES_PERIOD * remaining_kes_periods ) ))
  expiration_time_sec_diff=$(( expiration_time_sec - current_time_sec ))
  expiration_date=$(date '+%F %T Z' --date=@${expiration_time_sec})
}

showTimeLeft() {
  if [[ -z "${1##*[!0-9]*}" ]]; then
    say "${FG_RED}ERROR${NC}: time must be an integer number [$1]"
    return 1
  fi
  printf '%02dh:%02dm:%02ds\n' $(($1/3600)) $(($1%3600/60)) $(($1%60))
}


# Command    : waitNewBlockCreated
# Description: Wait for a new block to be created
# Return     : prints progress on STDOUT
waitNewBlockCreated() {
  counter=${TIMEOUT_NO_OF_SLOTS}
  say "Waiting for new block to be created (timeout = ${counter} slots, $(( counter * SLOT_LENGTH ))s)" 1 "log"
  say "${FG_BLUE}INFO${NC}: press any key to cancel balance check and return"
  initialTip=$(getBlockTip)
  actualTip=${initialTip}

  while [ "${actualTip}" = "${initialTip}" ]; do
    read -r -n 1 -s -t ${SLOT_LENGTH} -p "" abort
    if [[ $? -eq 0 ]]; then
      say "${FG_BLUE}INFO${NC}: Balance check aborted!"
      return 1
    fi
    actualTip=$(getBlockTip)
    counter=$((counter - SLOT_LENGTH))
    if [ ${counter} -lt ${SLOT_LENGTH} ]; then
      say "${FG_YELLOW}WARN${NC}: waited $(( TIMEOUT_NO_OF_SLOTS * SLOT_LENGTH )) secs and no new block created"
      return 1
    fi
  done
  say "New block was created - ${actualTip}" 1 "log"
}


# Command    : validateDecimalNbr [decimalNbr]
# Description: validate decimal number
# Parameters : decimalNbr   >   decimal number
# Return     : 0 on success, else 1
# Examples of Usage:
#   >> validateDecimalNbr 100.5
validateDecimalNbr() {
  re_decimal_nbr='^[0-9]+([.][0-9]+)?$'
  if [[ $1 =~ ${re_decimal_nbr} ]]; then
    return 0
  else
    return 1
  fi
}

# Command    : formatLovelace
# Description: Pretty print Lovelace value using locales
# Parameters : Lovelace  >  Amount in Lovelace
# Return     : Formatted string (warning: the string can contain unicode characters in some locales)
formatLovelace() {
  re_int_nbr='^[0-9]+$'
  if [[ $1 =~ ${re_int_nbr} ]]; then
    printf "%'.6f" ${1}e-6
  else
    say "${FG_RED}ERROR${NC}: must be a valid integer number"
    return 1
  fi
}

# Command    : ADAtoLovelace [ADA]
# Description: Convert number in ADA to Lovelace
# Parameters : ADA   >   Amount in ADA, decimal number accepted
# Return     : Lovelace on STDOUT
# Examples of Usage:
#   >> ADAtoLovelace 100.5
ADAtoLovelace() {
  if validateDecimalNbr $1; then
    echo "$1 * 1000000 / 1" | bc # /1 is to remove decimals from bc command
  else
    say "${FG_RED}ERROR${NC}: must be a valid integer or decimal number"
    return 1
  fi
}

# Command    : pctToFraction [percent]
# Description: Convert number as percent to fraction
# Parameters : percent   >   number to be converted in range 0-100
# Return     : fraction number on STDOUT
# Examples of Usage:
#   >> pctToFraction 7.5
pctToFraction() {
  if validateDecimalNbr $1; then
    if [[ $(bc <<< "$1 >= 0" ) -eq 0 || $(bc <<< "$1 <= 100" ) -eq 0 ]]; then
      say "${FG_RED}ERROR${NC}: must be a number between 0-100"
      return 1
    else
      echo "x=$1 / 100; if(x<1) print 0; x" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
    fi
  else
    say "${FG_RED}ERROR${NC}: must be a valid integer or decimal number"
    return 1
  fi
}

# Command    : fractionToPCT [fraction]
# Description: Convert fraction number to precent
# Parameters : fraction   >   number to be converted
# Return     : number as percentage on STDOUT
# Examples of Usage:
#   >> fractionToPCT 0.015
fractionToPCT() {
  if validateDecimalNbr $1; then
    if (( $(bc <<<"$1 > 0") )); then
      echo "x=$1 * 100; if(x<1) print 0; x" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
    else
      echo 0
    fi
  else
    say "${FG_RED}ERROR${NC}: must be a valid decimal number"
    return 1
  fi
}


# Command    : getPoolID [pool name]
# Description: create and save pool id in hex & bech32 encoded format
# Return     : populates $pool_id & $pool_id_bech32
getPoolID() {
  pool_id_file="${POOL_FOLDER}/${1}/${POOL_ID_FILENAME}"
  pool_id=""
  pool_id_bech32_file="${POOL_FOLDER}/${1}/${POOL_ID_FILENAME}-bech32"
  pool_id_bech32=""
  pool_coldkey_vk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}"
  if [[ -f ${pool_coldkey_vk_file} ]]; then
    if ! pool_id=$(${CCLI} shelley stake-pool id --verification-key-file "${pool_coldkey_vk_file}" --output-format hex 2>/dev/null) || \
       ! pool_id_bech32=$(${CCLI} shelley stake-pool id --verification-key-file "${pool_coldkey_vk_file}" 2>/dev/null); then
      if ! pool_id=$(${CCLI} shelley stake-pool id --cold-verification-key-file "${pool_coldkey_vk_file}" --output-format hex 2>/dev/null) || \
         ! pool_id_bech32=$(${CCLI} shelley stake-pool id --cold-verification-key-file "${pool_coldkey_vk_file}" 2>/dev/null); then
        return 1
      fi
    fi
    echo ${pool_id} > "${pool_id_file}"
    echo ${pool_id_bech32} > "${pool_id_bech32_file}"
    return 0
  fi
  [[ -f ${pool_id_file} ]] && pool_id=$(cat ${pool_id_file})
  [[ -f ${pool_id_bech32_file} ]] && pool_id_bech32=$(cat ${pool_id_bech32_file})
}


# Command    : getPayAddress [wallet name]
# Description: create and save payment address
# Return     : populates $pay_addr
getPayAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_addr_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_ADDR_FILENAME}"
  if [[ -f "${payment_vk_file}" ]]; then
    if ${CCLI} shelley address build --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      pay_addr=$(cat "${payment_addr_file}")
      return 0
    fi
  fi
  pay_addr=""
  return 1
}

# Command    : getBaseAddress [wallet name]
# Description: create, store and save base address
# Return     : populates $base_addr
getBaseAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  base_addr_file="${WALLET_FOLDER}/${1}/${WALLET_BASE_ADDR_FILENAME}"
  if [[ -f "${payment_vk_file}" && -f "${stake_vk_file}" ]]; then
    if ${CCLI} shelley address build --payment-verification-key-file "${payment_vk_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      base_addr=$(cat "${base_addr_file}")
      return 0
    fi
  fi
  base_addr=""
  return 1
}

# Command    : getRewardAddress [wallet name]
# Description: create, store and save reward address
# Return     : populates $reward_addr
getRewardAddress() {
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_addr_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_ADDR_FILENAME}"
  if [[ -f "${stake_vk_file}" ]]; then
    if ${CCLI} shelley stake-address build --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      reward_addr=$(cat "${stake_addr_file}")
      return 0
    fi
  fi
  reward_addr=""
  return 1
}

# Command    : getAddressInfo [address]
# Description: get address info from from node
# Return     : populates $address_info
getAddressInfo() {
  address_info=$(${CCLI} shelley address info --address $1)
}

# Command    : getBalance [address]
# Description: check balance for provided address
# Return     : populates $lovelace & $utx0_count
getBalance() {
  lovelace=0
  utx0_count=0

  [[ -z $1 ]] && return 1

  if ! ${CCLI} shelley query utxo ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address "${1}" > "${TMP_FOLDER}"/fullUtxo.out; then return 1; fi
  tail -n +3 "${TMP_FOLDER}"/fullUtxo.out | sort -k3 -nr > "${TMP_FOLDER}"/balance.out

  while read -r utxo; do
    utx0_count=$(( utx0_count + 1 ))
    lovelace=$(( lovelace + $(awk '{ print $3 }' <<< "${utxo}") ))
  done <"${TMP_FOLDER}"/balance.out
}


# Command    : getRewards [wallet name]
# Description: check balance of reward address
# Return     : populates $reward_lovelace
getRewards() {
  reward_lovelace=-1
  if isWalletRegistered $1; then
    reward_lovelace=$(jq -r '.rewardAccountBalance' <<< "${stakeAddressInfo}")
    [[ "${reward_lovelace}" =~ ^[0-9]+$ ]] || reward_lovelace=0
  fi
}


# Command    : sendADA [destination address] [amount] [source address] [source sign key] [Include Fee]
# Description: send ADA from source to destination
#              can also be used to defrag address by sending all to self
#              supports fee to be payed by sender(default) or receiver by reducing amount to send
# Parameters : Destination Address   >   Destination address.
#              Amount                >   Amount in lovelace.
#              Source Address        >   Source address.
#              Source Sign Key       >   Path to Signature (skey) file. For stake wallet, payment skey is to be used.
#              Include Fee           >   Optional argument to specify that amount to send should be reduced by fee instead of payed by sender.
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> sendADA 61WKMJemoBa....ssL7fzhq 100 61RM9xbIdg....HbyQY175 "$CNODE_HOME/priv/wallet/MyWallet/payment.skey" "no"
sendADA() {

  # Handle script arguments
  dAddr="$1"
  amount="$2"
  sAddr="$3"
  sKey="$4"
  inclFee="$5"

  say "" 1
  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"
  getBalance ${sAddr}

  balance=0
  utxoCount=0
  txIn=""
  say "" 2
  say "Using UTxO's:" 2
  while read -r utxo; do
    inAddr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxoBalance=$(awk '{ print $3 }' <<< "${utxo}")
    utxoCount=$(( utxoCount +1))
    txIn="${txIn} --tx-in ${inAddr}#${idx}"
    balance=$(( balance + utxoBalance ))
    say "TxHash: ${inAddr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxoBalance})" 2
    [[ ${inclFee} = "yes" && ${balance} -ge ${amount} ]] && break
  done <"${TMP_FOLDER}"/balance.out

  [[ ${balance} -eq ${amount} ]] && outCount=1 || outCount=2

  say "" 1
  say "# Calculate fee, new amount and remaining balance" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${txIn} --tx-out ${dAddr}+0 --ttl ${ttlValue} --fee 0 --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${txIn} --tx-out ${dAddr}+0 --ttl ${ttlValue} --fee 0 --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utxoCount}
    --tx-out-count ${outCount}
    ${NETWORK_IDENTIFIER}
    --witness-count 1
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  # Sanity checks
  if [[ ${inclFee} = "no" ]]; then
    if [[ ${balance} -lt $(( amount + minFee )) ]]; then
      say "${FG_RED}ERROR${NC}: Not enough ADA in address ($(formatLovelace ${balance}) < $(formatLovelace ${amount}) + $(formatLovelace ${minFee}))" 1>&2
      return 1
    fi
  else
    if [[ ${amount} -lt ${minFee} ]]; then
      say "${FG_RED}ERROR${NC}: Fee deducted from ADA to send, amount can not be less than fee ($(formatLovelace ${amount}) < $(formatLovelace ${minFee}))" 1>&2
      return 1
    elif [[ ${balance} -lt ${amount} ]]; then
      say "${FG_RED}ERROR${NC}: Not enough ADA in address ($(formatLovelace ${balance}) < $(formatLovelace ${amount}))" 1>&2
      return 1
    fi
  fi

  if [[ ${inclFee} = "no" ]]; then
    txOut="--tx-out ${dAddr}+${amount}"
  else
    txOut="--tx-out ${dAddr}+$(( amount - minFee ))"
    say "New amount to send after fee deduction is $(formatLovelace $(( amount - minFee ))) ADA ($(formatLovelace ${amount}) - $(formatLovelace ${minFee}))" 1 "log"
  fi

  newBalance=$(( lovelace - amount ))
  if [[ ${inclFee} = "no" ]]; then
    newBalance=$(( balance - amount - minFee ))
    txOut="${txOut} --tx-out ${sAddr}+${newBalance}"
    say "Balance left to be returned in used UTxO's is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${balance}) - $(formatLovelace ${amount}) - $(formatLovelace ${minFee}))" 1 "log"
  elif [[ ${outCount} -eq 2 ]]; then
    txOut="${txOut} --tx-out ${sAddr}+$(( balance - amount ))"
    say "Balance left to be returned in used UTxO's is $(formatLovelace $(( balance - amount ))) ADA ($(formatLovelace ${balance}) - $(formatLovelace ${amount}))" 1 "log"
  fi

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${txIn}
    ${txOut}
    --ttl ${ttlValue}
    --fee ${minFee}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Source wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${sKey}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     :  sendMetadata [wallet address] [wallet sign key] [metadata file] [metadata type]
# Description :  post metadata file on chain using specified wallet to pay for the transaction fee
sendMetadata() {
  # Handle script arguments
  addr="$1"
  payment_sk_file="$2"
  metafile="$3"
  if [[ $4 = "no-schema" ]]; then
    metadata="--json-metadata-no-schema --metadata-json-file ${metafile}"
  elif [[ $4 = "detailed-schema" ]]; then
    metadata="--json-metadata-detailed-schema --metadata-json-file ${metafile}"
  elif [[ $4 = "cbor" ]]; then
    metadata="--metadata-cbor-file ${metafile}"
  else
    say "${FG_RED}ERROR${NC}: unknown metadata type '$4'"
    return 1
  fi

  say "" 1
  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"
  getBalance ${addr}

  # Use all available utxo in source address
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out

  say "" 1
  say "# Calculate fee, new amount and remaining balance" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${addr}+0 --ttl ${ttlValue} --fee 0 ${metadata} --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${addr}+0 --ttl ${ttlValue} --fee 0 ${metadata} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 1
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    say "${FG_RED}ERROR${NC}: Not enough ADA in address ( $(formatLovelace ${lovelace}) < $(formatLovelace ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee ))
  tx_out="--tx-out ${addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${minFee}) )" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    ${metadata}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Wallet: ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command    : isWalletRegistered [wallet name]
# Description: check if wallet is registered on chain
# Return     : 0 if registered, else 1
isWalletRegistered() {
  if getRewardAddress $1; then
    stakeAddressInfo=$(${CCLI} shelley query stake-address-info ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address ${reward_addr} | jq -r '.[0] // empty')
    [[ -n "${stakeAddressInfo}" ]] && return 0
  fi
  return 1
}

# Command    : registerStakeWallet [wallet name] [optional: skip validation true|false]
# Description: Register stake keys on chain and move funds from payment address to payment base address
# Return     : prints progress on STDOUT
registerStakeWallet() {

  if [[ -z $2 || $2 = "false" ]]; then
    say "Wallet ${FG_GREEN}${1}${NC} not registered on chain"
    waitForInput "press any key to continue with registration" && echo
  fi

  # Wallet key filenames
  payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}"
  stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_cert_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_CERT_FILENAME}"

  say "Creating registration certificate" 1 "log"
  say "" 1
  say "${CCLI} shelley stake-address registration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_cert_file}" 2
  if ! ${CCLI} shelley stake-address registration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_cert_file}"; then return 1; fi

  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  keyDeposit=$(jq -r '.keyDeposit' "${TMP_FOLDER}"/protparams.json)
  say "Key Deposit is ${keyDeposit}" 1 "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"

  # Use all available utxo in source address
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out

  say "" 1
  say "# Calculate fee" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${stake_cert_file} --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${stake_cert_file} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ ${lovelace} -lt $(( minFee + keyDeposit )) ]]; then
    say "\n${FG_RED}ERROR${NC}: Not enough ADA in wallet ($(formatLovelace ${lovelace}) < $(formatLovelace ${minFee}) + $(formatLovelace ${keyDeposit}))"
    return 1
  fi

  newBalance=$(( lovelace - minFee - keyDeposit ))
  tx_out="--tx-out ${base_addr}+${newBalance}"

  say "New balance after tx fee and key deposit is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${lovelace}) - $(formatLovelace ${minFee}) - $(formatLovelace ${keyDeposit}))" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${stake_cert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    echo
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    say "Wallet ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    echo
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi

  say "${FG_YELLOW}Waiting for wallet registration to be recorded on chain${NC}"
  while true; do
    if ! waitNewBlockCreated; then
      break
    fi
    getBalance ${base_addr}
    if [[ ${lovelace} -ne ${newBalance} ]]; then
      say "${FG_YELLOW}WARN${NC}: Balance mismatch, wallet registration not included in latest block... waiting for next block!"
      say "$(formatLovelace ${lovelace}) != $(formatLovelace ${newBalance})" 1
    else
      break
    fi
  done

  if [[ ${lovelace} -ne ${newBalance} ]]; then
    say "${FG_YELLOW}WARN${NC}: wallet registration check aborted"
    return 1
  fi

  reward_lovelace=0
}


# Command    : deregisterStakeWallet [wallet]
# Description: Deregister stake keys/wallet from chain, key deposit fee returned to wallets base address
# Return     : prints progress on STDOUT
deregisterStakeWallet() {

  # Wallet key filenames
  payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}"
  stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_dereg_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_DEREG_FILENAME}"

  say "Creating deregistration certificate" 1 "log"
  say "" 1
  say "${CCLI} shelley stake-address deregistration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_dereg_file}" 2
  if ! ${CCLI} shelley stake-address deregistration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_dereg_file}"; then return 1; fi

  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  keyDeposit=$(jq -r '.keyDeposit' "${TMP_FOLDER}"/protparams.json)
  say "Key Deposit is ${keyDeposit}" 1 "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"

  # Use all available utxo in tx fee wallet base address
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out

  say "" 1
  say "# Calculate fee" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${stake_dereg_file} --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${stake_dereg_file} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ $(( lovelace + keyDeposit - minFee )) -lt 0 ]]; then
    say "\n${FG_RED}ERROR${NC}: Not enough ADA in wallet ($(formatLovelace ${lovelace}) + $(formatLovelace ${keyDeposit}) < $(formatLovelace ${minFee}))"
    return 1
  fi

  newBalance=$(( lovelace + keyDeposit - minFee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"

  say "New balance after returned key deposit and subtracted tx fee is $(formatLovelace ${newBalance}) ADA ($(formatLovelace ${lovelace}) + $(formatLovelace ${keyDeposit}) - $(formatLovelace ${minFee}))" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${stake_dereg_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    echo
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    say "Wallet ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    echo
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command    : registerPool [pool name] [reward wallet] [delegate reward wallet] [owner wallet] [multi-owner skeys ...]
#
# Description: Register pool with pledge on chain
# Parameters : pool name                 >   pool to register on chain
#              reward wallet             >   name of wallet that collects the pool rewards
#              delegate reward wallet    >   true or false, should reward wallet be delegated to pool
#              owner wallet              >   the pool owner, also pays for the pool registration fee
#              multi-owner skeys         >   a list of extra extra owner skeys to sign pool registration with
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> registerPool "MyPool" "MyRewardWallet" "true" "MyOwnerWallet" "/path/to/secondOwner.skey"
#
registerPool() {

  pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}"
  pool_regcert_file="${POOL_FOLDER}/${1}/${POOL_REGCERT_FILENAME}"
  reward_stake_sk_file="${WALLET_FOLDER}/${2}/${WALLET_STAKE_SK_FILENAME}"
  reward_delegation_cert_file="${WALLET_FOLDER}/${2}/${WALLET_DELEGCERT_FILENAME}"
  delegate_reward_wallet="${3}"
  owner_payment_sk_file="${WALLET_FOLDER}/${4}/${WALLET_PAY_SK_FILENAME}"
  owner_stake_sk_file="${WALLET_FOLDER}/${4}/${WALLET_STAKE_SK_FILENAME}"
  owner_delegation_cert_file="${WALLET_FOLDER}/${4}/${WALLET_DELEGCERT_FILENAME}"
  getBaseAddress "${4}"
  getBalance ${base_addr}
  shift 4
  multi_owner_count=$#
  multi_owner_keys=$@

  if [[ ! -s "${TMP_FOLDER}"/balance.out ]]; then
    say "${FG_RED}ERROR${NC}: wallet empty"
    return 1
  fi

  say "" 1
  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  poolDeposit=$(jq -r '.poolDeposit' "${TMP_FOLDER}"/protparams.json)
  say "Pool Deposit is ${poolDeposit}" 1 "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"

  # Use all available utxo in pledge wallet
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out
  
  reward_delegation_cert=""
  reward_wallet_key=""
  witness_count=$(( 3 + multi_owner_count ))
  if [[ "${delegate_reward_wallet}" = "true" ]]; then
    reward_delegation_cert="--certificate-file ${reward_delegation_cert_file}"
  fi
  if [[ ! "${owner_stake_sk_file}" = "${reward_stake_sk_file}" ]]; then
    reward_wallet_key="${reward_stake_sk_file}"
    ((witness_count++))
  fi

  say "" 1
  say "# Calculate fee, new amount and remaining balance" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --certificate-file ${pool_regcert_file} --certificate-file ${owner_delegation_cert_file} ${reward_delegation_cert} --fee 0 --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --certificate-file ${pool_regcert_file} --certificate-file ${owner_delegation_cert_file} ${reward_delegation_cert} --fee 0 --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count ${witness_count}
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ ${lovelace} -lt $(( minFee + poolDeposit )) ]]; then
    say "${FG_RED}ERROR${NC}: Not enough ADA in base address ( $(formatLovelace ${lovelace}) < $(formatLovelace ${minFee}) + $(formatLovelace ${poolDeposit}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee - poolDeposit ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${minFee}) - $(formatLovelace ${poolDeposit}) )" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_regcert_file}
    --certificate-file ${owner_delegation_cert_file}
    ${reward_delegation_cert}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Owner wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    say "Owner wallet ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    say "Pool ${FG_GREEN}${POOL_COLDKEY_SK_FILENAME}${NC}" "log"
    [[ -n ${reward_wallet_key} ]] && say "Reward wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    [[ ${multi_owner_count} -gt 0 ]] && say "Additional owners ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    return 2
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${reward_wallet_key}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command    : modifyPool [pool name] [reward wallet] [owner wallet] [multi-owner skeys ...]
#
# Description: Register pool with pledge on chain
# Parameters : pool name                 >   pool to register on chain
#              reward wallet             >   name of wallet that collects the pool rewards
#              owner wallet              >   the pool owner, also pays for the pool registration fee
#              multi-owner skeys         >   a list of extra extra owner skeys to sign pool registration with
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> modifyPool "MyPool" "MyRewardWallet" "MyOwnerWallet" "/path/to/secondOwner.skey"
#
modifyPool() {

  pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}"
  pool_regcert_file="${POOL_FOLDER}/${1}/${POOL_REGCERT_FILENAME}"
  reward_stake_sk_file="${WALLET_FOLDER}/${2}/${WALLET_STAKE_SK_FILENAME}"
  owner_payment_sk_file="${WALLET_FOLDER}/${3}/${WALLET_PAY_SK_FILENAME}"
  owner_stake_sk_file="${WALLET_FOLDER}/${3}/${WALLET_STAKE_SK_FILENAME}"
  getBaseAddress "${3}"
  getBalance ${base_addr}
  shift 3
  multi_owner_count=$#
  multi_owner_keys=$@
  
  if [[ ! -s "${TMP_FOLDER}"/balance.out ]]; then
    say "${FG_RED}ERROR${NC}: wallet empty"
    return 1
  fi

  say "" 1
  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"

  # Use all available utxo in pledge wallet base address
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out

  reward_wallet_key=""
  witness_count=$(( 3 + multi_owner_count ))
  if [[ ! "${owner_stake_sk_file}" = "${reward_stake_sk_file}" ]]; then
    reward_wallet_key="${reward_stake_sk_file}"
    ((witness_count++))
  fi

  say "" 1
  say "# Calculate fee, new amount and remaining balance" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --certificate-file ${pool_regcert_file} --fee 0 --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --certificate-file ${pool_regcert_file} --fee 0 --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count ${witness_count}
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    say "${FG_RED}ERROR${NC}: Not enough ADA in base address ( $(formatLovelace ${lovelace}) < $(formatLovelace ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${minFee}) )" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_regcert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Owner wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    say "Owner wallet ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    say "Pool ${FG_GREEN}${POOL_COLDKEY_SK_FILENAME}${NC}" "log"
    [[ -n ${reward_wallet_key} ]] && say "Reward wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    [[ ${multi_owner_count} -gt 0 ]] && say "Additional owners ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    return 2
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${reward_wallet_key}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command    : withdrawRewards [stake skey file] [payment skey file] [base address] [reward address] [rewards in lovelace]
# Description: withdraw rewards earned and send to wallet base address
#
withdrawRewards() {

  # script arguments
  stake_sk_file="$1"
  payment_sk_file="$2"
  base_addr="$3"
  stake_addr="$4"
  reward_lovelace="$5"

  say "" 1
  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"

  # Use all available utxo in pledge wallet base address
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out

  say "" 1
  say "# Calculate fee, new amount and remaining balance" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    say "${FG_RED}ERROR${NC}: Not enough ADA in wallet ( $(formatLovelace ${lovelace}) < $(formatLovelace ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee + reward_lovelace ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${minFee}) )" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --withdrawal ${stake_addr}+${reward_lovelace}
    --ttl ${ttlValue}
    --fee ${minFee}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    say "Wallet ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"

  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command    : Delegate [stake skey] [pay skey] [pay addr] [pool vkey] [deleg cert]
#
# Description: Register pool with pledge on chain
# Parameters : stake skey    >   wallet stake skey
#              pay skey      >   wallet payment skey
#              base addr     >   wallet base address
#              pool vkey     >   pool you are delegating to vkey
#              deleg cert    >   delegation certificate
#
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> registerPool "../wallet/MyWallet/stake.skey" "../wallet/MyWallet/payment.skey" 00d9d57c....ssL7fzhq "../pools/MyPool/cold.vkey" "delegation.cert"
#
delegate() {

  # script arguments
  stake_sk_file="$1"
  payment_sk_file="$2"
  base_addr="$3"
  pool_coldkey_vk_file="$4"
  pool_delegcert_file="$5"

  say "" 1
  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"

  # Use all available utxo in pledge wallet
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out

  say "" 1
  say "# Calculate fee, new amount and remaining balance" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${pool_delegcert_file} --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${pool_delegcert_file} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    say "${FG_RED}ERROR${NC}: Not enough ADA in wallet ( $(formatLovelace ${lovelace}) < $(formatLovelace ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${minFee}) )" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_delegcert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    say "Wallet ${FG_GREEN}${WALLET_STAKE_SK_FILENAME}${NC}" "log"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"

  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command    : deRegisterPool [pool cold skey] [pool dereg cert] [wallet addr] [wallet skey]
#
# Description: Retire pool
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> deRegisterPool "../pools/MyPool/cold.vkey" "../pools/MyPool/pool.dereg" 00d9d57c....ssL7fzhq "../wallet/MyWallet/payment.skey"
#
deRegisterPool() {

  # script arguments
  pool_coldkey_sk_file="$1"
  pool_deregcert_file="$2"
  wallet_addr="$3"
  wallet_payment_sk_file="$4"
  
  # get balance
  getBalance ${wallet_addr}

  say "" 1
  say "# Protocol Parameters" 1 "log"
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    say "\nHow long do you want the transaction to be valid?"
    read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter
    if [[ -n ${ttl_enter} && ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      say "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}" 1>&2
      return 1
    fi
    ttlValue=$(( currSlot + (${ttl_enter:-1800}/SLOT_LENGTH) ))
    echo
  else
    ttlValue=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" 1 "log"

  # Use all available utxo in wallet address
  say "" 2
  say "Using UTxO's:" 2
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" 2
    say "ADA: $(formatLovelace ${utxo_balance})" 2
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out

  say "" 1
  say "# Calculate fee, new amount and remaining balance" 1 "log"
  say "$ ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${wallet_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${pool_deregcert_file} --out-file ${TMP_FOLDER}/tx0.tmp" 2
  if ! ${CCLI} shelley transaction build-raw ${tx_in} --tx-out ${wallet_addr}+0 --ttl ${ttlValue} --fee 0 --certificate-file ${pool_deregcert_file} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  say "$ ${CCLI} ${minFeeArgs[*]}" 2
  minFee=$([[ "$(${CCLI} ${minFeeArgs[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  say "fee is $(formatLovelace ${minFee}) ADA" 1 "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    say "${FG_RED}ERROR${NC}: Not enough ADA in wallet ( $(formatLovelace ${lovelace}) < $(formatLovelace ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee ))
  tx_out="--tx-out ${wallet_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) ADA ( $(formatLovelace ${lovelace}) - $(formatLovelace ${minFee}) )" 1 "log"

  say "" 1
  say "# Build transaction" 1 "log"
  
  buildArgs=(
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_deregcert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    tx_tmp="/tmp/tx.raw_$(date +%s)"
    if ! cp -f "${TMP_FOLDER}/tx.raw" "${tx_tmp}"; then
      say "${FG_RED}ERROR${NC}: unable to copy tx file to: ${tx_tmp}" 1>&2
      return 1
    fi
    say "Transaction successfully built and saved to: ${FG_CYAN}${tx_tmp}${NC}" "log"
    say "Copy file to offline computer and sign it using CNTools in offline mode '-o' [Sign Tx] with:" "log"
    say "Wallet ${FG_GREEN}${WALLET_PAY_SK_FILENAME}${NC}" "log"
    say "Pool ${FG_GREEN}${POOL_COLDKEY_SK_FILENAME}${NC}" "log"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  say "" 1
  say "# Sign & Send transaction" 1 "log"

  if ! signTx "${TMP_FOLDER}/tx.raw" "${wallet_payment_sk_file}" "${pool_coldkey_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command    : buildTx
#
# Description: Helper function to offline build a raw transaction
#              populate an array variable called 'buildArgs' with all data
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> buildTx
#
buildTx() {
  say "Building transaction" 1
  say "$ ${CCLI} shelley transaction build-raw ${buildArgs[*]}" 2
  output=$(${CCLI} shelley transaction build-raw ${buildArgs[*]})
  if [[ -n $output ]]; then
    say "${FG_RED}ERROR${NC}: Problem during tx creation with args ${buildArgs[*]}"
    say "$output"
    return 1
  fi
}

# Command    : signTx [raw tx file] [signing keys ...]
#
# Description: Helper function to offline sign a raw transaction
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> signTx "/tmp/tx.raw" "../wallet/MyWallet/payment.skey" "../wallet/MyWallet/stake.skey"
#
signTx() {
  tx_raw="$1"
  parent_dir="$(dirname "${tx_raw}")"
  tx_signed="${parent_dir}/tx.signed_$(date +%s)"
  shift
  skey_count=0
  tx_sign_keys=()
  for skey in "$@"; do
    if [[ -f "${skey}" ]]; then
      tx_sign_keys+=( --signing-key-file ${skey} )
      ((skey_count++))
    fi
  done
  
  signArgs=(
    shelley transaction sign
    --tx-body-file "${tx_raw}"
    ${tx_sign_keys[*]}
    ${NETWORK_IDENTIFIER}
    --out-file "${tx_signed}"
  )
  
  say "Signing transaction" 1
  say "$ ${CCLI} ${signArgs[*]} " 2
  output=$(${CCLI} ${signArgs[*]} 2>&1)
  if [[ -n $output ]]; then
    say "${FG_RED}ERROR${NC}: Problem during signing with args ${signArgs[*]}"
    say "$output"
    return 1
  fi
}

# Command    : submitTx [signed tx file]
#
# Description: Helper function to submit an offline signed transaction file
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> signTx "/tmp/tx.signed"
#
submitTx() {
  tx_signed="$1"

  submitArgs=(
    shelley transaction submit
    --tx-file "${tx_signed}"
    ${PROTOCOL_IDENTIFIER}
    ${NETWORK_IDENTIFIER}
  )
  
  say "Sending transaction" 1
  say "$ ${CCLI} ${submitArgs[*]}" 2
  output=$(${CCLI} ${submitArgs[*]} 2>&1)
  if [[ -n $output ]]; then
    say "${FG_RED}ERROR${NC}: Problem during tx submission with args ${submitArgs[*]}"
    say "$output"
    return 1
  fi
  say "" 1
}


# Command    : selectOpMode
# Description: Helper function to choose operational mode
selectOpMode() {
  echo
  say "Online mode  -  The default mode to use if all keys are available"
  echo
  say "Hybrid mode  -  1) Go through steps to build a transaction file"
  say "                2) Copy built tx file to offline computer"
  say "                3) Sign it using 'Sign Tx' with keys on offline computer"
  say "                   (CNTools started in offline mode '-o' without node connection)"
  say "                4) Copy the signed tx file back to online computer and submit using 'Submit Tx'"
  echo
  select_opt "[o] Online" "[h] Hybrid" "[Esc] Cancel"
  case $? in
    0) op_mode="online" ;;
    1) op_mode="hybrid" ;;
    2) return 1 ;;
  esac
}


# Command    : rotatePoolKeys [pool name]
#
# Description: Rotate pool's KES keys
# Return     : null
# Examples of Usage:
#   >> rotatePoolKeys MyPool
#
rotatePoolKeys() {
  pool_name="${1}"

  # cold keys
  pool_coldkey_sk_file="${POOL_FOLDER}/${pool_name}/${POOL_COLDKEY_SK_FILENAME}"

  # generated files
  pool_hotkey_vk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_VK_FILENAME}"
  pool_hotkey_sk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_SK_FILENAME}"
  pool_opcert_counter_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_COUNTER_FILENAME}"
  pool_saved_kes_start="${POOL_FOLDER}/${pool_name}/${POOL_CURRENT_KES_START}"
  pool_opcert_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_FILENAME}"

  getCurrentKESperiod
  echo "${current_kes_period}" > ${pool_saved_kes_start}

  say "creating new hot keys and certificate" 1
  say "$ ${CCLI} shelley node key-gen-KES --verification-key-file ${pool_hotkey_vk_file} --signing-key-file ${pool_hotkey_sk_file}" 2
  if ! ${CCLI} shelley node key-gen-KES --verification-key-file "${pool_hotkey_vk_file}" --signing-key-file "${pool_hotkey_sk_file}"; then return 1; fi
  say "$ ${CCLI} shelley node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --cold-signing-key-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}" 2
  if ! ${CCLI} shelley node issue-op-cert --kes-verification-key-file "${pool_hotkey_vk_file}" --cold-signing-key-file "${pool_coldkey_sk_file}" --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" --kes-period "${current_kes_period}" --out-file "${pool_opcert_file}"; then return 1; fi
  chmod 700 ${POOL_FOLDER}/${pool_name}/*

  kesExpiration "${current_kes_period}"
}

# Command    : getDelegators [pool id]
#
# Description: parse ledger-state for pool delegators
# Return     : json array in variable $delegators_json
#
getDelegators() {
  pool_id=$1

  if ! timeout -k 5 $TIMEOUT_LEDGER_STATE ${CCLI} shelley query ledger-state ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --out-file "${TMP_FOLDER}"/ledger-state.json; then
    say "${FG_RED}ERROR${NC}: ledger dump failed/timed out"
    say "increase timeout value in cntools.config"
    return 1
  fi
  say "\nLedger state dumped, parsing data..."
  non_myopic_delegators=$(jq -r -c ".esNonMyopic.snapNM._delegations | .[] | select(.[1] == \"${pool_id}\") | .[0][\"key hash\"]" "${TMP_FOLDER}"/ledger-state.json)
  snapshot_delegators=$(jq -r -c ".esSnapshots._pstakeSet._delegations | .[] | select(.[1] == \"${pool_id}\") | .[0][\"key hash\"]" "${TMP_FOLDER}"/ledger-state.json)
  lstate=$(jq -r -c ".esLState" "${TMP_FOLDER}"/ledger-state.json)
  lstate_dstate=$(jq -r -c "._delegationState._dstate" <<< "${lstate}")
  ledger_pParams=$(jq -r -c '._delegationState._pstate._pParams."'"${pool_id}"'" // empty' <<< "${lstate}")
  ledger_fPParams=$(jq -r -c '._delegationState._pstate._fPParams."'"${pool_id}"'" // empty' <<< "${lstate}")
  [[ -z "${ledger_fPParams}" ]] && ledger_fPParams="${ledger_pParams}"
  lstate_rewards=$(jq -r -c "._rewards" <<< "${lstate_dstate}")
  lstate_utxo=$(jq -r -c "._utxoState._utxo" <<< "${lstate}")
  lstate_delegators=$(jq -r -c "._delegations | .[] | select(.[1] == \"${pool_id}\") | .[0][\"key hash\"]" <<< "${lstate_dstate}")
  delegators=$(echo "${non_myopic_delegators}" "${snapshot_delegators}" "${lstate_delegators}" | tr ' ' '\n' | sort -u)
  say "\n$(wc -w <<< "${delegators}") delegators found, gathering data for each:"
  pledge_pParams="$(jq -c -r '.pledge // 0' <<< "${ledger_pParams}")"
  pledge_fPParams="$(jq -c -r '.pledge // 0' <<< "${ledger_fPParams}")"
  [[ ${pledge_pParams} -eq ${pledge_fPParams} ]] && pledge=${pledge_pParams} || pledge=${pledge_fPParams}
  owners_pParams="$(jq -c -r '.owners[] // empty' <<< "${ledger_pParams}")"
  owners_fPParams="$(jq -c -r '.owners[] // empty' <<< "${ledger_fPParams}")"
  if [[ ${owners_pParams} = ${owners_fPParams} ]]; then
    owners=${owners_pParams}
    owner_nbr=$(jq -r '(.owners | length) // 0' <<< "${ledger_pParams}")
  else
    owners=${owners_fPParams}
    owner_nbr=$(jq -r '(.owners | length) // 0' <<< "${ledger_fPParams}")
  fi
  delegators_array=()
  delegator_nbr=0
  total_stake=0
  total_pledged=0
  for key in ${delegators}; do
    stake=$(jq -r -c ".[] | select(.address | contains(\"${key}\")) | .amount" <<< "${lstate_utxo}" | awk 'BEGIN{total = 0} {total = total + $1} END{printf "%.0f", total}')
    rewards=$(jq -r -c ".[] | select(.[0][\"key hash\"] == \"${key}\") | .[1]" <<< "${lstate_rewards}")
    total_stake=$((total_stake + stake + rewards))
    say "Delegator $((++delegator_nbr)) processed"
    if echo "${owners}" | grep -q "${key}"; then
      key="${key} (owner)"
      total_pledged=$((total_pledged + stake + rewards))
    fi
    delegators_array+=( "hex_key" "${key}" "stake" "$(formatLovelace ${stake})" "rewards" "$(formatLovelace ${rewards})" )
  done

  # Construct delegator json array
  delegators_json=$({
    say '['
    printf '{"%s":"%s","%s":"%s","%s":"%s"},\n' "${delegators_array[@]}" | sed '$s/,$//'
    say ']'
  } | jq -c .)
}


function printTable() {
  local -r delimiter="${1}"
  local -r data="$(removeEmptyLines "${2}")"
  if [[ "${delimiter}" != '' && "$(isEmptyString "${data}")" = 'false' ]]; then
    local -r numberOfLines="$(wc -l <<< "${data}")"
    if [[ "${numberOfLines}" -gt '0' ]]; then
      local table=''
      local i=1
      for ((i = 1; i <= "${numberOfLines}"; i = i + 1)); do
        local line=''
        line="$(sed "${i}q;d" <<< "${data}")"
        local numberOfColumns='0'
        numberOfColumns="$(awk -F "${delimiter}" '{print NF}' <<< "${line}")"
        # Add Line Delimiter
        if [[ "${i}" -eq '1' ]]; then
          table="${table}$(printf '%s@+' "$(repeatString '@+' "${numberOfColumns}")")"
        fi
        # Add Header Or Body
        table="${table}\n"
        local j=1
        for ((j = 1; j <= "${numberOfColumns}"; j = j + 1)); do
          table="${table}$(printf '@| %s' "$(cut -d "${delimiter}" -f "${j}" <<< "${line}")")"
        done
        table="${table}@|\n"
        # Add Line Delimiter
        if [[ "${i}" -eq '1' ]] || [[ "${numberOfLines}" -gt '1' && "${i}" -eq "${numberOfLines}" ]]; then
          table="${table}$(printf '%s@+' "$(repeatString '@+' "${numberOfColumns}")")"
        fi
      done
      if [[ "$(isEmptyString "${table}")" = 'false' ]]; then
        echo -e "${table}" | column -s '@' -t | awk '/^\+/{gsub(" ", "-", $0)}1'
      fi
    fi
  fi
}

function removeEmptyLines() {
  local -r content="${1}"
  echo -e "${content}" | sed '/^\s*$/d'
}

function repeatString() {
  local -r string="${1}"
  local -r numberToRepeat="${2}"
  if [[ "${string}" != '' && "${numberToRepeat}" =~ ^[1-9][0-9]*$ ]]; then
    local -r result="$(printf "%${numberToRepeat}s")"
    echo -e "${result// /${string}}"
  fi
}

function isEmptyString() {
  local -r string="${1}"
  if [[ "$(trimString "${string}")" = '' ]]; then
    echo 'true' && return 0
  fi
  echo 'false' && return 1
}

function trimString() {
  local -r string="${1}"
  sed 's,^[[:blank:]]*,,' <<< "${string}" | sed 's,[[:blank:]]*$,,'
}
