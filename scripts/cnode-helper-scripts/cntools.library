#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2086,SC2230,SC2206,SC2140

############################################################
# Variables to keep counter for versions                   #
############################################################
# The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
# and this adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
# Any breaking changes (eg: that requires change of cntools.config, env or a change in priv folder would be considered breaking and will be exempt from auto-update)
CNTOOLS_MAJOR_VERSION=7
# Changes that can be applied without breaking existing functionality that can be applied from within CNTools
CNTOOLS_MINOR_VERSION=0
# Backwards compatible bug fixes. No additional functionality or major changes and can be applied from within CNTools
CNTOOLS_PATCH_VERSION=1
CNTOOLS_VERSION="${CNTOOLS_MAJOR_VERSION}.${CNTOOLS_MINOR_VERSION}.${CNTOOLS_PATCH_VERSION}"

############################################################
# Default config values                                    #
# overriden by values set in cntools.config                #
############################################################
[[ -z ${TMP_FOLDER} ]] && TMP_FOLDER=/tmp/cntools
[[ -z ${TIMEOUT_NO_OF_SLOTS} ]] && TIMEOUT_NO_OF_SLOTS=600
[[ -z ${TIMEOUT_LEDGER_STATE} ]] && TIMEOUT_LEDGER_STATE=300
[[ -z ${SHELLEY_TRANS_FILENAME} ]] && SHELLEY_TRANS_FILENAME="${CNODE_HOME}/guild-db/shelley_trans_epoch"
[[ ${SHELLEY_TRANS_FILENAME} =~ ^${CNODE_HOME}/db/ ]] && mkdir -p "${CNODE_HOME}/guild-db" && SHELLEY_TRANS_FILENAME="${CNODE_HOME}/guild-db/shelley_trans_epoch"
[[ -z ${WALLET_SELECTION_FILTER_LIMIT} ]] && WALLET_SELECTION_FILTER_LIMIT=10
[[ -z ${KES_ALERT_PERIOD} ]] && KES_ALERT_PERIOD=172800 # default 2 days
[[ -z ${KES_WARNING_PERIOD} ]] && KES_WARNING_PERIOD=604800 # default 7 days
[[ $(uname) == Darwin ]] && ENABLE_CHATTR=false
[[ -z ${ENABLE_CHATTR} ]] && ENABLE_CHATTR=true
[[ -z ${ENABLE_DIALOG} ]] && ENABLE_DIALOG=true

############################################################
# library sourced by cntools with common taskes to perform #
############################################################

# Assumes that env has been sourced by calling script

# Command     : logln [log level] [message]
# Description : write message to log file with log level specified
logln() {
  local log_level=$1
  shift
  [[ -z $1 ]] && return
  echo -e "$@" | while read -r log_line; do
    log_line=$(sed -E 's/\x1b(\[[0-9;]*[a-zA-Z]|[0-9])//g' <<< ${log_line##*( )})
    [[ -z ${log_line} ]] && continue
    printf '%s %-8s %s\n' "$(date "+%F %T %Z")" "[${log_level}]" "${log_line}" >> "${CNTOOLS_LOG}"
  done
}

# Command     : println [log level] [message]
# Description : print and log(if enabled) message
# Parameters  : log level  >  log level (default: INFO)
#                             OFF    : logging disabled, output only to tty
#                             LOG    : logged as DEBUG but not printed to tty
#                             DEBUG  : verbose output, logged and printed to tty
#                             INFO   : normal output printed to tty and logged
#                             ACTION : e.g cardano-cli executions etc, logged but not printed to tty
#                             ERROR  : stderr output and error messages
#             : message    >  The message to print/log
println() {  
  sleep 0.05 # hack, sleep 50ms before each print to preserve order of execution
  local log_level=$1
  shift
  case $log_level in
    OFF) printf '%b\n' "$@" >&6 ;;
    LOG) logln "DEBUG" "$@" ;;
    DEBUG) printf '%b\n' "$@" >&6; logln "DEBUG" "$@" ;;
    INFO) printf '%b\n' "$@" ;;
    ACTION) logln "ACTION" "$@" ;;
    ERROR) printf '%b\n' "$@" >&2 ;;
    *) printf '%b\n' "${log_level}"; [[ $# -ge 1 ]] && printf '%s\n' "$@" ;;
  esac
}

# Command     : distanceToBottom [rows]
# Description : print blank rows and reset cursor position
createDistanceToBottom() {
  printf "%0.s\n" $(seq $1) >&6; printf "\033[$1A" >&6
}

# Command     : archiveLog
# Description : archive old log file and clean archive folder keeping last 10 log files
archiveLog() {
  [[ -z ${CNTOOLS_LOG} ]] && return
  log_archive="$(dirname "${CNTOOLS_LOG}")/archive"
  log_file="$(basename "${CNTOOLS_LOG}")"
  mkdir -p "${log_archive}"
  [[ -f ${CNTOOLS_LOG} ]] && mv -f "${CNTOOLS_LOG}" "${log_archive}/${log_file}_$(date +%s)"
  find "${log_archive}" -maxdepth 1 -type f -name "${log_file}*" -printf '%Ts\t%p\n' | sort -n | head -n -10 | cut -f 2- | xargs rm -rf
}

# Command     : waitForInput [optional: message]
# Description : wait for user keypress to continue
# Parameters  : message  >  [optional]: override default 'press any key to return to home menu' message
waitForInput() {
  exec >&6 # normal stdout
  createDistanceToBottom $(( $# + 1 ))
  tput sc
  ESC=$(printf "\033")
  echo
  if [[ $# -eq 0 ]]; then
    echo "press any key to return to home menu"
  else
    printf '%b\n' "$@"
  fi
  read -rsn1 key # get 1 character
  if [[ $key == $ESC ]]; then
    read -rsn2 key # read 2 more chars
  fi
  tput rc && tput ed
  exec >&8 # custom stdout
}

# Command     : need_cmd [command]
# Description : Check if command is available, else print error
# Parameters  : command  >  The command to check
need_cmd() {
  if ! command -v "$1" &>/dev/null; then
    println "ERROR" "${FG_RED}ERROR${NC}: need '$1' (command not found)\ntry 'sudo apt install $1'\nplease install with your packet manager of choice(apt/yum etc..) and relaunch CNTools"
    return 1
  fi
}


# Command     : protectionPreRequisites
# Description : Check if needed protection prerequisites is available, else print error
protectionPreRequisites() {
  if ! need_cmd "gpg"; then
    return 1
  fi

  if ! need_cmd "chattr" &>/dev/null; then
    [[ ${ENABLE_CHATTR} = true ]] && println "ERROR" "chattr command not available but enabled in config, please install or disable in cntools.config and re-run CNTools" && return 1
  elif [[ ${ENABLE_CHATTR} = true ]]; then # chattr available and enabled, make sure sudo access to chattr is enabled
    touch "${TMP_FOLDER}"/test
    println "DEBUG" "Testing chattr access permission, enter user password if requested..."
    if ! sudo chattr -i "${TMP_FOLDER}"/test; then
      rm -f "${TMP_FOLDER}"/test
      echo
      println "ERROR" "${FG_YELLOW}WARN${NC}: Elevated privileges needed for chattr command used to write protect wallet and pool keys"
      println "ERROR" "Add required sudo permissions or run the following command to add passwordless sudo access to chattr command for '$(whoami)' user"
      echo
      println "ERROR" "echo \"$(whoami) ALL=NOPASSWD: $(command -v chattr)\" | sudo tee /etc/sudoers.d/cntools"
      return 1
    fi
    rm -f "${TMP_FOLDER}"/test
  fi
}

# Command     : safeDel [path]
# Description : unlock and use secure delete (srm) if available to delete file|dir
# Note        : srm mainly effective for traditional magnetic HDDs and non copy-on-write or journal file systems
# Parameters  : command  >  The command to check
safeDel() {
  path=$1
  [[ ${ENABLE_CHATTR} = true && -f "${path}" && $(lsattr -R "${path}") =~ -i- ]] && sudo chattr -i "${path}"
  command -v "srm" &>/dev/null && delcommand='srm' || delcommand='rm'
  if "${delcommand}" -rf "${path}"; then
    println "Deleted: ${path}"
  else
    println "ERROR" "${FG_RED}ERROR${NC}: delete failed for ${path}"
    return 1
  fi
  return 0
}

# Command     : dialogSetup
# Description : set config parameters for dialog formatting
dialogSetup() {
  export DIALOGRC="${TMP_FOLDER}"/.dialogrc
  [[ ! -f ${DIALOGRC} ]] && cat << EOF > "${TMP_FOLDER}"/.dialogrc
# Types of values:
#
# Number     -  <number>
# String     -  "string"
# Boolean    -  <ON|OFF>
# Attribute  -  (foreground,background,highlight?)
# Set aspect-ration.
aspect = 0
# Set separator (for multiple widgets output).
separate_widget = ""
# Set tab-length (for textbox tab-conversion).
tab_len = 0
# Make tab-traversal for checklist, etc., include the list.
visit_items = OFF
# Shadow dialog boxes? This also turns on color.
use_shadow = OFF
# Turn color support ON or OFF
use_colors = OFF
# Screen color
screen_color = (BLACK,BLACK,OFF)
# Shadow color
shadow_color = (BLACK,BLACK,ON)
# Dialog box color
dialog_color = (BLACK,BLACK,OFF)
# Dialog box title color
title_color = (RED,BLACK,ON)
# Dialog box border color
border_color = (BLACK,BLACK,OFF)
# Active button color
button_active_color = (WHITE,BLACK,ON)
# Inactive button color
button_inactive_color = (BLACK,WHITE,OFF)
# Active button key color
button_key_active_color = button_active_color
# Inactive button key color
button_key_inactive_color = (RED,BLACK,OFF)
# Active button label color
button_label_active_color = (YELLOW,BLACK,OFF)
# Inactive button label color
button_label_inactive_color = (BLACK,WHITE,ON)
# Input box color
inputbox_color = button_inactive_color
# Input box border color
inputbox_border_color = button_inactive_color
# Item color
item_color = button_inactive_color
# Selected item color
item_selected_color = button_active_color
# Dialog box border2 color
border2_color = button_inactive_color
# Input box border2 color
inputbox_border2_color = button_inactive_color
EOF
}

# Command     : fileDialog [title] [optional: start path]
# Description : open a file dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: /tmp/)
fileDialog() {
  exec >&6 # normal stdout
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    printf "$1: " && read -r file
    return
  fi
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="/tmp/"
  file=$(dialog --stdout --clear --keep-tite --title "$1" --fselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)))
  exec >&8 # custom stdout
}
# Command     : dirDialog [title] [optional: start dir]
# Description : open a directory dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: /tmp/)
dirDialog() {
  exec >&6 # normal stdout
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    printf "$1: " && read -r dir
    return
  fi
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="/tmp/"
  dir=$(dialog --stdout --clear --keep-tite --title "$1" --dselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)))
  exec >&8 # custom stdout
}


# Command     : selectOption [opt1] [opt2] ...
# Description : Create a bash menu to select one of the provided options
# Parameters  : optX  >  a list of available options to choose from
ESC=$(printf "\033")
cursor_blink_on()  { printf "$ESC[?25h"; }
cursor_blink_off() { printf "$ESC[?25l"; }
cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
print_option()     { printf "  $1 "; }
print_selected()   { printf " $ESC[7m $1 $ESC[27m$2"; }
get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
key_input()        { key2=""
                     read -rsn1 key1   # get 1 character
                     if [[ $key1 == $ESC ]]; then
                       read -rsn2 -t 0.3 key2 # read 2 more chars, 1s timeout
                     fi
                       if [[ $key2 = "[A" ]]; then echo up;
                     elif [[ $key2 = "[B" ]]; then echo down;
                     elif [[ $key1 = $ESC && $key2 = "" ]]; then echo Esc;
                     elif [[ $key1 = ""   ]]; then echo enter;
                     else echo $key1; fi; }
opt_shortcut()     { [[ "$1" =~ ^\[([[:alnum:]]+)\].* ]] && echo ${BASH_REMATCH[1]}; }
opt_firstchar()    { printf "${1:0:1}" | tr '[:upper:]' '[:lower:]'; }
selectOption() {
  sleep 0.1 # sleep for a short time to get tty in sync

  # initially print empty new lines (scroll down if at bottom of screen)
  printf "\n" && for opt; do printf "\n"; done

  # determine current screen position for overwriting the options
  local lastrow=$(get_cursor_row)
  local startrow=$(($lastrow - $# - 1))

  cursor_blink_off

  local shortcut_found="no"
  local selected=0
  while true; do
    # print options by overwriting the last lines
    local idx=0
    for opt; do
      opt_part2=""
      if [[ "$opt" =~ ^(.*)[[:space:]](\(.*) ]]; then
        opt_part1="${BASH_REMATCH[1]}"
        opt_part2=" ${BASH_REMATCH[2]}"
      else
        opt_part1="$opt"
      fi
      cursor_to $(($startrow + $idx))
      if [ $idx -eq $selected ]; then
        print_selected "$opt_part1" "$opt_part2"
      else
        print_option "$opt_part1$opt_part2"
      fi
      ((idx++))
    done

    [[ "${shortcut_found}" = "yes" ]] && break

    # user key control
    key_pressed=$(key_input)
    case ${key_pressed} in
      enter) break;;
      up)    ((selected--));
             if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
      down)  ((selected++));
             if [ $selected -ge $# ]; then selected=0; fi;;
      *)     # shortcut available for selected key?
             i=0
             for opt; do
               [[ ${key_pressed} = $(opt_shortcut "$opt") ]] && selected=${i} && shortcut_found="yes" && break
               ((i++))
             done
             # If no shortcut is found, lets see if it matches the first char of any of the options
             j=0
             for opt; do
               [[ "${shortcut_found}" != "yes" && ${key_pressed} = $(opt_firstchar "$opt") ]] && selected=${j} && break
               ((j++))
             done
             ;;
    esac
  done

  # clear menu
  cursor_blink_on
  cursor_to $startrow
  tput ed
  
  return $selected
}

# Command     : select_opt [opt1] [opt2] ...
# Description : Helper function to selectOption
# Parameters  : optX  >  a list of available options to choose from
select_opt() {
  exec >&6 # normal stdout
  local opts=( "$@" )
  selectOption "${opts[@]}"
  local answer=$?
  exec >&8 # custom stdout
  println "DEBUG" "Selected value: ${opts[${answer}]}"
  return $answer
}

# Command     : validIP [IP address]
# Description : A helper function to validate input for valid IPv4 address
# Parameters  : IP address  >  the IPv4 address to validate
# Return      : 1 on success
validIP() {
  local  ip=$1
  local  stat=1

  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    OIFS=$IFS
    IFS='.'
    ip=($ip)
    IFS=$OIFS
    [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
    stat=$?
  fi
  return $stat
}

# Command     : getDirs [path to folder]
# Description : A helper function to get all subdirs for a directory
# Parameters  : path to folder    >   full path to folder, subdirs of this folder returned
# Return      : populates ${dirs} array
getDirs() {
  if [[ ! -d "$1" ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: Missing folder: $1"
    waitForInput && return 1
  fi
  dirs=()
  while IFS= read -r -d '' dir; do
    dirs+=("$(basename ${dir})")
  done < <(find "${1}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
  return 0
}

# Command     : selectDir [type] [dir1 dir2 ...]
# Description : A helper function to selectOption() specifically for directory selection
# Parameters  : type  >  'wallet' or 'pool' 
#             : dirX  >  array of dirs to include in selection, '[Esc] Cancel' option added to all selections
# Return      : populates ${dir_name} variable
selectDir() {
  exec >&6 # normal stdout
  local type=$1 && shift
  dirs=( "$@" )
  dirs+=("[Esc] Cancel")
  selectOption "${dirs[@]}"
  dir_name=${dirs[$?]}
  [[ "${dir_name}" = "[Esc] Cancel" ]] && return 1
  exec >&8 # custom stdout
  println "DEBUG" "Selected ${type}: ${dir_name}"
}

# Command     : selectWallet [mode] [file1 file2 ... | wallet_name1 wallet_name1 ... ]
# Description : A helper function to select a CNTools wallet
# Parameters  : mode       >  a string containing some of the following: none|non-reg|reg|balance|delegate|reward to be added next to wallet in selection menu
#             : arg array  >  array of files required to exist in wallet folder for it to be selectable **OR** the name of wallet to exclude from selection
# Return      : populates ${wallet_name} variable with wallet selection
selectWallet() {
  wallet_dirs=()
  mode=$1 && shift
  if ! getDirs "${WALLET_FOLDER}"; then return 1; fi # dirs() array populated with all wallet folders
  if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" ]]; then
    tput sc
    wallet_count=${#dirs[@]}
    [[ ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]] && println "OFF" "Balance checking wallets..."
  fi
  for dir in "${dirs[@]}"; do
    for arg in "$@"; do # check if wallet is missing a required file or name matches execution, if so hide it
      [[ ${arg} == *"."* && ! -f "${WALLET_FOLDER}/${dir}/${arg}" ]] && continue 2
      [[ ${arg} != *"."* && ${dir} = "${arg}" ]] && continue 2
    done
    if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" && ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then
      if [[ ${mode} = "non-reg" ]]; then
        if isWalletRegistered ${dir}; then continue; fi
      elif [[ ${mode} = "reg" ]]; then
        if ! isWalletRegistered ${dir}; then continue; fi
      fi
      if [[ ${mode} = "balance" || ${mode} = "non-reg" || ${mode} = "reg" ]]; then
        getBaseAddress ${dir}
        getPayAddress ${dir}
        getBalance ${base_addr}
        base_lovelace=${lovelace}
        getBalance ${pay_addr}
        pay_lovelace=${lovelace}
        if [[ ${base_lovelace} -gt 0 && ${pay_lovelace} -gt 0 ]]; then
          wallet_dirs+=("${dir} (Funds: ${FG_CYAN}$(formatLovelace ${base_lovelace})${NC} Ada | Enterprise Funds: ${FG_CYAN}$(formatLovelace ${pay_lovelace})${NC} Ada)")
        elif [[ ${pay_lovelace} -gt 0 ]]; then
          wallet_dirs+=("${dir} (Enterprise Funds: ${FG_CYAN}$(formatLovelace ${pay_lovelace})${NC} Ada)")
        else
          wallet_dirs+=("${dir} (Funds: ${FG_CYAN}$(formatLovelace ${base_lovelace})${NC} Ada)")
        fi
      elif [[ ${mode} = "delegate" ]]; then
        getBaseAddress ${dir}
        getBalance ${base_addr}
        if getRewardAddress ${dir}; then
          delegation_pool_id=$(${CCLI} query stake-address-info ${ERA_IDENTIFIER} ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address "${reward_addr}" | jq -r '.[0].delegation // empty')
          unset poolName
          if [[ -n ${delegation_pool_id} ]]; then
            while IFS= read -r -d '' pool; do
              getPoolID "$(basename ${pool})"
              if [[ "${pool_id_bech32}" = "${delegation_pool_id}" ]]; then
                poolName=$(basename ${pool}) && break
              fi
            done < <(find "${POOL_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
          fi
          if [[ -n ${poolName} ]]; then
            wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} Ada - ${FG_RED}delegated${NC} to ${FG_GREEN}${poolName}${NC})")
          elif [[ -n ${delegation_pool_id} ]]; then
            wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} Ada - ${FG_RED}delegated${NC} to external address)")
          else
            wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} Ada)")
          fi
        else
          wallet_dirs+=("${dir} (${FG_CYAN}$(formatLovelace ${lovelace})${NC} Ada)")
        fi
      elif [[ ${mode} = "reward" ]]; then
        getRewards ${dir}
        [[ ${reward_lovelace} -le 0 ]] && continue
        wallet_dirs+=("${dir} (Rewards: ${FG_CYAN}$(formatLovelace ${reward_lovelace})${NC} Ada)")
      fi
    else
      wallet_dirs+=("${dir}")
    fi
  done
  if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" ]]; then tput rc && tput ed; fi
  if [[ ${#wallet_dirs[@]} -eq 0 ]]; then
    if [[ ${mode} = "balance" ]]; then
      println "ERROR" "${FG_YELLOW}WARN${NC}: No wallets with funds available for selection!"
    elif [[ ${mode} = "delegate" ]]; then
      println "ERROR" "${FG_YELLOW}WARN${NC}: No wallets available that can be delegated or used as pool pledge/owner/reward wallet!"
    elif [[ ${mode} = "reward" ]]; then
      println "ERROR" "${FG_YELLOW}WARN${NC}: No wallets available that have rewards to withdraw!"
    else
      println "ERROR" "${FG_YELLOW}WARN${NC}: No wallets available for selection!"
    fi
    return 1
  fi
  if ! selectDir "wallet" "${wallet_dirs[@]}"; then return 1; fi # ${dir_name} populated by selectDir function
  wallet_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : selectPool [mode] [file1 file2 ...]
# Description : A helper function to select a CNTools pool
# Parameters  : mode   >  a string containing some of the following: reg|non-reg
#             : fileX  >  array of files required to exist in pool folder for it to be selectable
# Return      : populates ${pool_name} variable with pool selection
selectPool() {
  pool_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${POOL_FOLDER}"; then return 1; fi # dirs() array populated with all pool folders
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if pool is missing a required file and if so hide it
      [[ -f "${POOL_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${POOL_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "non-reg" ]]; then
      [[ -f "${POOL_FOLDER}/${dir}/${POOL_REGCERT_FILENAME}" ]] && continue
    elif [[ ${mode} = "reg" ]]; then
      [[ ! -f "${POOL_FOLDER}/${dir}/${POOL_REGCERT_FILENAME}" ]] && continue
    fi
    pool_dirs+=("${dir}")
  done
  if [[ ${#pool_dirs[@]} -eq 0 ]]; then
    println "ERROR" "${FG_YELLOW}WARN${NC}: No pools available that can be selected!"
    [[ ${enc_req_files} -gt 0 ]] && println "DEBUG" "* Encrypted pools not listed *"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && println "DEBUG" "${FG_YELLOW}encrypted pools found but NOT listed, please decrypt to show${NC}"
  if ! selectDir "pool" "${pool_dirs[@]}"; then return 1; fi # ${dir_name} populated by selectDir function
  pool_name="${dir_name}"
}


# Command     : getPassword [optional: confirm]
# Description : Get password from user on STDIN
# Parameters  : confirm  >  [optional] force user to provide password twice for confirmation
# Return      : populates ${password} variable, make sure to unset variable when done
getPassword() {
  exec >&6 # normal stdout
  sleep 0.1
  while true; do
    readPassword "Enter password (length >= 8)"
    password=${read_password} && unset read_password
    if [ ${#password} -lt 8 ]; then
      echo
      echo -e "${FG_RED}ERROR${NC}: password length too short, please use a minimum of 8 characters."
      echo
      echo "Press q to abort or any other key to retry"
      read -rsn 1 abort
      [[ ${abort} = "q" ]] && unset password && exec >&8 && return 1
      echo
      continue
    fi
    if [[ "$1" = "confirm" ]]; then
      echo && readPassword "Confirm password"
      check_password=${read_password} && unset read_password
      if [[ "${password}" != "${check_password}" ]]; then
        echo
        echo -e "${FG_RED}ERROR${NC}: password missmatch!"
        echo
        echo "Press q to abort or any other key to retry"
        read -rsn 1 abort
        [[ ${abort} = "q" ]] && unset password && unset check_password && exec >&8 && return 1
        echo
      else
        echo && unset check_password && exec >&8 && return
      fi
    else
      echo && exec >&8 && return
    fi
  done
  exec >&8 # custom stdout
}
readPassword() {
  read_password=""
  prompt="$1: "
  while IFS= read -p "${prompt}" -r -s -n 1 char; do
    if [[ ${char} == $'\0' ]]; then break; fi
    if [[ ${char} == $'\b' ]]; then
      [[ ${#read_password} -gt 0 ]] && printf "\033[1D\033[0K" && read_password=${read_password%?}
      prompt=''
    else
      prompt='*'
      read_password+="${char}"
    fi
  done
}


# Command     : encryptFile [file] [password]
# Description : Encrypt file with GPG
# Parameters  : file      >  Path for file to encrypt, will get a new .gpg file extention added to filename
#             : password  >  Password to encrypt file with
encryptFile() {
  exec >&6 # normal stdout
  sleep 0.1
  echo "${2}" | gpg --symmetric --yes --batch --cipher-algo AES256 --passphrase-fd 0 --output "${1}.gpg" "${1}" &>/dev/null && \
  safeDel "${1}" >/dev/null || {
    exec >&8 # custom stdout
    println "ERROR" "${FG_RED}ERROR${NC}: failed to encrypt ${1}"
    return 1
  }
  exec >&8 # custom stdout
  println "DEBUG" "${1} successfully encrypted"
}


# Command     : decryptFile [file] [password]
# Description : Decrypt file with GPG
# Parameters  : file      >  Path for file to decrypt, file extension .gpg required
#             : password  >  Password to decrypt file with
decryptFile() {
  exec >&6 # normal stdout
  sleep 0.1
  echo "${2}" | gpg --decrypt --batch --yes --passphrase-fd 0 --output "${1%.*}" "${1}" &>/dev/null && \
  rm -f "${1}" || {
    exec >&8 # custom stdout
    println "ERROR" "${FG_RED}ERROR${NC}: failed to decrypt ${1}"
    return 1
  }
  exec >&8 # custom stdout
  println "DEBUG" "${1} successfully decrypted"
}


# Command     : getNodeMetrics
# Description : Get latest metrics from the node
# Return      : populates ${node_metrics} variable
getNodeMetrics() {
  node_metrics=$(curl -s -m ${EKG_TIMEOUT} -H 'Accept: application/json' "http://${EKG_HOST}:${EKG_PORT}/" 2>/dev/null)
}

# Command     : getBlockTip
# Description : Get latest block number
getBlockTip() {
  getNodeMetrics
  jq '.cardano.node.ChainDB.metrics.blockNum.int.val //0' <<< "${node_metrics}"
}

# Command     : getSlotTip
# Description : Get latest slot number
getSlotTip() {
  getNodeMetrics
  jq '.cardano.node.ChainDB.metrics.slotNum.int.val //0' <<< "${node_metrics}"
}

# Command     : getSlotTipRef
# Description : Offline calculation of reference tip
getSlotTipRef() {
  current_time_sec=$(date -u +%s)
  if [[ "${PROTOCOL_IDENTIFIER}" = "--cardano-mode" ]]; then
    # Combinator network
    byron_slots=$(( $(cat $SHELLEY_TRANS_FILENAME) * BYRON_EPOCH_LENGTH )) # since this point will only be reached once we're in Shelley phase
    byron_end_time=$(( BYRON_GENESIS_START_SEC + ( $(cat $SHELLEY_TRANS_FILENAME) * BYRON_EPOCH_LENGTH * BYRON_SLOT_LENGTH ) ))
    if [[ "${current_time_sec}" -lt "${byron_end_time}" ]]; then
      # In Byron phase
      echo $(( ( current_time_sec - BYRON_GENESIS_START_SEC ) / BYRON_SLOT_LENGTH ))
    else
      # In Shelley phase
      echo $(( byron_slots + (( current_time_sec - byron_end_time ) / SLOT_LENGTH ) ))
    fi
  else
    # Shelley Mode only, no Byron slots
    echo $(( ( current_time_sec - SHELLEY_GENESIS_START_SEC ) / SLOT_LENGTH ))
  fi
}

# Command     : getSlotTipDiff
# Description : Get difference between current node slot tip and calculated tip based on genesis file
getSlotTipDiff() {
  tip_ref=$(getSlotTipRef)
  tip_node=$(getSlotTip)
  echo $(( tip_ref - tip_node ))
}

# Command     : slotInterval
# Description : Calculate expected interval between blocks
slotInterval() {
  [[ $(echo "${DECENTRALISATION} < 0.5" | bc) -eq 1 ]] && local d=0.5 || local d=${DECENTRALISATION}
  echo "(${SLOT_LENGTH} / ${ACTIVE_SLOTS_COEFF} / ${d}) + 0.5" | bc -l | awk '{printf "%.0f\n", $1}'
}

# Command     : getEpoch
# Description : Offline calculation of current epoch based on genesis file
getEpoch() {
  current_time_sec=$(date -u +%s)
  if [[ "${PROTOCOL_IDENTIFIER}" == "--cardano-mode" ]]; then
    byron_end_time=$(( BYRON_GENESIS_START_SEC + ( $(cat $SHELLEY_TRANS_FILENAME) * BYRON_EPOCH_LENGTH * BYRON_SLOT_LENGTH ) ))
    echo $(( $(cat $SHELLEY_TRANS_FILENAME) + ( (current_time_sec - byron_end_time) / SLOT_LENGTH / EPOCH_LENGTH ) ))
  else
    echo $(( (current_time_sec - SHELLEY_GENESIS_START_SEC) / SLOT_LENGTH / EPOCH_LENGTH ))
  fi
}

# Command     : getTimeUntilNextEpoch
# Description : Offline calculation of time until next epoch
timeUntilNextEpoch() {
  current_epoch=$(getEpoch)
  current_time_sec=$(date -u +%s)
  if [[ "${PROTOCOL_IDENTIFIER}" = "--cardano-mode" ]]; then
    showTimeLeft $(( ($(cat $SHELLEY_TRANS_FILENAME) * BYRON_SLOT_LENGTH * BYRON_EPOCH_LENGTH) + ( ( current_epoch + 1 - $(cat $SHELLEY_TRANS_FILENAME) ) * SLOT_LENGTH * EPOCH_LENGTH ) - current_time_sec + BYRON_GENESIS_START_SEC ))
  else
    showTimeLeft $(( ( ( ( (current_time_sec - SHELLEY_GENESIS_START_SEC) / SLOT_LENGTH / EPOCH_LENGTH ) + 1 ) * SLOT_LENGTH * EPOCH_LENGTH ) - current_time_sec + SHELLEY_GENESIS_START_SEC ))
  fi
}
showTimeLeft() {
  if [[ -z "${1##*[!0-9]*}" ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: time must be an integer number [$1]"
    return 1
  fi
  printf '%02dh:%02dm:%02ds\n' $(($1/3600)) $(($1%3600/60)) $(($1%60))
}

# Command     : getCurrentKESperiod
# Description : Offline calculation of current KES period based on reference tip
getCurrentKESperiod() {
  tip_ref=$(getSlotTipRef)
  current_kes_period=$(( tip_ref / SLOTS_PER_KES_PERIOD ))
}

# Command     : kesExpiration [Pool KES start period]
# Description : Calculate KES expiration
# Parameters  : Pool KES start period  >  KES start stored in POOL_CURRENT_KES_START file for pool in question
# Return      : expiration date can be accessed through variable ${expiration_date} after function has been executed
kesExpiration() {
  if [[ -z "${1##*[!0-9]*}" ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: KES start period must be an integer number [$1]"
    return 1
  fi
  pool_kes_start_period=$1
  getCurrentKESperiod
  remaining_kes_periods=$(( MAX_KES_EVOLUTIONS - ( current_kes_period - pool_kes_start_period ) ))
  current_time_sec=$(date -u +%s)
  expiration_time_sec=$(( current_time_sec - ( SLOT_LENGTH * (tip_ref % SLOTS_PER_KES_PERIOD) ) + ( SLOT_LENGTH * SLOTS_PER_KES_PERIOD * remaining_kes_periods ) ))
  expiration_time_sec_diff=$(( expiration_time_sec - current_time_sec ))
  expiration_date=$(date '+%F %T %Z' --date=@${expiration_time_sec})
}

# Command     : waitNewBlockCreated [optional: silent]
# Description : Wait for a new block to be created
# Parameters  : silent  >  any argument to function will prevent DEBUG output to tty
waitNewBlockCreated() {
  counter=${TIMEOUT_NO_OF_SLOTS}
  [[ $# -eq 0 ]] && println "DEBUG" "Waiting for new block to be created (timeout = ${counter} slots, $(( counter * SLOT_LENGTH ))s)"
  [[ $# -eq 0 ]] && println "DEBUG" "${FG_BLUE}INFO${NC}: press any key to cancel and return (won't stop transaction)"
  initialTip=$(getBlockTip)
  actualTip=${initialTip}

  while [ "${actualTip}" = "${initialTip}" ]; do
    read -r -n 1 -s -t ${SLOT_LENGTH} abort
    if [[ $? -eq 0 ]]; then
      println "${FG_YELLOW}WARN${NC}: aborted!! transaction still in queue!"
      return 1
    fi
    actualTip=$(getBlockTip)
    counter=$((counter - SLOT_LENGTH))
    if [ ${counter} -lt ${SLOT_LENGTH} ]; then
      println "${FG_YELLOW}WARN${NC}: waited $(( TIMEOUT_NO_OF_SLOTS * SLOT_LENGTH )) secs and no new block created"
      return 1
    fi
  done
  println "LOG" "New block was created - ${actualTip}"
}

# Command     : verifyTx [address]
# Description : Verify that the transaction was successfully registered by checking address balance against $newBalance
# Parameters  : address  >  the address to compare with
verifyTx() {
  if ! waitNewBlockCreated; then return 1; fi
  getBalance ${1}
  while [[ ${lovelace} -ne ${newBalance} ]]; do
    println "DEBUG" "${FG_YELLOW}WARN${NC}: Balance mismatch, transaction not included in latest block... waiting for next block!"
    println "LOG" "$(formatLovelace ${lovelace}) != $(formatLovelace ${newBalance})"
    if ! waitNewBlockCreated "silent"; then return 1; fi
    getBalance ${1}
  done
  return 0
}

# Command     : validateDecimalNbr [decimalNbr]
# Description : validate decimal number
# Parameters  : decimalNbr  >  decimal number
validateDecimalNbr() {
  re_decimal_nbr='^[0-9]+([.][0-9]+)?$'
  if [[ $1 =~ ${re_decimal_nbr} ]]; then
    return 0
  else
    return 1
  fi
}

# Command     : formatLovelace
# Description : Pretty print Lovelace value
# Parameters  : Lovelace  >  Amount in Lovelace
formatLovelace() {
  re_int_nbr='^[0-9]+$'
  if [[ $1 =~ ${re_int_nbr} ]]; then
    [[ $1 -le 999999 ]] && echo "0.$1" && return
    printf '%s.%s' "$(sed ':a;s/\B[0-9]\{3\}\>/,&/;ta' <<< ${1::-6})" "${1: -6}"
  else
    println "ERROR" "${FG_RED}ERROR${NC}: must be a valid integer number"
    return 1
  fi
}

# Command     : formatAda
# Description : Pretty print Ada value
# Parameters  : Ada  >  Amount in Ada
formatAda() {
  re_int_nbr='^[0-9]+$'
  if [[ $1 =~ ${re_int_nbr} ]]; then
    sed ':a;s/\B[0-9]\{3\}\>/,&/;ta' <<< $1
  else
    println "ERROR" "${FG_RED}ERROR${NC}: must be a valid integer number"
    return 1
  fi
}

# Command     : AdaToLovelace [Ada]
# Description : Convert number in Ada to Lovelace
# Parameters  : Ada  >  Amount in Ada, decimal number accepted
AdaToLovelace() {
  if validateDecimalNbr $1; then
    echo "$1 * 1000000 / 1" | bc # /1 is to remove decimals from bc command
  else
    println "ERROR" "${FG_RED}ERROR${NC}: must be a valid integer or decimal number"
    return 1
  fi
}

# Command     : pctToFraction [percent]
# Description : Convert number as percent to fraction
# Parameters  : percent  >  number to be converted in range 0-100
pctToFraction() {
  if validateDecimalNbr $1; then
    if [[ $(bc <<< "$1 >= 0" ) -eq 0 || $(bc <<< "$1 <= 100" ) -eq 0 ]]; then
      println "ERROR" "${FG_RED}ERROR${NC}: must be a number between 0-100"
      return 1
    else
      echo "x=$1 / 100; if(x<1) print 0; x" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
    fi
  else
    println "ERROR" "${FG_RED}ERROR${NC}: must be a valid integer or decimal number"
    return 1
  fi
}

# Command     : fractionToPCT [fraction]
# Description : Convert fraction number to precent
# Parameters  : fraction  >  number to be converted
fractionToPCT() {
  if validateDecimalNbr $1; then
    if (( $(bc <<<"$1 > 0") )); then
      echo "x=$1 * 100; if(x<1) print 0; x" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
    else
      echo 0
    fi
  else
    println "ERROR" "${FG_RED}ERROR${NC}: must be a valid decimal number"
    return 1
  fi
}

# Command     : getPoolID [pool name]
# Description : create and save pool id in hex & bech32 encoded format
# Parameters  : pool name  >  the name of the pool
# Return      : populates ${pool_id} & ${pool_id_bech32}
getPoolID() {
  pool_id_file="${POOL_FOLDER}/${1}/${POOL_ID_FILENAME}"
  pool_id_bech32_file="${POOL_FOLDER}/${1}/${POOL_ID_FILENAME}-bech32"
  [[ -f ${pool_id_file} && -f ${pool_id_bech32_file} ]] && pool_id=$(cat ${pool_id_file}) && pool_id_bech32=$(cat ${pool_id_bech32_file}) && return 0
  pool_id=""
  pool_id_bech32=""
  pool_coldkey_vk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}"
  if [[ -f ${pool_coldkey_vk_file} ]]; then
    println "ACTION" "${CCLI} stake-pool id --cold-verification-key-file \"${pool_coldkey_vk_file}\" --output-format hex"
    println "ACTION" "${CCLI} stake-pool id --cold-verification-key-file \"${pool_coldkey_vk_file}\""
    if ! pool_id=$(${CCLI} stake-pool id --cold-verification-key-file "${pool_coldkey_vk_file}" --output-format hex 2>/dev/null) || \
       ! pool_id_bech32=$(${CCLI} stake-pool id --cold-verification-key-file "${pool_coldkey_vk_file}" 2>/dev/null); then
      return 1
    fi
    echo ${pool_id} > "${pool_id_file}"
    echo ${pool_id_bech32} > "${pool_id_bech32_file}"
    return 0
  fi
  return 1
}

# Command     : getPayAddress [wallet name]
# Description : create and save payment address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${pay_addr}
getPayAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_addr_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_ADDR_FILENAME}"
  [[ -f ${payment_addr_file} ]] && pay_addr=$(cat "${payment_addr_file}") && return 0
  pay_addr=""
  if [[ -f "${payment_vk_file}" ]]; then
    println "ACTION" "${CCLI} address build --payment-verification-key-file \"${payment_vk_file}\" --out-file \"${payment_addr_file}\" ${NETWORK_IDENTIFIER}"
    if ${CCLI} address build --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      pay_addr=$(cat "${payment_addr_file}")
      return 0
    fi
  fi
  return 1
}

# Command     : getBaseAddress [wallet name] | [payment.vkey] [stake.vkey]
# Description : create, store and save base address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${base_addr}
getBaseAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  base_addr_file="${WALLET_FOLDER}/${1}/${WALLET_BASE_ADDR_FILENAME}"
  [[ -f ${base_addr_file} ]] && base_addr=$(cat "${base_addr_file}") && return 0
  base_addr=""
  if [[ -f "${payment_vk_file}" && -f "${stake_vk_file}" ]]; then
    println "ACTION" "${CCLI} address build --payment-verification-key-file \"${payment_vk_file}\" --stake-verification-key-file \"${stake_vk_file}\" --out-file \"${base_addr_file}\" ${NETWORK_IDENTIFIER}"
    if ${CCLI} address build --payment-verification-key-file "${payment_vk_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      base_addr=$(cat "${base_addr_file}")
      return 0
    fi
  elif [[ $# -eq 2 && -f "${1}" && -f "${2}" ]]; then
    base_addr=$(${CCLI} address build --payment-verification-key-file "${1}" --stake-verification-key-file "${2}" ${NETWORK_IDENTIFIER} 2>/dev/null)
  fi
  return 1
}

# Command     : getRewardAddress [wallet name]
# Description : create, store and save reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_addr}
getRewardAddress() {
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_addr_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_ADDR_FILENAME}"
  [[ -f ${stake_addr_file} ]] && reward_addr=$(cat "${stake_addr_file}") && return 0
  reward_addr=""
  if [[ -f "${stake_vk_file}" ]]; then
    println "ACTION" "${CCLI} stake-address build --stake-verification-key-file \"${stake_vk_file}\" --out-file \"${stake_addr_file}\" ${NETWORK_IDENTIFIER}"
    if ${CCLI} stake-address build --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      reward_addr=$(cat "${stake_addr_file}")
      return 0
    fi
  elif [[ -f "${1}" ]]; then
    reward_addr=$(${CCLI} stake-address build --stake-verification-key-file "${1}" ${NETWORK_IDENTIFIER} 2>/dev/null)
  fi
  return 1
}

# Command     : getRewardAddressFromKey [stake vkey]
# Description : get reward address from a stake key
# Parameters  : stake key  >  path to stake.vkey file
# Return      : populates ${reward_addr}
getRewardAddressFromKey() {
  println "ACTION" "${CCLI} stake-address build --stake-verification-key-file \"${1}\" ${NETWORK_IDENTIFIER}"
  reward_addr=$(${CCLI} stake-address build --stake-verification-key-file "${1}" ${NETWORK_IDENTIFIER} 2>/dev/null)
}

# Command     : getAddressInfo [address]
# Description : get address info from from node
# Parameters  : address  >  the wallet address to query
# Return      : populates ${address_info}
getAddressInfo() {
  println "ACTION" "${CCLI} address info --address $1"
  address_info=$(${CCLI} address info --address $1)
}

# Command     : getBalance [address]
# Description : check balance for provided address
# Parameters  : address  >  the wallet address to query
# Return      : populates ${lovelace} & ${utx0_count}
getBalance() {
  lovelace=0
  utx0_count=0

  [[ -z $1 ]] && return 1

  if ! ${CCLI} query utxo ${ERA_IDENTIFIER} ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address "${1}" > "${TMP_FOLDER}/fullUtxo.out"; then return 1; fi
  tail -n +3 "${TMP_FOLDER}"/fullUtxo.out | sort -k3 -nr > "${TMP_FOLDER}"/balance.out

  while read -r utxo; do
    utx0_count=$(( utx0_count + 1 ))
    lovelace=$(( lovelace + $(awk '{ print $3 }' <<< "${utxo}") ))
  done <"${TMP_FOLDER}"/balance.out
}


# Command     : getRewards [wallet name]
# Description : check balance of reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_lovelace}
getRewards() {
  reward_lovelace=-1
  if isWalletRegistered $1; then
    reward_lovelace=0
    for reward_entry in $(jq -r '.[] | @base64' <<< "${stake_address_info}"); do
      _jq() { base64 -d <<< ${reward_entry} | jq -r "${1}"; }
      reward_lovelace=$(( reward_lovelace + $(_jq '.rewardAccountBalance //0') ))
    done
  fi
}
# Command     : getRewardsFromAddr [stake address]
# Description : check balance of reward address
# Parameters  : stake address  >  the address from stake.vkey
# Return      : populates ${reward_lovelace}
getRewardsFromAddr() {
  println "ACTION" "${CCLI} query stake-address-info ${ERA_IDENTIFIER} ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address ${1}"
  stake_address_info=$(${CCLI} query stake-address-info ${ERA_IDENTIFIER} ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address ${1})
  reward_lovelace=0
  for reward_entry in $(jq -r '.[] | @base64' <<< "${stake_address_info}"); do
    _jq() { base64 -d <<< ${reward_entry} | jq -r "${1}"; }
    reward_lovelace=$(( reward_lovelace + $(_jq '.rewardAccountBalance //0') ))
  done
}

# Command     : isWalletRegistered [wallet name]
# Description : check if wallet is registered on chain
# Parameters  : wallet name  >  the name of the wallet
isWalletRegistered() {
  if getRewardAddress $1; then
    println "ACTION" "${CCLI} query stake-address-info ${ERA_IDENTIFIER} ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address ${reward_addr}"
    stake_address_info=$(${CCLI} query stake-address-info ${ERA_IDENTIFIER} ${PROTOCOL_IDENTIFIER} ${NETWORK_IDENTIFIER} --address ${reward_addr})
    [[ -n "${stake_address_info}" && $(jq -r 'length' <<< ${stake_address_info}) -gt 0 ]] && return 0
  fi
  return 1
}

# Command     : getWalletType [wallet name|sign key]
# Description : check if wallet is a hardware wallet, 0=yes, 1=cli, 2=cli & encrypted, 3=signing keys missing, 4=verification keys missing
# Parameters  : wallet name|sign key  >  the name of the wallet or path to sign key
getWalletType() {
  if [[ -f $1 ]]; then # Sign key
    [[ $(jq -r '.description' "${1}") = *"Hardware"* ]] && return 0
    [[ -f "${1}" ]] && return 1
    [[ -f "${1}.gpg" ]] && return 2
  elif [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}" && -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}" ]]; then # CNTools wallet
    payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
    payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}"
    stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
    stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}"
    if [[ $(jq -r '.description' "${payment_vk_file}") = *"Hardware"* ]]; then
      payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_PAY_SK_FILENAME}"
      stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_STAKE_SK_FILENAME}"
      ([[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]]) && return 3 || return 0
    elif [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}.gpg" || -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}.gpg" ]]; then
      return 2
    else    
      ([[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]]) && return 3 || return 1
    fi
  else
    return 4
  fi
}

# Command     : getSlotAndTTL
# Description : query node for slot tip and calculate/get TTL from input depending on op_mode
getSlotAndTTL() {
  currSlot=$(getSlotTip)
  if [[ ${op_mode} = "hybrid" ]]; then
    println "DEBUG" "\nHow long do you want the transaction to be valid?"
    sleep 0.1 && read -r -p "TTL (in seconds, default: 1800/30min): " ttl_enter 2>&6 && println "LOG" "TTL (in seconds, default: 1800/30min): ${ttl_enter}"
    ttl_enter=${ttl_enter:-1800}
    if [[ ! ${ttl_enter} =~ ^[0-9]+$ ]]; then
      println "ERROR" "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}"
      return 1
    fi
    ttl=$(( currSlot + (ttl_enter/SLOT_LENGTH) ))
  else
    ttl=$(( currSlot + (600/SLOT_LENGTH) )) # TTL default: 10min
  fi
  println "LOG" "Current slot is ${currSlot}, setting ttl to ${ttl}"
}

# Command     : parseWalletUTXOs
# Description : loop and parse all UTXO in ${TMP_FOLDER}/balance.out file generated by getBalance() function needed to be run before this function
parseWalletUTXOs() {
  [[ ! -s "${TMP_FOLDER}"/balance.out ]] && println "ERROR" "\n${FG_RED}ERROR${NC}: wallet empty!" && return 1
  # Use all available utxo in source address
  println "LOG" "Using UTxO's:"
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}" | sed -e "s@\"@@g")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    println "LOG" "TxHash: ${in_addr}#${idx}"
    println "LOG" "Ada: $(formatLovelace ${utxo_balance})"
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <"${TMP_FOLDER}"/balance.out
}

# Command     : buildOfflineJSON [type]
# Description : construct a json containing all data for offline signing
# Parameters  : type  >  type of transaction, e.g 'payment'
buildOfflineJSON() {
  offlineJSON="{}"
  if ! offlineJSON=$(jq ". += { id: $(date +%s) }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { type: \"${1}\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-created\": \"$(date --iso-8601=s)\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-expire\": \"$(date --iso-8601=s --date="@$(($(date +%s)+ttl_enter))")\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { ttl: ${ttl} }" <<< ${offlineJSON}); then return 1; fi
}

# Command     : registerStakeWallet [wallet name] [optional: skip validation]
# Description : Register stake keys on chain and move funds from payment address to payment base address
# Parameters  : wallet name      >  the name of the wallet
# Parameters  : skip validation  >  [optional] [true|false] if true, skip wallet registration check
registerStakeWallet() {

  wallet_name=$1
  wallet_source="base"

  if [[ -z $2 || $2 = "false" ]]; then
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name}${NC} not registered on chain"
    waitForInput "press any key to continue with registration"
  fi

  stake_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_VK_FILENAME}"
  stake_cert_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_CERT_FILENAME}"
  
  getBaseAddress "${wallet_name}"
  getBalance ${base_addr}
  if ! parseWalletUTXOs; then return 1; fi
  
  println "ACTION" "${CCLI} stake-address registration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_cert_file}"
  if ! ${CCLI} stake-address registration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_cert_file}"; then return 1; fi

  if ! getSlotAndTTL; then return 1; fi
  keyDeposit=$(jq -r '.keyDeposit' "${TMP_FOLDER}"/protparams.json)
  println "LOG" "Key Deposit is ${keyDeposit}"

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${stake_cert_file} ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${stake_cert_file} ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ ${lovelace} -lt $(( min_fee + keyDeposit )) ]]; then
    println "ERROR" "\n${FG_RED}ERROR${NC}: Not enough Ada in wallet ($(formatLovelace ${lovelace}) < $(formatLovelace ${min_fee}) + $(formatLovelace ${keyDeposit}))"
    return 1
  fi

  newBalance=$(( lovelace - min_fee - keyDeposit ))
  tx_out="--tx-out ${base_addr}+${newBalance}"

  println "LOG" "New balance after tx fee and key deposit is $(formatLovelace ${newBalance}) Ada ($(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${keyDeposit}))"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file ${stake_cert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: $(( min_fee + keyDeposit )) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${payment_sk_file})${NC}" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
  echo
  if ! verifyTx ${base_addr}; then return 1; fi

  reward_lovelace=0
}

# Command     : deregisterStakeWallet
# Description : Deregister stake keys/wallet from chain, key deposit fee returned to wallets base address
deregisterStakeWallet() {

  wallet_source="base"

  stake_dereg_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_DEREG_FILENAME}"
  println "ACTION" "${CCLI} stake-address deregistration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_dereg_file}"
  if ! ${CCLI} stake-address deregistration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_dereg_file}"; then return 1; fi

  if ! parseWalletUTXOs; then return 1; fi
  if ! getSlotAndTTL; then return 1; fi
  
  keyDeposit=$(jq -r '.keyDeposit' "${TMP_FOLDER}"/protparams.json)
  println "LOG" "Key Deposit is ${keyDeposit}"

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${stake_dereg_file} ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${stake_dereg_file} ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ $(( lovelace + keyDeposit - min_fee )) -lt 0 ]]; then
    println "ERROR" "\n${FG_RED}ERROR${NC}: Not enough Ada in wallet ($(formatLovelace ${lovelace}) + $(formatLovelace ${keyDeposit}) < $(formatLovelace ${min_fee}))"
    return 1
  fi

  newBalance=$(( lovelace + keyDeposit - min_fee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"

  println "LOG" "New balance after returned key deposit and subtracted tx fee is $(formatLovelace ${newBalance}) Ada ($(formatLovelace ${lovelace}) + $(formatLovelace ${keyDeposit}) - $(formatLovelace ${min_fee}))"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file ${stake_dereg_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"amount-returned\": ${keyDeposit} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: ${min_fee} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${payment_sk_file})${NC}" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : sendAda
# Description : send Ada from source to destination
#             : can also be used to defrag address by sending all to self
#             : supports fee to be payed by sender(default) or receiver by reducing amount to send
sendAda() {

  [[ $(cat "${WALLET_FOLDER}/${s_wallet}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${s_addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  getBalance ${s_addr}
  if ! parseWalletUTXOs; then return 1; fi
  if ! getSlotAndTTL; then return 1; fi

  [[ ${lovelace} -eq ${amount_lovelace} ]] && outCount=1 || outCount=2

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${d_addr}+0 --invalid-hereafter ${ttl} --fee 0 ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${d_addr}+0 --invalid-hereafter ${ttl} --fee 0 ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count ${outCount}
    ${NETWORK_IDENTIFIER}
    --witness-count 1
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  # Sanity checks
  if [[ ${include_fee} = "no" ]]; then
    if [[ ${lovelace} -lt $(( amount_lovelace + min_fee )) ]]; then
      println "ERROR" "${FG_RED}ERROR${NC}: Not enough Ada in address ($(formatLovelace ${lovelace}) < $(formatLovelace ${amount_lovelace}) + $(formatLovelace ${min_fee}))"
      return 1
    fi
  else
    if [[ ${amount_lovelace} -lt ${min_fee} ]]; then
      println "ERROR" "${FG_RED}ERROR${NC}: Fee deducted from Ada to send, amount can not be less than fee ($(formatLovelace ${amount_lovelace}) < $(formatLovelace ${min_fee}))"
      return 1
    elif [[ ${lovelace} -lt ${amount_lovelace} ]]; then
      println "ERROR" "${FG_RED}ERROR${NC}: Not enough Ada in address ($(formatLovelace ${lovelace}) < $(formatLovelace ${amount_lovelace}))"
      return 1
    fi
  fi

  if [[ ${include_fee} = "no" ]]; then
    tx_out="--tx-out ${d_addr}+${amount_lovelace}"
  else
    tx_out="--tx-out ${d_addr}+$(( amount_lovelace - min_fee ))"
    println "LOG" "New amount to send after fee deduction is $(formatLovelace $(( amount_lovelace - min_fee ))) Ada ($(formatLovelace ${amount_lovelace}) - $(formatLovelace ${min_fee}))"
  fi

  newBalance=$(( lovelace - amount_lovelace ))
  if [[ ${include_fee} = "no" ]]; then
    newBalance=$(( lovelace - amount_lovelace - min_fee ))
    tx_out="${tx_out} --tx-out ${s_addr}+${newBalance}"
    println "LOG" "Balance left to be returned in used UTxO's is $(formatLovelace ${newBalance}) Ada ($(formatLovelace ${lovelace}) - $(formatLovelace ${amount_lovelace}) - $(formatLovelace ${min_fee}))"
  elif [[ ${outCount} -eq 2 ]]; then
    tx_out="${tx_out} --tx-out ${s_addr}+$(( lovelace - amount_lovelace ))"
    println "LOG" "Balance left to be returned in used UTxO's is $(formatLovelace $(( lovelace - amount_lovelace ))) Ada ($(formatLovelace ${lovelace}) - $(formatLovelace ${amount_lovelace}))"
  fi
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Payment"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${s_wallet}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"source-address\": \"${s_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { amount: ${amount_lovelace} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"destination-address\": \"${d_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: ${min_fee} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${s_wallet}' payment signing key\", vkey: $(jq -c . "${s_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Source Wallet ${FG_GREEN}${s_wallet} ${FG_CYAN}$(basename ${s_payment_sk_file})${NC}"  
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${s_payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : Delegate
# Description : Register pool with pledge on chain
delegate() {

  wallet_source="base"

  if ! parseWalletUTXOs; then return 1; fi
  if ! getSlotAndTTL; then return 1; fi

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${pool_delegcert_file} ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${pool_delegcert_file} ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: Not enough Ada in wallet ( $(formatLovelace ${lovelace}) < $(formatLovelace ${min_fee}) )"
    return 1
  fi

  newBalance=$(( lovelace - min_fee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  println "LOG" "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file ${pool_delegcert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Delegation"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: ${min_fee} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${payment_sk_file})${NC}" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : withdrawRewards
# Description : withdraw rewards earned and send to wallet base address
withdrawRewards() {

  wallet_source="base"

  if ! parseWalletUTXOs; then return 1; fi
  if ! getSlotAndTTL; then return 1; fi

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --fee 0 ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: Not enough Ada in wallet ( $(formatLovelace ${lovelace}) < $(formatLovelace ${min_fee}) )"
    return 1
  fi

  newBalance=$(( lovelace - min_fee + reward_lovelace ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  println "LOG" "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --withdrawal ${reward_addr}+${reward_lovelace}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Rewards Withdrawal"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { rewards: ${reward_lovelace} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: ${min_fee} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${payment_sk_file})${NC}" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : registerPool
# Description : Register pool with pledge on chain
registerPool() {

  getBaseAddress ${owner_wallets[0]}
  getBalance ${base_addr}
  if ! parseWalletUTXOs; then return 1; fi
  
  if ! getSlotAndTTL; then return 1; fi
  
  poolDeposit=$(jq -r '.poolDeposit' "${TMP_FOLDER}"/protparams.json)
  println "LOG" "Pool Deposit is ${poolDeposit}"
  
  owner_delegation_cert=""
  [[ ${delegate_owner_wallet} = 'Y' ]] && owner_delegation_cert="--certificate-file ${owner_delegation_cert_file}"
  
  witness_count=$(( 2 + ${#owner_wallets[@]} )) # owner payment + cold + multi-owners(main owner included)
  
  reward_delegation_cert=""
  reward_wallet_stake_key=""
  if [[ ${delegate_reward_wallet} = 'Y' ]]; then
    reward_delegation_cert="--certificate-file ${reward_delegation_cert_file}"
    reward_mu='N'
    for wallet_name in ${owner_wallets[@]}; do
      [[ "${wallet_name}" = "${reward_wallet}" ]] && reward_mu='Y' && break # reward wallet is also a multi owner, witness count already include reward wallet stake key
    done
    [[ ${reward_mu} = 'N' ]] && ((witness_count++)) # reward wallet to be delegated but not a multi-owner, increase witness count
  else
    reward_stake_sk_file=""
  fi
  
  owner_delegation_cert=""
  if [[ ${delegate_owner_wallet} = 'Y' ]]; then
    owner_delegation_cert="--certificate-file ${owner_delegation_cert_file}"
  fi

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --certificate-file ${pool_regcert_file} ${owner_delegation_cert} ${reward_delegation_cert} --fee 0 ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --certificate-file ${pool_regcert_file} ${owner_delegation_cert} ${reward_delegation_cert} --fee 0 ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count ${witness_count}
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ ${lovelace} -lt $(( min_fee + poolDeposit )) ]]; then
    println "ERROR" "\n${FG_RED}ERROR${NC}: Not enough Ada in base address ( $(formatLovelace ${lovelace}) < $(formatLovelace ${min_fee}) + $(formatLovelace ${poolDeposit}) )"
    return 1
  fi

  newBalance=$(( lovelace - min_fee - poolDeposit ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  println "LOG" "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${poolDeposit}) )"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file ${pool_regcert_file}
    ${owner_delegation_cert}
    ${reward_delegation_cert}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": ${pledge_ada} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": ${cost_ada} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"witness-era\": \"${ERA_WITNESS}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: $(( min_fee + poolDeposit )) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      if [[ ${index} -eq 0 ]]; then
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${owner_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
      stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    done
    [[ ${delegate_reward_wallet} = 'Y' && ${reward_mu} = 'N' ]] && if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Reward wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${reward_stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { witness: [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Pool ${FG_GREEN}${pool_name} ${FG_CYAN}${POOL_COLDKEY_SK_FILENAME}${NC}" 
    println "DEBUG" "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_CYAN}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_CYAN}${WALLET_STAKE_SK_FILENAME}${NC}" 
    for index in "${!owner_wallets[@]}"; do
      [[ ${index} -eq 0 ]] && continue # skip main owner
      println "DEBUG" "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_CYAN}${WALLET_STAKE_SK_FILENAME}${NC}"
    done
    [[ delegate_reward_wallet = 'Y' ]] && println "DEBUG" "Reward wallet ${FG_GREEN}${reward_wallet} ${FG_CYAN}$(basename ${reward_stake_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  multi_owner_keys=()
  for wallet_name in ${owner_wallets[@]}; do
    [[ "${wallet_name}" = "${owner_wallets[0]}" ]] && continue # skip main owner
    [[ "${wallet_name}" = "${reward_wallet}" && ${delegate_reward_wallet} = 'Y' ]] && continue # skip reward wallet, already included due to delegation
    getWalletType ${wallet_name}
    multi_owner_keys+=( "${stake_sk_file}" )
  done
  
  if ! witnessTx "${TMP_FOLDER}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${reward_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_FOLDER}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : modifyPool
# Description : Register pool with pledge on chain
modifyPool() {

  getBaseAddress ${owner_wallets[0]}
  getBalance ${base_addr}
  if ! parseWalletUTXOs; then return 1; fi
  
  if ! getSlotAndTTL; then return 1; fi

  witness_count=$(( 2 + ${#owner_wallets[@]} )) # owner payment + cold + multi-owners(main owner included)

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --certificate-file ${pool_regcert_file} --fee 0 ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${base_addr}+0 --invalid-hereafter ${ttl} --certificate-file ${pool_regcert_file} --fee 0 ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count ${witness_count}
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println "ERROR" "\n${FG_RED}ERROR${NC}: Not enough Ada in base address ( $(formatLovelace ${lovelace}) < $(formatLovelace ${min_fee}) )"
    return 1
  fi

  newBalance=$(( lovelace - min_fee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  println "LOG" "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file ${pool_regcert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Update"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": ${pledge_ada} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": ${cost_ada} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"witness-era\": \"${ERA_WITNESS}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: ${min_fee} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      if [[ ${index} -eq 0 ]]; then
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${owner_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
      stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    done
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { witness: [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Pool ${FG_GREEN}${pool_name} ${FG_CYAN}${POOL_COLDKEY_SK_FILENAME}${NC}" 
    println "DEBUG" "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_CYAN}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_CYAN}${WALLET_STAKE_SK_FILENAME}${NC}" 
    for index in "${!owner_wallets[@]}"; do
      [[ ${index} -eq 0 ]] && continue # skip main owner
      println "DEBUG" "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_CYAN}${WALLET_STAKE_SK_FILENAME}${NC}"
    done
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  multi_owner_keys=()
  for wallet_name in ${owner_wallets[@]}; do
    [[ "${wallet_name}" = "${owner_wallets[0]}" ]] && continue # skip main owner
    getWalletType ${wallet_name}
    multi_owner_keys+=( "${stake_sk_file}" )
  done
  
  if ! witnessTx "${TMP_FOLDER}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_FOLDER}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : deRegisterPool
# Description : Retire pool
deRegisterPool() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  getBalance ${addr}
  if ! parseWalletUTXOs; then return 1; fi
  if ! getSlotAndTTL; then return 1; fi

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${pool_deregcert_file} ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${addr}+0 --invalid-hereafter ${ttl} --fee 0 --certificate-file ${pool_deregcert_file} ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: Not enough Ada in wallet ( $(formatLovelace ${lovelace}) < $(formatLovelace ${min_fee}) )"
    return 1
  fi

  newBalance=$(( lovelace - min_fee ))
  tx_out="--tx-out ${addr}+${newBalance}"
  println "LOG" "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file ${pool_deregcert_file}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -f "${POOL_FOLDER}/${pool_name}/poolmeta.json" ]]; then
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"$(jq -r .name "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"$(jq -r .ticker "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"\" }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"retire-epoch\": ${epoch_enter} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: ${min_fee} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' stake signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${payment_sk_file})${NC}" 
    println "DEBUG" "Pool ${FG_GREEN}${pool_name} ${FG_CYAN}$(basename ${pool_coldkey_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${payment_sk_file}" "${pool_coldkey_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : rotatePoolKeys
# Description : Rotate pool's KES keys
# Parameters  : pool name   >  the pool name to rotate KES keys for
rotatePoolKeys() {
  # cold keys
  pool_coldkey_sk_file="${POOL_FOLDER}/${pool_name}/${POOL_COLDKEY_SK_FILENAME}"

  # generated files
  pool_hotkey_vk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_VK_FILENAME}"
  pool_hotkey_sk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_SK_FILENAME}"
  pool_opcert_counter_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_COUNTER_FILENAME}"
  pool_saved_kes_start="${POOL_FOLDER}/${pool_name}/${POOL_CURRENT_KES_START}"
  pool_opcert_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_FILENAME}"

  getCurrentKESperiod
  echo "${current_kes_period}" > ${pool_saved_kes_start}

  println "ACTION" "${CCLI} node key-gen-KES --verification-key-file ${pool_hotkey_vk_file} --signing-key-file ${pool_hotkey_sk_file}"
  if ! ${CCLI} node key-gen-KES --verification-key-file "${pool_hotkey_vk_file}" --signing-key-file "${pool_hotkey_sk_file}"; then return 1; fi
  println "ACTION" "${CCLI} node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --cold-signing-key-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}"
  if ! ${CCLI} node issue-op-cert --kes-verification-key-file "${pool_hotkey_vk_file}" --cold-signing-key-file "${pool_coldkey_sk_file}" --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" --kes-period "${current_kes_period}" --out-file "${pool_opcert_file}"; then return 1; fi
  chmod 700 ${POOL_FOLDER}/${pool_name}/*

  kesExpiration "${current_kes_period}"
}

# Command     : sendMetadata
# Description : post metadata file on chain using specified wallet to pay for the transaction fee
sendMetadata() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  if [[ ${metatype} = "no-schema" ]]; then
    metadata="--json-metadata-no-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "detailed-schema" ]]; then
    metadata="--json-metadata-detailed-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "cbor" ]]; then
    metadata="--metadata-cbor-file ${metafile}"
  else
    println "ERROR" "${FG_RED}ERROR${NC}: unknown metadata type '${metatype}'"
    return 1
  fi

  getBalance ${addr}
  if ! parseWalletUTXOs; then return 1; fi
  if ! getSlotAndTTL; then return 1; fi

  println "ACTION" "${CCLI} transaction build-raw ${tx_in} --tx-out ${addr}+0 --invalid-hereafter ${ttl} --fee 0 ${metadata} ${ERA_IDENTIFIER} --out-file ${TMP_FOLDER}/tx0.tmp"
  if ! ${CCLI} transaction build-raw ${tx_in} --tx-out ${addr}+0 --invalid-hereafter ${ttl} --fee 0 ${metadata} ${ERA_IDENTIFIER} --out-file "${TMP_FOLDER}"/tx0.tmp; then return 1; fi
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_FOLDER}"/tx0.tmp
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 1
    --byron-witness-count 0
    --protocol-params-file "${TMP_FOLDER}"/protparams.json
  )
  println "ACTION" "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println "LOG" "fee is $(formatLovelace ${min_fee}) Ada"

  if [[ ${lovelace} -lt ${min_fee} ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: Not enough Ada in address ( $(formatLovelace ${lovelace}) < $(formatLovelace ${min_fee}) )"
    return 1
  fi

  newBalance=$(( lovelace - min_fee ))
  tx_out="--tx-out ${addr}+${newBalance}"
  println "LOG" "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${lovelace}) - $(formatLovelace ${min_fee}) )"
  
  build_args=(
    ${tx_in}
    ${tx_out}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    ${metadata}
    --out-file "${TMP_FOLDER}"/tx.raw
  )
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Metadata"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: ${min_fee} }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_FOLDER}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_FOLDER}/offline_tx_$(jq .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_CYAN}${offline_tx}${NC}" 
    println "DEBUG" "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println "DEBUG" "Wallet ${FG_GREEN}${wallet_name} ${FG_CYAN}$(basename ${payment_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! signTx "${TMP_FOLDER}/tx.raw" "${payment_sk_file}"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : buildTx [build_args]
# Description : Helper function to build a raw transaction
#             : populate an array variable called 'build_args' with all data
# Parameters  : build_args  >  an array with all the arguments to assemble the transaction
buildTx() {
  println "ACTION" "${CCLI} transaction build-raw ${ERA_IDENTIFIER} ${build_args[*]}"
  ${CCLI} transaction build-raw ${ERA_IDENTIFIER} "${build_args[@]}"
}

# Command     : witnessTx [raw tx file] [signing keys ...]
# Description : Helper function to witness a raw transaction
# Parameters  : raw tx file   >  the transaction file to sign
#             : signing keys  >  list of signing keys to use when witnessing the transaction
witnessTx() {
  tx_raw="$1"
  shift
  [[ -n ${ERA_WITNESS} ]] && witness_era="${ERA_WITNESS}" || witness_era="${otx_witness_era}" # ERA_WITNESS empty in offline mode, otx_witness_era comes from offline tx (pool reg/mod Transaction >> Sign)
  tx_witness_files=()
  for skey in "$@"; do
    [[ -z ${skey//[[:blank:]]/} ]] && continue
    if [[ -f "${skey}" && $(jq -r '.description' "${skey}") = *"Hardware"* ]]; then # HW signing key
      if ! unlockHWDevice "witness the transaction"; then return 1; fi
      tx_witness="$(mktemp "${TMP_FOLDER}/tx.witness_XXXXXXXXXX")"
      witness_command=(
        cardano-hw-cli shelley transaction witness
        --tx-body-file "${tx_raw}"
        --hw-signing-file "${skey}"
        ${NETWORK_IDENTIFIER}
        --out-file "${tx_witness}"
      )
      println "ACTION" "${witness_command[@]}"
      if ! output=$(${witness_command[@]}) || [[ -n ${output} ]]; then println "ERROR" "${FG_RED}ERROR${NC}: during hw wallet signing:\n${output}" && return 1; fi # cardano-hw-cli seem to return with exit code 0 even on failure
      jq ".type = \"${witness_era}\"" "${tx_witness}" > "${tx_witness}.tmp" && mv -f "${tx_witness}.tmp" "${tx_witness}" # due to cardano-hw-cli bug, not setting era type correctly
    elif [[ -f "${skey}" ]]; then
      tx_witness="$(mktemp "${TMP_FOLDER}/tx.witness_XXXXXXXXXX")"
      witness_command=(
        ${CCLI} transaction witness
        --tx-body-file "${tx_raw}"
        --signing-key-file "${skey}"
        ${NETWORK_IDENTIFIER}
        --out-file "${tx_witness}"
      )
      println "ACTION" "${witness_command[@]}"
      if ! ${witness_command[@]}; then return 1; fi
    else
      println "ERROR" "${FG_RED}ERROR${NC}: signing key not found: ${skey}"
      return 1
    fi
    tx_witness_files+=( "${tx_witness}" )
  done
}

# Command     : assembleTx [raw tx file]
# Description : Helper function to witnessTx for assembling a signed tx using witnesses from tx_witness_files[] array
assembleTx() {
  tx_raw="$1"
  tx_signed="${TMP_FOLDER}/tx.signed_$(date +%s)"
  if [[ ${#tx_witness_files[@]} -gt 0 ]]; then # assemble witness files and sign
    tx_witness_out=()
    for witness in "${tx_witness_files[@]}"; do
      [[ -z ${witness//[[:blank:]]/} ]] && continue
      if [[ -f "${witness}" ]]; then
        tx_witness_out+=( "--witness-file ${witness}" )
      else
        println "ERROR" "${FG_RED}ERROR${NC}: witness file not found: ${witness}"
        return 1
      fi
    done
    sign_command=(
      ${CCLI} transaction assemble
      --tx-body-file "${tx_raw}"
      ${tx_witness_out[@]}
      --out-file "${tx_signed}"
    )
    println "ACTION" "${sign_command[@]}"
    ${sign_command[@]}
  else
    println "ERROR" "${FG_RED}ERROR${NC}: no witness files provided, unable to assemble tx!"
    return 1
  fi
}

# Command     : signTx [raw tx file] [signing keys ...]
# Description : Helper function to sign a raw transaction
# Parameters  : raw tx file    >  the transaction file to sign
#             : signing keys   >  list of signing keys to use when signing the transaction, for direct signing
signTx() {
  tx_raw="$1"
  shift
  tx_signed="${TMP_FOLDER}/tx.signed_$(date +%s)"
  if [[ $# -gt 0 ]]; then # sign directly
    tx_sign_out=()
    hw_wallet='N'
    for skey in "$@"; do
      [[ -z ${skey//[[:blank:]]/} ]] && continue
      skey_desc="$(jq -r '.description' "${skey}")"
      if [[ -f "${skey}" && ${skey_desc} = *"Hardware"* ]]; then # HW signing key
        tx_sign_out+=( "--hw-signing-file ${skey}" )
        if [[ ${wallet_source} = "base" && ${skey_desc} = "Payment"* ]]; then
          tx_sign_out+=( "--change-output-key-file ${skey}" )
          # Add stake.hwsfile as well as a change output
          [[ -f "$(dirname "${skey}")/${WALLET_HW_STAKE_SK_FILENAME}" ]] && tx_sign_out+=( "--change-output-key-file $(dirname "${skey}")/${WALLET_HW_STAKE_SK_FILENAME}" )
        fi
        hw_wallet='Y'
      elif [[ -f "${skey}" ]]; then
        tx_sign_out+=( "--signing-key-file ${skey}" )
      else
        println "ERROR" "\n${FG_RED}ERROR${NC}: sign key not found: ${skey}"
        return 1
      fi
    done
    if [[ ${hw_wallet} = 'Y' ]]; then
      if ! unlockHWDevice "sign the transaction"; then return 1; fi
      sign_command=(
        cardano-hw-cli shelley transaction sign
        --tx-body-file "${tx_raw}"
        ${tx_sign_out[@]}
        ${NETWORK_IDENTIFIER}
        --out-file "${tx_signed}"
      )
    else
      sign_command=(
        ${CCLI} transaction sign
        --tx-body-file "${tx_raw}"
        ${tx_sign_out[@]}
        ${NETWORK_IDENTIFIER}
        --out-file "${tx_signed}"
      )
    fi
  else
    println "ERROR" "\n${FG_RED}ERROR${NC}: no signing keys provided, unable to sign tx!"
    return 1
  fi
  
  println "ACTION" "${sign_command[@]}"
  ${sign_command[@]}
}

# Command     : submitTx [signed tx file]
# Description : Helper function to submit signed transaction file
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTx() {
  tx_signed="$1"

  submit_command=(
    ${CCLI} transaction submit
    --tx-file "${tx_signed}"
    ${PROTOCOL_IDENTIFIER}
    ${NETWORK_IDENTIFIER}
  )
  
  println "ACTION" "${submit_command[@]}"
  ${submit_command[@]}
}

# Command     : unlockHWDevice [action]
# Description : Directions to unlock and open HW device
# Parameters  : action  >  message for action to be taken
unlockHWDevice() {
  waitForInput "${FG_BLUE}INFO${NC}: please connect and unlock hardware device" "  ${FG_CYAN}Ledger${NC} - Unlock with pin and open Cardano app" "  ${FG_CYAN}Trezor${NC} - Make sure trezor bridge is installed (https://wallet.trezor.io/#/bridge) " "" "when done, press any key to continue"
  println "ACTION" "cardano-hw-cli device version | cut -d' ' -f4"
  device_app_version="$(cardano-hw-cli device version | cut -d' ' -f4)"
  if [[ ! ${device_app_version} =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    println "ERROR" "${FG_RED}ERROR${NC}: unable to identify connected hardware device, is the device plugged in and unlocked?"
    println "ERROR" "Make sure device is seen by OS using tools like lsusb etc and is working correctly"
    waitForInput && return 1
  fi
  
  println "DEBUG" "\n${FG_BLUE}INFO${NC}: follow directions on hardware device to $1"
}


# Command     : selectOpMode
# Description : Helper function to choose operational mode
selectOpMode() {
  println "OFF" "\nOnline mode  -  The default mode to use if all keys are available\n\n"\
"Hybrid mode  -  1) Go through steps to build a transaction file\n"\
"                2) Copy built tx file to offline computer\n"\
"                3) Sign it using 'Sign Tx' with keys on offline computer\n"\
"                   (CNTools started in offline mode '-o' without node connection)\n"\
"                4) Copy the signed tx file back to online computer and submit using 'Submit Tx'\n"
  select_opt "[o] Online" "[h] Hybrid" "[Esc] Cancel"
  case $? in
    0) op_mode="online" ;;
    1) op_mode="hybrid" ;;
    2) return 1 ;;
  esac
}
