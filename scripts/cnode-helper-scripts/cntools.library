#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2086,SC2230

############################################################
# Variables to keep counter for versions                   #
############################################################
# Any breaking changes (eg: that requires change of cntools.config, env or a change in priv folder would be considered breaking and will be exempt from auto-update)
CNTOOLS_MAJOR_VERSION=1
# Changes that can be applied without breaking existing functionality that can be applied from within CNTools
CNTOOLS_MINOR_VERSION=3
CNTOOLS_VERSION="$CNTOOLS_MAJOR_VERSION.$CNTOOLS_MINOR_VERSION"

############################################################
# library sourced by cntools with common taskes to perform #
############################################################

# Assumes that env has been sourced by calling script

# Command    : log [message]
# Description: Log message to file if activated in config
#              message is NOT outputed to STDOUT
# Parameters : message   >   The message
# Return     : null
# Examples of Usage:
#   >> log "Some log message"
log() {
  if [[ "${CNTOOLS_LOG}" != "" ]]; then
    message=$(echo $1 | sed -E 's/\\e\[[0-9;]{1,6}m/ ~~~ /g')
    echo "$(date "+%Y-%m-%dT%H:%M:%S%Z") : $message" >> ${CNTOOLS_LOG}
  fi
}

# Command    : indent
# Description: Pipe output of command to this function to indent output
# Parameters : null
# Return     : Indented output
# Examples of Usage:
#   >> some_command | indent
indent() { 
  sed 's/^/  /'; 
}


# Command    : waitForInput [optional: message]
# Description: wait for user keypress to continue
waitForInput() {
  ESC=$(printf "\033")
  echo ""
  if [[ -z $1 ]]; then
    message="press any key to return to home menu"
  else
    message="$1"
  fi
  read -rsn1 -p "${message}" key # get 1 character
  if [[ $key == $ESC ]]; then
    read -rsn2 key # read 2 more chars
  fi
}


# Command    : say [message]
# Description: Print message
# Parameters : message   >   The message
# Return     : message on STDOUT
# Examples of Usage:
#   >> say "Some message"
say() {
  echo -e "$1"
  if [[ $2 = "log" ]]; then
    log "$1"
  fi
}


# Command    : need_cmd [command]
# Description: Check if command is available, else print error
# Parameters : command   >   The command to check
# Return     : null
# Examples of Usage:
#   >> need_cmd "jq"
need_cmd() {
  if ! command -v "$1" > /dev/null 2>&1; then
    say "${RED}ERROR${NC}: need '$1' (command not found)" "try 'sudo apt install $1'"
    say "please install with your packet manager of choice(apt/yum etc..) and relaunch cntools"
    return 1
  fi
}


# Command    : protectionPreRequisites
# Description: Check if needed protection prerequisites is available, else print error
# Parameters : null
# Return     : 1 on error
# Examples of Usage:
#   >> protectionPreRequisites
protectionPreRequisites() {
  if ! need_cmd "gpg" || \
     ! need_cmd "systemd-ask-password" || \
     ! need_cmd "chattr"; then
    return 1
  fi
  
  touch "${TMP_FOLDER}/test"
  if ! sudo -n chattr -i "${TMP_FOLDER}/test" 2>&1; then
    rm -f "${TMP_FOLDER}/test"
    echo ""
    say "${ORANGE}WARN${NC}: Elevated privileges needed for chattr command used to write protect wallet and pool keys"
    say "Run the following command to add passwordless sudo access to chattr command for '$(whoami)' user"
    echo ""
    say "sudo echo \"$(whoami) ALL=NOPASSWD: $(command -v chattr)\" >> /etc/sudoers"
    waitForInput
    return 1
  fi
  rm -f "${TMP_FOLDER}/test"
}


# Command    : selectOption [opt1] [opt2] ...
#
# Description: Create a bash menu to select one of the provided options
# Parameters : optX    >   a list of available options to choose from
# Return     : index of selected option
# Examples of Usage:
#   >> selectOption MyWallet1 MyWallet2 Cancel
#
function selectOption {
  # little helpers for terminal print control and key input
  ESC=$(printf "\033")
  cursor_blink_on()  { printf "$ESC[?25h"; }
  cursor_blink_off() { printf "$ESC[?25l"; }
  cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
  print_option()     { printf "  $1 "; }
  print_selected()   { printf " $ESC[7m $1 $ESC[27m$2"; }
  get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
  key_input()        { read -rsn1 key   # get 1 character
                       if [[ $key == $ESC ]]; then
                         read -rsn2 key # read 2 more chars
                       fi
                         if [[ $key = "[A" ]]; then echo up;
                       elif [[ $key = "[B" ]]; then echo down;
                       elif [[ $key = ""   ]]; then echo enter;
                       else echo $key; fi; }
  opt_shortcut()     { [[ "$1" =~ ^\[([[:alnum:]])\].* ]] && echo ${BASH_REMATCH[1]}; }
  opt_firstchar()    { printf "${1:0:1}" | tr '[:upper:]' '[:lower:]'; }

  # initially print empty new lines (scroll down if at bottom of screen)
  for opt; do printf "\n"; done

  # determine current screen position for overwriting the options
  local lastrow=$(get_cursor_row)
  local startrow=$(($lastrow - $#))

  # ensure cursor and input echoing back on upon a ctrl+c during read -s
  trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
  cursor_blink_off

  local shortcut_found="no"
  local selected=0
  while true; do
    # print options by overwriting the last lines
    local idx=0
    for opt; do
      opt_part2=""
      if [[ "$opt" =~ ^(.*)[[:space:]](\(.*) ]]; then 
        opt_part1="${BASH_REMATCH[1]}"
        opt_part2=" ${BASH_REMATCH[2]}"
      else
        opt_part1="$opt"
      fi
      cursor_to $(($startrow + $idx))
      if [ $idx -eq $selected ]; then
        print_selected "$opt_part1" "$opt_part2"
      else
        print_option "$opt_part1$opt_part2"
      fi
      ((idx++))
    done
    
    [[ "${shortcut_found}" = "yes" ]] && break

    # user key control
    key_pressed=$(key_input)
    case ${key_pressed} in
      enter) break;;
      up)    ((selected--));
             if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
      down)  ((selected++));
             if [ $selected -ge $# ]; then selected=0; fi;;
      *)     # shortcut available for selected key?
             i=0
             for opt; do
               [[ ${key_pressed} = $(opt_shortcut "$opt") ]] && selected=${i} && shortcut_found="yes" && break
               ((i++))
             done
             # If no shortcut is found, lets see if it matches the first char of any of the options
             j=0
             for opt; do
               [[ "${shortcut_found}" != "yes" && ${key_pressed} = $(opt_firstchar "$opt") ]] && selected=${j} && break
               ((j++))
             done
             ;;
    esac
  done

  # cursor position back to normal
  cursor_to $lastrow
  printf "\n"
  cursor_blink_on

  return $selected
}
function select_opt {
  selectOption "$@" 1>&2
  local answer=$?
  echo $answer
  return $answer
}

# Command    : validIP [IP address]
# Description: A helper function to validate input for valid IPv4 address
# Parameters : IP address    >   the IPv4 address to validate
# Return     : 1 on success
# Examples of Usage:
#   >> validIP 123.123.123.123
#
function validIP()
{
  local  ip=$1
  local  stat=1

  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    OIFS=$IFS
    IFS='.'
    ip=($ip)
    IFS=$OIFS
    [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
    stat=$?
  fi
  return $stat
}


# Command    : getDirs [path to folder]
# Description: A helper function to get all subdirs for a directory
# Parameters : path to folder    >   full path to folder, subdirs of this folder returned
# Return     : populates ${dirs} array
# Examples of Usage:
#   >> getDirs /opt/cardano/cnode/priv/wallet
#
function getDirs {
  if [[ ! -d "$1" ]]; then
    say "${RED}ERROR${NC}: Missing folder: $1"
    waitForInput && return 1
  fi
  dirs=()
  while IFS= read -r -d '' dir; do
    dirs+=("$(basename ${dir})")
  done < <(find "${1}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
  return 0
}

# Command    : selectDir [dir1 dir2 ...]
# Description: A helper function to selectOption() specifically for directory selection 
# Parameters : array of dirs    >   array of dirs to include in selection, '[c] Cancel' option added to all selections
# Return     : populates ${dir_name} variable, 
# Examples of Usage:
#   >> selectDir Wallet1 Wallet2 Wallet3
#
function selectDir {
  dirs=("$@")
  dirs+=("[c] Cancel")
  selectOption "${dirs[@]}" 1>&2
  dir_name=${dirs[$?]}
  [[ "${dir_name}" = "[c] Cancel" ]] && return 1 || return 0
}


# Command    : getPassword [optional:confirm]
# Description: Get password from user on STDIN
# Parameters : confirm   >   Optional parameter, force user provide password twise to confirm
# Return     : populates $password variable, make sure to unset variable when done
# Examples of Usage:
#   >> local userPassword=$(getPassword confirm)
getPassword() {
  while true; do
    say "Enter key password (length >= 8)"
    password=$(systemd-ask-password "Password:")
    if [ ${#password} -lt 8 ]; then
      say ""
      say "${RED}ERROR${NC}: password length too short, please use a minimum of 8 characters."
      say ""
      read -r -n 1 -s -p "Press q to abort or any other key to retry" abort
      [[ ${abort} = "q" ]] && return 1
      say "\n"
      continue
    fi
    if [[ "$1" = "confirm" ]]; then
      local checkPassword=$(systemd-ask-password "Confirm: ")
      if [[ "${password}" != "${checkPassword}" ]]; then
        say ""
        say "${RED}ERROR${NC}: password missmatch!"
        say ""
        read -r -n 1 -s -p "Press q to abort or any other key to retry" abort
        [[ ${abort} = "q" ]] && return 1
        say "\n"
      else
        say "" && return
      fi
    else
      say "" && return
    fi
  done
}


# Command    : encryptFile [file] [password]
# Description: Encrypt file with GPG
# Parameters : file       >   Path for file to encrypt
#                             will get a new .gpg file extention added to filename
#              password   >   Password to encrypt file with
# Return     : null on successful execution
# Examples of Usage:
#   >> encryptFile "$CNODE_HOME/priv/wallet/MyWallet/SigningKeyShelley.skey"
encryptFile() {
  echo "${2}" | gpg --symmetric --yes --batch --cipher-algo AES256 --passphrase-fd 0 --output "${1}.gpg" "${1}" >/dev/null && \
  rm -f "${1}" || {
    say "${RED}ERROR${NC}: failed to encrypt ${1}"
    return 1
  }
  say "${1} successfully encrypted" "log"
}


# Command    : decryptFile [file] [password]
# Description: Decrypt file with GPG
# Parameters : file       >   Path for file to decrypt
#                             file extension .gpg required
#              password   >   Password to decrypt file with
# Return     : null on successful execution
# Examples of Usage:
#   >> decryptFile "$CNODE_HOME/priv/wallet/MyWallet/SigningKeyShelley.skey"
decryptFile() {
  echo "${2}" | gpg --decrypt --batch --yes --passphrase-fd 0 --output "${1%.*}" "${1}" >/dev/null && \
  rm -f "${1}" || {
    say "${RED}ERROR${NC}: failed to decrypt ${1}"
    return 1
  }
  say "${1} successfully decrypted" "log"
}


# Command    : getTip [optional:slot]
# Description: Get latest block or slot number
# Parameters : slot   >   optional parameter to get slot tip instead of block
# Return     : string with tip on STDOUT
# Examples of Usage:
#   >> tip=$(getTip)
getTip() {
  tip=$($CCLI shelley query tip --testnet-magic ${NWMAGIC})
  [[ $1 = "slot" ]] && tipType="Slot" || tipType="Block" # default to use block tip
  [[ "${tip}" =~ un${tipType}No.=.([[:alnum:]]+) ]] && echo ${BASH_REMATCH[1]}
}

# Command    : getEpoch
# Description: Calculates current epoch based on slot tip
# Parameters : null
# Return     : epoch on STDOUT
# Examples of Usage:
#   >> epoch=$(getEpoch)
getEpoch() {
  echo $(( $(getTip slot) / $(jq -r .epochLength ${GENESIS_JSON}) ))
}


# Command    : waitNewBlockCreated
# Description: Wait for a new block to be created
# Parameters : null
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> waitNewBlockCreated
waitNewBlockCreated() {
  SLOT_DURATION=$(jq -r .slotLength "$GENESIS_JSON")
  COUNTER=${TIMEOUT_NO_OF_SLOTS}
  say ""
  say "Waiting for new block to be created (timeout = ${COUNTER} slots, $(( COUNTER * SLOT_DURATION ))s)" "log"
  say ""
  say "${BLUE}INFO${NC}: press any key to cancel balance check and return"
  say ""
  initialTip=$(getTip)
  actualTip=${initialTip}

  while [ "${actualTip}" = "${initialTip}" ]; do
    read -r -n 1 -s -t ${SLOT_DURATION} -p "" abort
    if [[ $? -eq 0 ]]; then
      say "${BLUE}INFO${NC}: Balance check aborted!" "log"
      return 1
    fi
    actualTip=$(getTip)
    COUNTER=$((COUNTER - SLOT_DURATION))
    if [ ${COUNTER} -lt ${SLOT_DURATION} ]; then
      say "${ORANGE}WARN${NC}: waited $(( TIMEOUT_NO_OF_SLOTS * SLOT_DURATION )) secs and no new block created" "log"
      return 1
    fi
  done
  say "New block was created - ${actualTip}" "log"
}


# Command    : validateDecimalNbr [decimalNbr]
# Description: validate decimal number
# Parameters : decimalNbr   >   decimal number
# Return     : 0 on success, else 1
# Examples of Usage:
#   >> validateDecimalNbr 100.5
validateDecimalNbr() {
  re_decimal_nbr='^[0-9]+([.][0-9]+)?$'
  if [[ $1 =~ ${re_decimal_nbr} ]]; then
    return 0
  else
    return 1
  fi
}

# Command    : ADAtoLovelace [ADA]
# Description: Convert number in ADA to Lovelace
# Parameters : ADA   >   Amount in ADA, decimal number accepted
# Return     : Lovelace on STDOUT
# Examples of Usage:
#   >> ADAtoLovelace 100.5
ADAtoLovelace() {
  if validateDecimalNbr $1; then
    echo "$1 * 1000000 / 1" | bc # /1 is to remove decimals from bc command
  else
    say "${RED}ERROR${NC}: must be a valid integer or decimal number"
    return 1
  fi
}

# Command    : lovelacetoADA [Lovelace]
# Description: Convert number in Lovelace to ADA
# Parameters : Lovelace   >   Amount in Lovelace, integer number accepted
# Return     : ADA on STDOUT
# Examples of Usage:
#   >> lovelacetoADA 100.5
lovelacetoADA() {
  re_int_nbr='^[0-9]+$'
  if [[ $1 =~ ${re_int_nbr} ]]; then
    # ADA pretty print explanation for sed
    # remove trailing 0 IF there is a decimal separator
    # remove the separator if there are only 0 after separator also (assuming there is at least a digit before like BC does)
    echo "$1 / 1000000" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
  else
    say "${RED}ERROR${NC}: must be a valid integer number"
    return 1
  fi
}

# Command    : pctToFraction [percent]
# Description: Convert number as precent to fraction
# Parameters : percent   >   number to be converted in range 0-100
# Return     : fraction number on STDOUT
# Examples of Usage:
#   >> pctToFraction 7.5
pctToFraction() {
  if validateDecimalNbr $1; then
    if [[ $(bc <<< "$1 >= 0" ) -eq 0 || $(bc <<< "$1 <= 100" ) -eq 0 ]]; then
      say "${RED}ERROR${NC}: must be a number between 0-100"
      return 1
    else
      echo "x=$1 / 100; if(x<1) print 0; x" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
    fi
  else
    say "${RED}ERROR${NC}: must be a valid integer or decimal number"
    return 1
  fi
}

# Command    : fractionToPCT [fraction]
# Description: Convert fraction number to precent
# Parameters : fraction   >   number to be converted 
# Return     : number as percentage on STDOUT
# Examples of Usage:
#   >> fractionToPCT 0.015
fractionToPCT() {
  if validateDecimalNbr $1; then
    if (( $(bc <<<"$1 > 0") )); then 
      echo "x=$1 * 100; if(x<1) print 0; x" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
    else
      echo 0
    fi
  else
    say "${RED}ERROR${NC}: must be a valid decimal number"
    return 1
  fi
}


# Command    : getPayAddress [wallet name]
# Description: create and save payment address
# Return     : populates $pay_addr
getPayAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_addr_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_ADDR_FILENAME}"
  if [[ -f "${payment_vk_file}" ]]; then
    if ${CCLI} shelley address build --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_addr_file}" --testnet-magic ${NWMAGIC} 2>/dev/null; then
      pay_addr=$(cat "${payment_addr_file}")
    else
      pay_addr=""
      return 1
    fi
  else
    pay_addr=""
    return 1
  fi
}

# Command    : getBaseAddress [wallet name]
# Description: create, store and save base address
# Return     : populates $base_addr
getBaseAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  base_addr_file="${WALLET_FOLDER}/${1}/${WALLET_BASE_ADDR_FILENAME}"
  if [[ -f "${payment_vk_file}" && -f "${stake_vk_file}" ]]; then
    ${CCLI} shelley address build --payment-verification-key-file "${payment_vk_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" --testnet-magic ${NWMAGIC}
    base_addr=$(cat "${base_addr_file}")
  else
    base_addr=""
    return 1
  fi
}

# Command    : getRewardAddress [wallet name]
# Description: create, store and save reward address
# Return     : populates $reward_addr
getRewardAddress() {
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_addr_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_ADDR_FILENAME}"
  if [[ -f "${stake_vk_file}" ]]; then
    ${CCLI} shelley stake-address build --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_addr_file}" --testnet-magic ${NWMAGIC}
    reward_addr=$(cat "${stake_addr_file}")
  else
    reward_addr=""
    return 1
  fi
}

# Command    : getBalance [address]
# Description: check balance for provided address
# Return     : populates $lovelace & $ada
getBalance() {
  lovelace=0
  ada=0
  utx0_count=0
  
  [[ -z $1 ]] && return 1

  ${CCLI} shelley query utxo --testnet-magic "${NWMAGIC}" --address "${1}" > ${TMP_FOLDER}/fullUtxo.out
  tail -n +3 ${TMP_FOLDER}/fullUtxo.out | sort -k3 -nr > ${TMP_FOLDER}/balance.out
  
  while read -r utxo; do
    utx0_count=$(( utx0_count + 1 ))
    lovelace=$(( lovelace + $(awk '{ print $3 }' <<< "${utxo}") ))
  done <${TMP_FOLDER}/balance.out

  ada=$(lovelacetoADA ${lovelace})
}


# Command    : getRewards [wallet name]
# Description: check balance of reward address
# Return     : populates $reward_lovelace & $reward_ada
getRewards() {
  reward_lovelace=-1
  reward_ada=-1
  if isWalletRegistered $1; then
    reward_lovelace=$(jq -r '.rewardAccountBalance' <<< "${stakeAddressInfo}")
    [[ "${reward_lovelace}" =~ ^[0-9]+$ ]] || reward_lovelace=0
    reward_ada=$(lovelacetoADA ${reward_lovelace})
  fi
}


# Command    : sendADA [destination address] [amount] [source address] [source sign key] [Include Fee]
# Description: send ADA from source to destination
#              can also be used to defrag address by sending all to self
#              supports fee to be payed by sender(default) or receiver by reducing amount to send
# Parameters : Destination Address   >   Destination address.
#              Amount                >   Amount in lovelace.
#              Source Address        >   Source address.
#              Source Sign Key       >   Path to Signature (skey) file. For stake wallet, payment skey is to be used.
#              Include Fee           >   Optional argument to specify that amount to send should be reduced by fee instead of payed by sender.
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> sendADA 61WKMJemoBa....ssL7fzhq 100 61RM9xbIdg....HbyQY175 "$CNODE_HOME/priv/wallet/MyWallet/payment.skey" "no"
sendADA() {

  # Handle script arguments
  dAddr="$1"
  amount="$2"
  sAddr="$3"
  sKey="$4"
  inclFee="$5"

  say ""
  say " -- Protocol Parameters --"
  currSlot=$(getTip slot)
  ttlValue=$(( currSlot + 1000 ))
  say "TN Magic is ${NWMAGIC}" "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" "log"
  
  getBalance ${sAddr}

  balance=0
  utxoCount=0
  txIn=""
  while read -r utxo; do
    inAddr=$(awk '{ print $1 }' <<< "${utxo}")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxoBalance=$(awk '{ print $3 }' <<< "${utxo}")
    utxoCount=$(( utxoCount +1))
    txIn="${txIn} --tx-in ${inAddr}#${idx}"
    balance=$(( balance + utxoBalance ))
    [[ ${inclFee} = "yes" && ${balance} -ge ${amount} ]] && break
  done <${TMP_FOLDER}/balance.out

  [[ ${balance} -eq ${amount} ]] && outCount=1 || outCount=2

  say ""
  say " -- Calculate fee, new amount and remaining balance --" "log"
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-in-count ${utxoCount}
    --tx-out-count ${outCount}
    --ttl ${ttlValue}
    --testnet-magic ${NWMAGIC}
    --signing-key-file ${sKey}
    --protocol-params-file ${TMP_FOLDER}/protparams.json
  )

  minFee=$(${CCLI} ${minFeeArgs[*]} | awk '{ print $2 }')

  say "fee is $(numfmt --grouping ${minFee})" "log"

  # Sanity checks
  if [[ ${inclFee} = "no" ]]; then
    if [[ ${balance} -lt $(( amount + minFee )) ]]; then
      say "${RED}ERROR${NC}: Not enough Lovelace in address ($(numfmt --grouping ${balance}) < $(numfmt --grouping ${amount}) + $(numfmt --grouping ${minFee}))" 1>&2
      return 1
    fi
  else
    if [[ ${amount} -lt ${minFee} ]]; then
      say "${RED}ERROR${NC}: Fee deducted from ADA to send, amount can not be less than fee ($(numfmt --grouping ${amount}) < $(numfmt --grouping ${minFee}))" 1>&2
      return 1
    elif [[ ${balance} -lt ${amount} ]]; then
      say "${RED}ERROR${NC}: Not enough Lovelace in address ($(numfmt --grouping ${balance}) < $(numfmt --grouping ${amount}))" 1>&2
      return 1
    fi
  fi

  if [[ ${inclFee} = "no" ]]; then
    txOut="--tx-out ${dAddr}+${amount}"
  else
    txOut="--tx-out ${dAddr}+$(( amount - minFee ))"
    say "New amount to send in Lovelace after fee deduction is $(numfmt --grouping $(( amount - minFee ))) lovelaces ($(numfmt --grouping ${amount}) - $(numfmt --grouping ${minFee}))" "log"
  fi

  newBalance=$(( lovelace - amount ))
  if [[ ${inclFee} = "no" ]]; then
    newBalance=$(( balance - amount - minFee ))
    txOut="${txOut} --tx-out ${sAddr}+${newBalance}"
    say "Balance left to be returned in used UTxO's is $(numfmt --grouping ${newBalance}) lovelaces ($(numfmt --grouping ${balance}) - $(numfmt --grouping ${amount}) - $(numfmt --grouping ${minFee}))" "log"
  elif [[ ${outCount} -eq 2 ]]; then
    txOut="${txOut} --tx-out ${sAddr}+$(( balance - amount ))"
    say "Balance left to be returned in used UTxO's is $(numfmt --grouping $(( balance - amount ))) lovelaces ($(numfmt --grouping ${balance}) - $(numfmt --grouping ${amount}))" "log"
  fi

  buildArgs=(
    shelley transaction build-raw
    ${txIn}
    ${txOut}
    --ttl ${ttlValue}
    --fee ${minFee}
    --out-file ${TMP_FOLDER}/tx.raw
  )

  signArgs=(
    shelley transaction sign
    --tx-body-file ${TMP_FOLDER}/tx.raw
    --signing-key-file ${sKey}
    --testnet-magic ${NWMAGIC}
    --out-file ${TMP_FOLDER}/tx.signed
  )

  submitArgs=(
    shelley transaction submit
    --tx-file "${TMP_FOLDER}/tx.signed"
    --testnet-magic ${NWMAGIC}
  )

  echo ""
  say " -- Build, Sign & Send transaction --" "log"
  
  say "Building transaction"
  output=$(${CCLI} ${buildArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 1. Problem during tx creation with args ${buildArgs[*]}" 1>&2
    say "$output" "log"
    return 1
  fi

  say "Signing transaction"
  output=$(${CCLI} ${signArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 2. Problem during signing with args ${signArgs[*]}" 1>&2
    say "$output" "log"
    return 1
  fi

  say "Sending transaction"
  output=$(${CCLI} ${submitArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 3. Problem during tx submission with args ${submitArgs[*]}" 1>&2
    say "$output" "log"
    return 1
  fi
}


# Command    : isWalletRegistered [wallet name]
# Description: check if wallet is registered on chain
# Return     : 0 if registered, else 1
isWalletRegistered() {
  if getRewardAddress $1; then
    stakeAddressInfo=$(${CCLI} shelley query stake-address-info --testnet-magic ${NWMAGIC} --address ${reward_addr} | jq -r '.[] // empty')
    [[ -n "${stakeAddressInfo}" ]] && return 0
  fi
  return 1 
}

# Command    : registerStakeWallet [wallet name]
# Description: Register stake keys on chain and move funds from payment address to payment base address
# Return     : prints progress on STDOUT
registerStakeWallet() {
  
  echo ""
  waitForInput "Wallet not registered on chain, press any key to continue with registration"
  
  echo ""
  say " ## Register Stake Wallet ${GREEN}${1}${NC} on Chain ##" "log"
  echo ""

  # Wallet key filenames
  payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}"
  stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_cert_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_CERT_FILENAME}"
  
  echo ""
  say " -- Creating registration certificate --" "log"
  echo ""
  ${CCLI} shelley stake-address registration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_cert_file}"
  
  say " -- Protocol Parameters --"
  currSlot=$(getTip slot)
  ttlValue=$(( currSlot + 1000 ))
  keyDeposit=$(cat ${TMP_FOLDER}/protparams.json | jq -r '.keyDeposit')
  say "Key Deposit is ${keyDeposit}"
  say "TN Magic is ${NWMAGIC}" "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" "log"
  say ""
  
  # Use all available utxo in source address
  say "Using UTxO's:" "log"
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    say "TxHash: ${in_addr}#${idx}" "log"
    say "Lovelace: $(numfmt --grouping ${utxo_balance})" "log"
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <${TMP_FOLDER}/balance.out

  say ""
  say " -- Calculate fee --" "log"
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    --ttl ${ttlValue}
    --testnet-magic ${NWMAGIC}
    --signing-key-file ${payment_sk_file}
    --signing-key-file ${stake_sk_file}
    --certificate-file ${stake_cert_file}
    --protocol-params-file ${TMP_FOLDER}/protparams.json
  )

  minFee=$(${CCLI} ${minFeeArgs[*]} | awk '{ print $2 }')
  say "fee is $(numfmt --grouping ${minFee})" "log"

  if [[ ${lovelace} -lt $(( minFee + keyDeposit )) ]]; then
    say "${RED}ERROR${NC}: Not enough Lovelace in wallet ($(numfmt --grouping ${lovelace}) < $(numfmt --grouping ${minFee}) + $(numfmt --grouping ${keyDeposit}))"
    return 1
  fi

  newBalance=$(( lovelace - minFee - keyDeposit ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  
  say "New balance after tx fee and key deposit is $(numfmt --grouping ${newBalance}) lovelaces ($(numfmt --grouping ${lovelace}) - $(numfmt --grouping ${minFee}) - $(numfmt --grouping ${keyDeposit}))" "log"
  
  buildArgs=(
    shelley transaction build-raw
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${stake_cert_file}
    --out-file ${TMP_FOLDER}/tx.raw
  )

  signArgs=(
    shelley transaction sign
    --tx-body-file ${TMP_FOLDER}/tx.raw
    --signing-key-file ${payment_sk_file}
    --signing-key-file ${stake_sk_file}
    --testnet-magic ${NWMAGIC}
    --out-file ${TMP_FOLDER}/tx.signed
  )

  submitArgs=(
    shelley transaction submit
    --tx-file "${TMP_FOLDER}/tx.signed"
    --testnet-magic ${NWMAGIC}
  )

  echo ""
  say " -- Build, Sign & Send transaction --" "log"
  
  say "Building transaction" "log"
  output=$(${CCLI} ${buildArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 1. Problem during tx creation with args ${buildArgs[*]}"
    say "$output"
    return 1
  fi

  say "Signing transaction" "log"
  output=$(${CCLI} ${signArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 2. Problem during signing with args ${signArgs[*]}"
    say "$output"
    return 1
  fi

  say "Sending transaction" "log"
  output=$(${CCLI} ${submitArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 3. Problem during tx submission with args ${submitArgs[*]}"
    say "$output"
    return 1
  fi
  
  say "\n${ORANGE}Waiting for wallet registration to be recorded on chain, if aborted, choosen action will fail${NC}"
  
  while true; do
    if ! waitNewBlockCreated; then
      break
    fi
    getBalance ${base_addr}
    if [[ ${lovelace} -ne ${newBalance} ]]; then
      echo ""
      say "${ORANGE}WARN${NC}: Balance mismatch, transaction not included in latest block ($(numfmt --grouping ${lovelace}) != $(numfmt --grouping ${newBalance}))"
    else
      break
    fi
  done
  
  if [[ ${lovelace} -ne ${newBalance} ]]; then
    say "${RED}ERROR${NC}: failed to register wallet on chain or"
    return 1
  fi
  
  reward_ada=0
  reward_lovelace=0
}


# Command    : registerPool [pledge wallet base address] [pool cold sign key] [pledge wallet stake sign key] [pool registration cert file] [delegation certificate] [pledge wallet payment sign key]
#
# Description: Register pool with pledge on chain
# Parameters : pledge wallet base address      >   payment address, funds needed to pay tx fee for pool registration
#              pool cold sign key              >   pool cold sign key
#              pledge wallet stake sign key    >   stake signature key
#              pool registration cert file     >   pool registration cert file
#              delegation certificate          >   stake certificate
#              pledge wallet payment sign key  >   payment signature key
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> registerPool 00d9d57cb....ssL7fzhq "../pools/MyPool/cold.skey" "../wallet/MyWallet/stake.skey" "pool.cert" "delegation.cert" "../wallet/MyWallet/payment.skey"
#
registerPool() {

  # script arguments
  base_addr="$1"
  pool_coldkey_sk_file="$2"
  stake_sk_file="$3"
  pool_regcert_file="$4"
  pool_pledgecert_file="$5"
  pay_payment_sk_file="$6"
  
  echo ""
  say " -- Register Pool and Pledge on Chain --" "log"

  if [[ ! -s ${TMP_FOLDER}/balance.out ]]; then
    say "${RED}ERROR${NC}: wallet empty"
    return 1
  fi
  
  # Use all available utxo in pledge wallet
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <${TMP_FOLDER}/balance.out

  echo ""
  say " -- Protocol Parameters --"
  currSlot=$(getTip slot)
  ttlValue=$(( currSlot + 1000 ))
  poolDeposit=$(cat ${TMP_FOLDER}/protparams.json | jq -r '.poolDeposit')
  say "TN Magic is ${NWMAGIC}" "log"
  say "Pool Deposit is ${poolDeposit}"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" "log"

  echo ""
  say " -- Calculate fee, new amount and remaining balance --" "log"
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    --ttl ${ttlValue}
    --testnet-magic ${NWMAGIC}
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${pool_coldkey_sk_file}
    --signing-key-file ${stake_sk_file}
    --certificate-file ${pool_regcert_file}
    --certificate-file ${pool_pledgecert_file}
    --protocol-params-file ${TMP_FOLDER}/protparams.json
  )
  minFee=$(${CCLI} ${minFeeArgs[*]} | awk '{ print $2 }')
  say "fee is $(numfmt --grouping ${minFee})" "log"

  if [[ ${lovelace} -lt $(( minFee + poolDeposit )) ]]; then
    say "${RED}ERROR${NC}: Not enough Lovelace in base address ( $(numfmt --grouping ${lovelace}) < $(numfmt --grouping ${minFee}) + $(numfmt --grouping ${poolDeposit}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee - poolDeposit ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(numfmt --grouping ${newBalance}) lovelaces ( $(numfmt --grouping ${lovelace}) - $(numfmt --grouping ${minFee}) - $(numfmt --grouping ${poolDeposit}) )" "log"

  buildArgs=(
    shelley transaction build-raw
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_regcert_file}
    --certificate-file ${pool_pledgecert_file}
    --out-file ${TMP_FOLDER}/tx.raw
  )

  signArgs=(
    shelley transaction sign
    --tx-body-file ${TMP_FOLDER}/tx.raw
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${pool_coldkey_sk_file}
    --signing-key-file ${stake_sk_file}
    --testnet-magic ${NWMAGIC}
    --out-file ${TMP_FOLDER}/tx.signed
  )

  submitArgs=(
    shelley transaction submit
    --tx-file "${TMP_FOLDER}/tx.signed"
    --testnet-magic ${NWMAGIC}
  )

  echo ""
  say " -- Build, Sign & Send transaction --" "log"
  
  say "Building transaction"
  output=$(${CCLI} ${buildArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 1. Problem during tx creation with args ${buildArgs[*]}"
    say "$output" "log"
    return 1
  fi

  say "Signing transaction"
  output=$(${CCLI} ${signArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 2. Problem during signing with args ${signArgs[*]}"
    say "$output" "log"
    return 1
  fi

  say "Sending transaction"
  output=$(${CCLI} ${submitArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 3. Problem during tx submission with args ${submitArgs[*]}"
    say "$output" "log"
    return 1
  fi
}


# Command    : modifyPool [pledge wallet base address] [pool cold sign key] [pledge wallet stake sign key] [pool registration cert file] [pledge wallet payment sign key]
#
# Description: Register pool with pledge on chain
# Parameters : pledge wallet base address      >   payment address, funds needed to pay tx fee for pool registration
#              pool cold sign key              >   pool cold sign key
#              pledge wallet stake sign key    >   stake signature key
#              pool registration cert file     >   pool registration cert file
#              pledge wallet payment sign key  >   payment signature key
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> modifyPool 00d9d57cb....ssL7fzhq "../pools/MyPool/cold.skey" "../wallet/MyWallet/stake.skey" "pool.cert" "../wallet/MyWallet/payment.skey"
#
modifyPool() {

  # script arguments
  base_addr="$1"
  pool_coldkey_sk_file="$2"
  stake_sk_file="$3"
  pool_regcert_file="$4"
  pay_payment_sk_file="$5"
  
  echo ""
  say " -- Modify Pool Parameters and Update on Chain --" "log"
  if [[ ! -s ${TMP_FOLDER}/balance.out ]]; then
    say "${RED}ERROR${NC}: wallet empty"
    return 1
  fi
  
  # Use all available utxo in pledge wallet base address
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <${TMP_FOLDER}/balance.out

  echo ""
  say " -- Protocol Parameters --"
  currSlot=$(getTip slot)
  ttlValue=$(( currSlot + 1000 ))
  say "TN Magic is ${NWMAGIC}" "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" "log"

  echo ""
  say " -- Calculate fee, new amount and remaining balance --" "log"
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    --ttl ${ttlValue}
    --testnet-magic ${NWMAGIC}
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${pool_coldkey_sk_file}
    --signing-key-file ${stake_sk_file}
    --certificate-file ${pool_regcert_file}
    --protocol-params-file ${TMP_FOLDER}/protparams.json
  )
  minFee=$(${CCLI} ${minFeeArgs[*]} | awk '{ print $2 }')
  say "fee is $(numfmt --grouping ${minFee})" "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    say "${RED}ERROR${NC}: Not enough Lovelace in base address ( $(numfmt --grouping ${lovelace}) < $(numfmt --grouping ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(numfmt --grouping ${newBalance}) lovelaces ( $(numfmt --grouping ${lovelace}) - $(numfmt --grouping ${minFee}) )" "log"

  buildArgs=(
    shelley transaction build-raw
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_regcert_file}
    --out-file ${TMP_FOLDER}/tx.raw
  )

  signArgs=(
    shelley transaction sign
    --tx-body-file ${TMP_FOLDER}/tx.raw
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${pool_coldkey_sk_file}
    --signing-key-file ${stake_sk_file}
    --testnet-magic ${NWMAGIC}
    --out-file ${TMP_FOLDER}/tx.signed
  )

  submitArgs=(
    shelley transaction submit
    --tx-file "${TMP_FOLDER}/tx.signed"
    --testnet-magic ${NWMAGIC}
  )

  echo ""
  say " -- Build, Sign & Send transaction --" "log"
  
  say "Building transaction"
  output=$(${CCLI} ${buildArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 1. Problem during tx creation with args ${buildArgs[*]}"
    say "$output" "log"
    return 1
  fi

  say "Signing transaction"
  output=$(${CCLI} ${signArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 2. Problem during signing with args ${signArgs[*]}"
    say "$output" "log"
    return 1
  fi

  say "Sending transaction"
  output=$(${CCLI} ${submitArgs[*]})
  if [[ -n $output ]]; then
    say "${RED}ERROR${NC}: 3. Problem during tx submission with args ${submitArgs[*]}"
    say "$output" "log"
    return 1
  fi
}

# Command    : withdrawRewards [stake vkey file] [stake skey file] [payment skey file] [base address] [reward address] [rewards in lovelace]
# Description: withdraw rewards earned and send to wallet base address
#
withdrawRewards() {

  # script arguments
  stake_vk_file="$1"
  stake_sk_file="$2"
  pay_payment_sk_file="$3"
  base_addr="$4"
  stake_addr="$5"
  reward_lovelace="$6"

  echo ""
  if [[ ! -s ${TMP_FOLDER}/balance.out ]]; then
    say "${RED}ERROR${NC}: wallet empty"
    return 1
  fi

  # Use all available utxo in pledge wallet base address
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <${TMP_FOLDER}/balance.out

  say " -- Protocol Parameters --"
  currSlot=$(getTip slot)
  ttlValue=$(( currSlot + 1000 ))
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" "log"

  say ""
  say " -- Calculate fee, new amount and remaining balance --" "log"
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    --ttl ${ttlValue}
    --testnet-magic ${NWMAGIC}
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${stake_sk_file}
    --withdrawal ${stake_addr}+${reward_lovelace}
    --protocol-params-file ${TMP_FOLDER}/protparams.json
  )
  minFee=$(${CCLI} ${minFeeArgs[*]} | awk '{ print $2 }')
  say "fee is $(numfmt --grouping ${minFee})" "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    error "Not enough Lovelace in wallet ( $(numfmt --grouping ${lovelace}) < $(numfmt --grouping ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee + reward_lovelace ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(numfmt --grouping ${newBalance}) lovelaces ( $(numfmt --grouping ${lovelace}) - $(numfmt --grouping ${minFee}) )" "log"

  buildArgs=(
    shelley transaction build-raw
    ${tx_in}
    ${tx_out}
    --withdrawal ${stake_addr}+${reward_lovelace}
    --ttl ${ttlValue}
    --fee ${minFee}
    --out-file ${TMP_FOLDER}/tx.raw
  )

  signArgs=(
    shelley transaction sign
    --tx-body-file ${TMP_FOLDER}/tx.raw
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${stake_sk_file}
    --testnet-magic ${NWMAGIC}
    --out-file ${TMP_FOLDER}/tx.signed
  )

  submitArgs=(
    shelley transaction submit
    --tx-file "${TMP_FOLDER}/tx.signed"
    --testnet-magic ${NWMAGIC}
  )

  echo ""
  say " -- Build, Sign & Send transaction --" "log"
  
  say "Building transaction"
  output=$(${CCLI} ${buildArgs[*]})
  if [[ -n $output ]]; then
    error "1. Problem during tx creation with args ${buildArgs[*]}" "$output"
    return 1
  fi

  say "Signing transaction"
  output=$(${CCLI} ${signArgs[*]})
  if [[ -n $output ]]; then
    error "2. Problem during signing with args ${signArgs[*]}" "$output"
    return 1
  fi

  say "Sending transaction"
  output=$(${CCLI} ${submitArgs[*]})
  if [[ -n $output ]]; then
    error "3. Problem during tx submission with args ${submitArgs[*]}" "$output"
    return 1
  fi
}

# Command    : Delegate [stake vkey] [stake skey] [pay skey] [pay addr] [pool vkey] [deleg cert]
#
# Description: Register pool with pledge on chain
# Parameters : stake vkey    >   wallet stake vkey
#              stake skey    >   wallet stake skey
#              pay skey      >   wallet payment skey
#              base addr     >   wallet base address
#              pool vkey     >   pool you are delegating to vkey
#              deleg cert    >   delegation certificate
#
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> registerPool   "../wallet/MyWallet/stake.vkey" "../wallet/MyWallet/stake.skey" "../wallet/MyWallet/payment.skey" 00d9d57c....ssL7fzhq "../pools/MyPool/cold.vkey" "delegation.cert"
#
delegate() {

  # script arguments
  stake_vk_file="$1"
  stake_sk_file="$2"
  pay_payment_sk_file="$3"
  base_addr="$4"
  pool_coldkey_vk_file="$5"
  pool_delegcert_file="$6"

  # Use all available utxo in pledge wallet
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <${TMP_FOLDER}/balance.out
  
  echo ""
  say " -- Protocol Parameters --"
  currSlot=$(getTip slot)
  ttlValue=$(( currSlot + 1000 ))
  say "TN Magic is ${NWMAGIC}" "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" "log"

  echo ""
  say " -- Calculate fee, new amount and remaining balance --" "log"
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    --ttl ${ttlValue}
    --testnet-magic ${NWMAGIC}
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${stake_sk_file}
    --certificate-file ${pool_delegcert_file}
    --protocol-params-file ${TMP_FOLDER}/protparams.json
  )
  minFee=$(${CCLI} ${minFeeArgs[*]} | awk '{ print $2 }')
  say "fee is $(numfmt --grouping ${minFee})" "log"

  if [[ ${lovelace} -lt ${minFee} ]]; then
    error "Not enough Lovelace in wallet ( $(numfmt --grouping ${lovelace}) < $(numfmt --grouping ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee ))
  tx_out="--tx-out ${base_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(numfmt --grouping ${newBalance}) lovelaces ( $(numfmt --grouping ${lovelace}) - $(numfmt --grouping ${minFee}) )" "log"

  buildArgs=(
    shelley transaction build-raw
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_delegcert_file}
    --out-file ${TMP_FOLDER}/tx.raw
  )

  signArgs=(
    shelley transaction sign
    --tx-body-file ${TMP_FOLDER}/tx.raw
    --signing-key-file ${pay_payment_sk_file}
    --signing-key-file ${stake_sk_file}
    --testnet-magic ${NWMAGIC}
    --out-file ${TMP_FOLDER}/tx.signed
  )

  submitArgs=(
    shelley transaction submit
    --tx-file "${TMP_FOLDER}/tx.signed"
    --testnet-magic ${NWMAGIC}
  )

  echo ""
  say " -- Build, Sign & Send transaction --" "log"
  
  say "Building transaction"
  output=$(${CCLI} ${buildArgs[*]})
  if [[ -n $output ]]; then
    error "1. Problem during tx creation with args ${buildArgs[*]}" "$output"
    return 1
  fi

  say "Signing transaction"
  output=$(${CCLI} ${signArgs[*]})
  if [[ -n $output ]]; then
    error "2. Problem during signing with args ${signArgs[*]}" "$output"
    return 1
  fi

  say "Sending transaction"
  output=$(${CCLI} ${submitArgs[*]})
  if [[ -n $output ]]; then
    error "3. Problem during tx submission with args ${submitArgs[*]}" "$output"
    return 1
  fi
}


# Command    : deRegisterPool [pool cold skey] [pool dereg cert] [wallet addr] [wallet skey]
#
# Description: Retire pool
# Return     : prints progress on STDOUT
# Examples of Usage:
#   >> deRegisterPool "../pools/MyPool/cold.vkey" "../pools/MyPool/pool.dereg" 00d9d57c....ssL7fzhq "../wallet/MyWallet/payment.skey"
#
deRegisterPool() {

  # script arguments
  pool_coldkey_sk_file="$1"
  pool_deregcert_file="$2"
  wallet_addr="$3"
  wallet_payment_sk_file="$4"

  # Use all available utxo in wallet address
  tx_in=""
  while read -r utxo; do
    in_addr=$(awk '{ print $1 }' <<< "${utxo}")
    idx=$(awk '{ print $2 }' <<< "${utxo}")
    utxo_balance=$(awk '{ print $3 }' <<< "${utxo}")
    tx_in="${tx_in} --tx-in ${in_addr}#${idx}"
  done <${TMP_FOLDER}/balance.out
  
  echo ""
  say " -- Protocol Parameters --"
  currSlot=$(getTip slot)
  ttlValue=$(( currSlot + 1000 ))
  say "TN Magic is ${NWMAGIC}" "log"
  say "Current slot is ${currSlot}, setting ttl to ${ttlValue}" "log"

  echo ""
  say " -- Calculate fee, new amount and remaining balance --" "log"
  minFeeArgs=(
    shelley transaction calculate-min-fee
    --tx-in-count ${utx0_count}
    --tx-out-count 1
    --ttl ${ttlValue}
    --testnet-magic ${NWMAGIC}
    --signing-key-file ${wallet_payment_sk_file}
    --signing-key-file ${pool_coldkey_sk_file}
    --certificate-file ${pool_deregcert_file}
    --protocol-params-file ${TMP_FOLDER}/protparams.json
  )
  minFee=$(${CCLI} ${minFeeArgs[*]} | awk '{ print $2 }')
  say "fee is $(numfmt --grouping ${minFee})" "log"
  echo ""
  
  if [[ ${lovelace} -lt ${minFee} ]]; then
    error "Not enough Lovelace in wallet ( $(numfmt --grouping ${lovelace}) < $(numfmt --grouping ${minFee}) )"
    return 1
  fi

  newBalance=$(( lovelace - minFee ))
  tx_out="--tx-out ${wallet_addr}+${newBalance}"
  say "Balance left to be returned in used UTxO is $(numfmt --grouping ${newBalance}) lovelaces ( $(numfmt --grouping ${lovelace}) - $(numfmt --grouping ${minFee}) )" "log"

  buildArgs=(
    shelley transaction build-raw
    ${tx_in}
    ${tx_out}
    --ttl ${ttlValue}
    --fee ${minFee}
    --certificate-file ${pool_deregcert_file}
    --out-file ${TMP_FOLDER}/tx.raw
  )

  signArgs=(
    shelley transaction sign
    --tx-body-file ${TMP_FOLDER}/tx.raw
    --signing-key-file ${wallet_payment_sk_file}
    --signing-key-file ${pool_coldkey_sk_file}
    --testnet-magic ${NWMAGIC}
    --out-file ${TMP_FOLDER}/tx.signed
  )

  submitArgs=(
    shelley transaction submit
    --tx-file "${TMP_FOLDER}/tx.signed"
    --testnet-magic ${NWMAGIC}
  )

  echo ""
  say " -- Build, Sign & Send transaction --" "log"
  
  say "Building transaction"
  output=$(${CCLI} ${buildArgs[*]})
  if [[ -n $output ]]; then
    error "1. Problem during tx creation with args ${buildArgs[*]}" "$output"
    return 1
  fi

  say "Signing transaction"
  output=$(${CCLI} ${signArgs[*]})
  if [[ -n $output ]]; then
    error "2. Problem during signing with args ${signArgs[*]}" "$output"
    return 1
  fi

  say "Sending transaction"
  output=$(${CCLI} ${submitArgs[*]})
  if [[ -n $output ]]; then
    error "3. Problem during tx submission with args ${submitArgs[*]}" "$output"
    return 1
  fi
}


# Command    : kesExpiration [current KES period]
#
# Description: Calculate KES expiration
# Parameters : current KES period    >   KES start stored in POOL_CURRENT_KES_START file for pool in question
# Return     : expiration date can be accessed through variable ${expiration_date} after function has been executed
# Examples of Usage:
#   >> kesExpiration 1234
#
kesExpiration() {
  if [[ -z "${1##*[!0-9]*}" ]]; then
    say "${RED}ERROR${NC}: current KES period must be an integer number [$1]"
    return 1
  fi
  
  max_kes_evolutions=$(jq -r .maxKESEvolutions "${GENESIS_JSON}")
  genesis_start_time_sec=$(date --date=$(jq -r .systemStart "${GENESIS_JSON}") +%s)	# UTC
  slot_duration=$(jq -r .slotLength "${GENESIS_JSON}")
  slots_per_kes_period=$(jq -r .slotsPerKESPeriod "${GENESIS_JSON}")
  kes_expiration_period=$(( ${1} + ${max_kes_evolutions} - 1 ))
  expiration_time_sec=$(( ${genesis_start_time_sec} + ( ${slot_duration} * ${kes_expiration_period} * ${slots_per_kes_period} ) ))
  expiration_date=$(date --date=@${expiration_time_sec})
}
