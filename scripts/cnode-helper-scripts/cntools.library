#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2086,SC2230,SC2206,SC2140

######################################
# Do NOT modify code below           #
######################################

############################################################
# Variables to keep counter for versions                   #
############################################################
# The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
# and this adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
# Major: Any considerable change in the code base, big feature, workflow or breaking change from previous version
CNTOOLS_MAJOR_VERSION=10
# Minor: Changes and features of minor character that can be applied without breaking existing functionality or workflow
CNTOOLS_MINOR_VERSION=3
# Patch: Backwards compatible bug fixes. No additional functionality or major changes
CNTOOLS_PATCH_VERSION=0

CNTOOLS_VERSION="${CNTOOLS_MAJOR_VERSION}.${CNTOOLS_MINOR_VERSION}.${CNTOOLS_PATCH_VERSION}"

############################################################
# Default config values                                    #
# overriden by values set in cntools.sh                    #
############################################################
TMP_DIR="${TMP_DIR}/cntools"
if ! mkdir -p "${TMP_DIR}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create directory for temporary files: ${TMP_DIR}"; fi
if ! mkdir -p "${WALLET_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create wallet directory: ${WALLET_FOLDER}"; fi
if ! mkdir -p "${POOL_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create pool directory: ${POOL_FOLDER}"; fi
if ! mkdir -p "${ASSET_FOLDER}" 2>/dev/null; then myExit 1 "${FG_RED}ERROR${NC}: Failed to create asset directory: ${POOL_ASSET}"; fi
[[ -z ${TIMEOUT_NO_OF_SLOTS} ]] && TIMEOUT_NO_OF_SLOTS=600
[[ -z ${TX_TTL} ]] && TX_TTL=3600
[[ -z ${WALLET_SELECTION_FILTER_LIMIT} ]] && WALLET_SELECTION_FILTER_LIMIT=10
[[ -z ${KES_ALERT_PERIOD} ]] && KES_ALERT_PERIOD=172800 # default 2 days
[[ -z ${KES_WARNING_PERIOD} ]] && KES_WARNING_PERIOD=604800 # default 7 days
[[ $(uname) == Darwin ]] && ENABLE_CHATTR=false
[[ -z ${ENABLE_CHATTR} ]] && ENABLE_CHATTR=true
[[ -z ${ENABLE_DIALOG} ]] && ENABLE_DIALOG=false
[[ ${ENABLE_ADVANCED} = "true" ]] && ADVANCED_MODE="true"
[[ -z ${CHECK_KES} ]] && CHECK_KES=true
[[ -z ${CNTOOLS_LOG} ]] && CNTOOLS_LOG="${LOG_DIR}/cntools-history.log"
getEraIdentifier

############################################################
# library sourced by cntools with common taskes to perform #
############################################################

# Assumes that env has been sourced by calling script

# Command     : logln [log level] [message]
# Description : write message to log file with log level specified
logln() {
  local log_level=$1
  shift
  [[ -z $1 ]] && return
  echo -e "$@" | while read -r log_line; do
    log_line=$(sed -E 's/\x1b(\[[0-9;]*[a-zA-Z]|[0-9])//g' <<< ${log_line##*( )})
    [[ -z ${log_line} ]] && continue
    printf '%s %-8s %s\n' "$(date "+%F %T %Z")" "[${log_level}]" "${log_line}" >> "${CNTOOLS_LOG}"
  done
}

# Command     : println [log level] [newline] [message]
# Description : print and log(if enabled) message
# Parameters  : log level  >  log level (default: INFO)
#                             OFF    : logging disabled, output only to tty
#                             LOG    : logged as DEBUG but not printed to tty
#                             DEBUG  : verbose output, logged and printed to tty
#                             INFO   : normal output printed to tty and logged
#                             ACTION : e.g cardano-cli executions etc, logged but not printed to tty
#                             ERROR  : stderr output and error messages
#             : newline    >  Add a newline at the end for tty output (default true) 
#             : message    >  The message to print/log
println() {  
  sleep 0.05 # hack, sleep 50ms before each print to preserve order of execution
  local log_level=$1
  shift
  local newline="\n"
  if [[ $1 =~ true|false ]]; then
    [[ $1 = false ]] && newline=""
    shift
  fi
  case $log_level in
    OFF) printf "%b${newline}" "$@" >&6 ;;
    LOG) logln "DEBUG" "$@" ;;
    DEBUG) printf "%b${newline}" "$@" >&6; logln "DEBUG" "$@" ;;
    INFO) printf "%b${newline}" "$@" ;;
    ACTION) logln "ACTION" "$@" ;;
    ERROR) printf "%b${newline}" "$@" >&2 ;;
    *) printf "%b${newline}" "${log_level}"; [[ $# -ge 1 ]] && printf "%b${newline}" "$@" ;;
  esac
}

# Command     : getAnswerAnyCust [variable name] [log] [question]
# Description : wrapper function for getAnswerAny() in env to read input from stdin 
#               and save response into provided variable name while also logging response
# Parameters  : variable name  >  the name of the variable to save users response into
#             : log            >  [true|false] log question (default: true)
#             : question       >  what to ask user to input
getAnswerAnyCust() {
  sleep 0.1 # hack, sleep 100ms before asking question to preserve order
  var_name=$1
  shift
  local log_question=true
  if [[ $1 =~ true|false ]]; then
    [[ $1 = false ]] && log_question=false
    shift
  fi
  getAnswerAny "${var_name}" "$*" >&6
  [[ ${log_question} = true ]] && println LOG "$*: ${!var_name}"
}

# Command     : archiveLog
# Description : archive old log file and clean archive folder keeping last 10 log files
archiveLog() {
  [[ -z ${CNTOOLS_LOG} ]] && return
  log_archive="$(dirname "${CNTOOLS_LOG}")/archive"
  log_file="$(basename "${CNTOOLS_LOG}")"
  mkdir -p "${log_archive}"
  [[ -f ${CNTOOLS_LOG} ]] && mv -f "${CNTOOLS_LOG}" "${log_archive}/${log_file}_$(date +%s)"
  find "${log_archive}" -maxdepth 1 -type f -name "${log_file}*" -printf '%Ts\t%p\n' | sort -n | head -n -10 | cut -f 2- | xargs rm -rf
}

# Command     : waitForInput [optional: message]
# Description : wait for user keypress to continue
# Parameters  : message  >  [optional]: override default 'press any key to proceed ..' message
waitForInput() {
  exec >&6 # normal stdout
  waitToProceed "$*"
  exec >&8 # custom stdout
}

# Command     : protectionPreRequisites
# Description : Check if needed protection prerequisites is available, else print error
protectionPreRequisites() {
  ! cmdAvailable "gpg" && return 1

  if ! cmdAvailable "chattr" &>/dev/null; then
    [[ ${ENABLE_CHATTR} = true ]] && echo -e "chattr command not available but enabled in config, please install or disable in cntools.sh and re-run CNTools" && return 1
  elif [[ ${ENABLE_CHATTR} = true ]]; then # chattr available and enabled, make sure sudo access to chattr is enabled
    touch "${TMP_DIR}"/test
    echo -e "Testing chattr access permission, enter user password if requested..."
    if ! sudo chattr -i "${TMP_DIR}"/test; then
      rm -f "${TMP_DIR}"/test
      echo -e "\n${FG_YELLOW}WARN${NC}: Elevated privileges needed for chattr command used to write protect wallet and pool keys"
      echo -e "Add required sudo permissions or run the following command to add passwordless sudo access to chattr command for '$(whoami)' user"
      echo -e "echo \"$(whoami) ALL=NOPASSWD: $(command -v chattr)\" | sudo tee /etc/sudoers.d/cntools"
      return 1
    fi
    rm -f "${TMP_DIR}"/test
  fi
}

# Command     : safeDel [path]
# Description : unlock and use secure delete (srm) if available to delete file|dir
# Note        : srm mainly effective for traditional magnetic HDDs and non copy-on-write or journal file systems
# Parameters  : command  >  The command to check
safeDel() {
  path=$1
  [[ ${ENABLE_CHATTR} = true && -f "${path}" && $(lsattr -R "${path}") =~ -i- ]] && sudo chattr -i "${path}"
  command -v "srm" &>/dev/null && delcommand='srm' || delcommand='rm'
  if "${delcommand}" -rf "${path}"; then
    println "Deleted: ${path}"
  else
    println ERROR "${FG_RED}ERROR${NC}: delete failed for ${path}"
    return 1
  fi
  return 0
}

# Command     : dialogSetup
# Description : set config parameters for dialog formatting
dialogSetup() {
  export DIALOGRC="${TMP_DIR}"/.dialogrc
  [[ ! -f ${DIALOGRC} ]] && cat <<-EOF > "${TMP_DIR}"/.dialogrc
		# Types of values:
		#
		# Number     -  <number>
		# String     -  "string"
		# Boolean    -  <ON|OFF>
		# Attribute  -  (foreground,background,highlight?)
		# Set aspect-ration.
		aspect = 0
		# Set separator (for multiple widgets output).
		separate_widget = ""
		# Set tab-length (for textbox tab-conversion).
		tab_len = 0
		# Make tab-traversal for checklist, etc., include the list.
		visit_items = OFF
		# Shadow dialog boxes? This also turns on color.
		use_shadow = OFF
		# Turn color support ON or OFF
		use_colors = OFF
		# Screen color
		screen_color = (BLACK,BLACK,OFF)
		# Shadow color
		shadow_color = (BLACK,BLACK,ON)
		# Dialog box color
		dialog_color = (BLACK,BLACK,OFF)
		# Dialog box title color
		title_color = (RED,BLACK,ON)
		# Dialog box border color
		border_color = (BLACK,BLACK,OFF)
		# Active button color
		button_active_color = (WHITE,BLACK,ON)
		# Inactive button color
		button_inactive_color = (BLACK,WHITE,OFF)
		# Active button key color
		button_key_active_color = button_active_color
		# Inactive button key color
		button_key_inactive_color = (RED,BLACK,OFF)
		# Active button label color
		button_label_active_color = (YELLOW,BLACK,OFF)
		# Inactive button label color
		button_label_inactive_color = (BLACK,WHITE,ON)
		# Input box color
		inputbox_color = button_inactive_color
		# Input box border color
		inputbox_border_color = button_inactive_color
		# Item color
		item_color = button_inactive_color
		# Selected item color
		item_selected_color = button_active_color
		# Dialog box border2 color
		border2_color = button_inactive_color
		# Input box border2 color
		inputbox_border2_color = button_inactive_color
		EOF
}

# Command     : fileDialog [title] [optional: start path]
# Description : open a file dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: ${TMP_DIR}/)
fileDialog() {
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    getAnswerAnyCust file "$1" && return
  else
    println DEBUG false "${1}: "
    waitForInput "Press any key to open the file explorer [cancel to skip!]"
  fi
  exec >&6 2>&7 # normal stdout/stderr
  sleep 0.1
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="${TMP_DIR}/"
  dialog --clear --keep-tite --title "$1" --fselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)) 2>"${TMP_DIR}/dialog.out"
  file=$([[ -f "${TMP_DIR}/dialog.out" ]] && cat "${TMP_DIR}/dialog.out" || echo "")
  tput cup $(( ${ROW#*[} -1 )) $(( ${COL} -1 ))
  exec >&8 2>&9 # custom stdout/stderr
  println DEBUG "${FG_LGRAY}${file}${NC}"
}
# Command     : dirDialog [title] [optional: start dir]
# Description : open a directory dialog
# Parameters  : show help  >  [0=no|1=yes] print dialog help text
#             : title      >  The dialog title text
#             : verbosity  >  [optional] Start path when dialog is opened, either dir or file (default: ${TMP_DIR}/)
dirDialog() {
  if [[ ${ENABLE_DIALOG} = "false" ]]; then
    getAnswerAnyCust dir "$1" && return
  else
    println DEBUG false "${1}: "
    waitForInput "Press any key to open the file explorer [cancel to skip!]"
  fi
  exec >&6 2>&7 # normal stdout/stderr
  sleep 0.1
  dialogSetup
  [[ -n $2 ]] && start_path="$2" || start_path="${TMP_DIR}/"
  dialog --clear --keep-tite --title "$1" --dselect "${start_path}" $(($(tput lines)-14)) $(($(tput cols)-10)) 2>"${TMP_DIR}/dialog.out"
  dir=$([[ -f "${TMP_DIR}/dialog.out" ]] && cat "${TMP_DIR}/dialog.out" || echo "")
  tput cup $(( ${ROW#*[} -1 )) $(( ${COL} -1 ))
  exec >&8 2>&9 # custom stdout/stderr
  println DEBUG "${FG_LGRAY}${dir}${NC}"
}


# Command     : selectOption [opt1] [opt2] ...
# Description : Create a bash menu to select one of the provided options
# Parameters  : optX  >  a list of available options to choose from
ESC=$(printf "\033")
cursor_blink_on()  { printf "${ESC}[?25h"; }
cursor_blink_off() { printf "${ESC}[?25l"; }
cursor_to()        { printf "${ESC}[$1;${2:-1}H"; }
print_option()     { printf "  $1 "; }
print_selected()   { printf " ${ESC}[7m $1 ${ESC}[27m$2"; }
get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
key_input()        { key2=""
                     read -rsn1 key1   # get 1 character
                     if [[ $key1 == "${ESC}" ]]; then
                       read -rsn2 -t 0.3 key2 # read 2 more chars, 1s timeout
                     fi
                       if [[ ${key2} = "[A" ]]; then echo up;
                     elif [[ ${key2} = "[B" ]]; then echo down;
                     elif [[ ${key1} = "${ESC}" && ${key2} = "" ]]; then echo Esc;
                     elif [[ ${key1} = ""   ]]; then echo enter;
                     else echo ${key1}; fi; }
opt_shortcut()     { [[ "$1" =~ ^\[([[:alnum:]]+)\].* ]] && echo ${BASH_REMATCH[1]}; }
opt_firstchar()    { printf "${1:0:1}" | tr '[:upper:]' '[:lower:]'; }
selectOption() {
  sleep 0.1 # sleep for a short time to get tty in sync

  # initially print empty new lines (scroll down if at bottom of screen)
  printf "\n" && for opt; do printf "\n"; done

  # determine current screen position for overwriting the options
  local startrow=$(( $(get_cursor_row) - $# - 1 ))

  cursor_blink_off

  local shortcut_found="no"
  local selected=0
  while true; do
    # print options by overwriting the last lines
    local idx=0
    for opt; do
      opt_part2=""
      if [[ "$opt" =~ ^(.*)[[:space:]](\(.*) ]]; then
        opt_part1="${BASH_REMATCH[1]}"
        opt_part2=" ${BASH_REMATCH[2]}"
      else
        opt_part1="$opt"
      fi
      cursor_to $(( startrow + idx ))
      if [ ${idx} -eq ${selected} ]; then
        print_selected "${opt_part1}" "${opt_part2}"
      else
        print_option "${opt_part1}${opt_part2}"
      fi
      ((idx++))
    done

    [[ "${shortcut_found}" = "yes" ]] && break

    # user key control
    key_pressed=$(key_input)
    case ${key_pressed} in
      enter) break;;
      up)    ((selected--));
             if [ ${selected} -lt 0 ]; then selected=$(($# - 1)); fi;;
      down)  ((selected++));
             if [ ${selected} -ge $# ]; then selected=0; fi;;
      *)     # shortcut available for selected key?
             i=0
             for opt; do
               [[ ${key_pressed} = $(opt_shortcut "${opt}") ]] && selected=${i} && shortcut_found="yes" && break
               ((i++))
             done
             # If no shortcut is found, lets see if it matches the first char of any of the options
             j=0
             for opt; do
               [[ "${shortcut_found}" != "yes" && ${key_pressed} = $(opt_firstchar "${opt}") ]] && selected=${j} && break
               ((j++))
             done
             ;;
    esac
  done

  # clear menu
  cursor_blink_on
  cursor_to $startrow
  tput ed
  
  return $selected
}

# Command     : select_opt [opt1] [opt2] ...
# Description : Helper function to selectOption
# Parameters  : optX  >  a list of available options to choose from
select_opt() {
  exec >&6 # normal stdout
  local opts=()
  for item in "$@"; do
    [[ -n ${item} ]] && opts+=("${item}")
  done
  selectOption "${opts[@]}"
  local answer=$?
  exec >&8 # custom stdout
  selected_value="${opts[${answer}]}"
  println DEBUG "Selected value: ${selected_value}"
  return $answer
}

# Command     : getDirs [path to folder]
# Description : A helper function to get all subdirs for a directory
# Parameters  : path to folder    >   full path to folder, subdirs of this folder returned
# Return      : populates ${dirs} array
getDirs() {
  if [[ ! -d "$1" ]]; then
    println ERROR "${FG_RED}ERROR${NC}: Missing folder: $1"
    waitForInput && return 1
  fi
  dirs=()
  while IFS= read -r -d '' dir; do
    dirs+=("$(basename ${dir})")
  done < <(find "${1}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
  return 0
}

# Command     : selectDir [type] [dir1 dir2 ...]
# Description : A helper function to selectOption() specifically for directory selection
# Parameters  : type  >  'wallet' 'pool' 'policy' 'asset'
#             : dirX  >  array of dirs to include in selection, '[Esc] Cancel' option added to all selections
# Return      : populates ${dir_name} variable
selectDir() {
  exec >&6 # normal stdout
  local type=$1 && shift
  dirs=( "$@" )
  dirs+=("[Esc] Cancel")
  selectOption "${dirs[@]}"
  dir_name=${dirs[$?]}
  [[ "${dir_name}" = "[Esc] Cancel" ]] && return 1
  exec >&8 # custom stdout
  println DEBUG "Selected ${type}: ${dir_name}"
}

# Command     : selectWallet [mode] [file1 file2 ... | wallet_name1 wallet_name1 ... ]
# Description : A helper function to select a CNTools wallet
# Parameters  : mode       >  a string containing some of the following: none|encrypted|non-reg|reg|balance|delegate|reward|assets to be added next to wallet in selection menu
#             : arg array  >  array of files required to exist in wallet folder for it to be selectable **OR** the name of wallet to exclude from selection
# Return      : populates ${wallet_name} variable with wallet selection
selectWallet() {
  wallet_dirs=()
  mode=$1 && shift
  if ! getDirs "${WALLET_FOLDER}"; then return 1; fi # dirs() array populated with all wallet folders
  if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" ]]; then
    tput sc
    wallet_count=${#dirs[@]}
    [[ ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]] && println OFF "Balance checking wallets..."
  fi
  for dir in "${dirs[@]}"; do
    for arg in "$@"; do # check if wallet is missing a required file or name matches execution, if so hide it
      [[ ${arg} == *"."* && ! -f "${WALLET_FOLDER}/${dir}/${arg}" ]] && continue 2
      [[ ${arg} != *"."* && ${dir} = "${arg}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${WALLET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        wallet_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        wallet_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
    elif [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" && ${wallet_count} -le ${WALLET_SELECTION_FILTER_LIMIT} ]]; then
      if [[ ${mode} = "non-reg" ]]; then
        if isWalletRegistered ${dir}; then continue; fi
      elif [[ ${mode} = "reg" ]]; then
        if ! isWalletRegistered ${dir}; then continue; fi
      fi
      if [[ ${mode} = "balance" || ${mode} = "non-reg" || ${mode} = "reg" ]]; then
        getBaseAddress ${dir}
        getPayAddress ${dir}
        [[ -z ${base_addr} || -z ${pay_addr} ]] && wallet_dirs+=("${dir}") && continue # ignore and add wallet without extra details
        getBalance ${base_addr}
        base_lovelace=${assets[lovelace]}
        [[ ${#assets[@]} -gt 1 ]] && base_assets_out=" + ${FG_LBLUE}$((${#assets[@]}-1))${NC} additional assets" || base_assets_out=""
        getBalance ${pay_addr}
        pay_lovelace=${assets[lovelace]}
        [[ ${#assets[@]} -gt 1 ]] && pay_assets_out=" + ${FG_LBLUE}$((${#assets[@]}-1))${NC} additional assets" || pay_assets_out=""
        if [[ ${base_lovelace} -gt 0 && ${pay_lovelace} -gt 0 ]]; then
          wallet_dirs+=("${dir} (Funds: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} Ada${base_assets_out} | Enterprise Funds: ${FG_LBLUE}$(formatLovelace ${pay_lovelace})${NC} Ada${pay_assets_out})")
        elif [[ ${pay_lovelace} -gt 0 ]]; then
          wallet_dirs+=("${dir} (Enterprise Funds: ${FG_LBLUE}$(formatLovelace ${pay_lovelace})${NC} Ada${pay_assets_out})")
        else
          wallet_dirs+=("${dir} (Funds: ${FG_LBLUE}$(formatLovelace ${base_lovelace})${NC} Ada${base_assets_out})")
        fi
      elif [[ ${mode} = "delegate" ]]; then
        getBaseAddress ${dir}
        [[ -z ${base_addr} ]] && wallet_dirs+=("${dir}") && continue # ignore and add wallet without extra details
        getBalance ${base_addr}
        if getRewardAddress ${dir}; then
          delegation_pool_id=$(${CCLI} query stake-address-info ${NETWORK_IDENTIFIER} --address "${reward_addr}" | jq -r '.[0].delegation // empty')
          unset poolName
          if [[ -n ${delegation_pool_id} ]]; then
            while IFS= read -r -d '' pool; do
              getPoolID "$(basename ${pool})"
              if [[ "${pool_id_bech32}" = "${delegation_pool_id}" ]]; then
                poolName=$(basename ${pool}) && break
              fi
            done < <(find "${POOL_FOLDER}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
          fi
          if [[ -n ${poolName} ]]; then
            wallet_dirs+=("${dir} (${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada - ${FG_RED}delegated${NC} to ${FG_GREEN}${poolName}${NC})")
          elif [[ -n ${delegation_pool_id} ]]; then
            wallet_dirs+=("${dir} (${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada - ${FG_RED}delegated${NC} to external address)")
          else
            wallet_dirs+=("${dir} (${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada)")
          fi
        else
          wallet_dirs+=("${dir} (${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada)")
        fi
      elif [[ ${mode} = "reward" ]]; then
        getRewards ${dir}
        [[ ${reward_lovelace} -le 0 ]] && continue
        wallet_dirs+=("${dir} (Rewards: ${FG_LBLUE}$(formatLovelace ${reward_lovelace})${NC} Ada)")
      fi
    else
      wallet_dirs+=("${dir}")
    fi
  done
  if [[ ${CNTOOLS_MODE} = "CONNECTED" && ${mode} != "none" ]]; then tput rc && tput ed; fi
  if [[ ${#wallet_dirs[@]} -eq 0 ]]; then
    if [[ ${mode} = "balance" ]]; then
      println ERROR "${FG_YELLOW}WARN${NC}: No wallets with funds available for selection! Required files:\n$(printf '%b\n' "$@")"
    elif [[ ${mode} = "delegate" ]]; then
      println ERROR "${FG_YELLOW}WARN${NC}: No wallets available that can be delegated or used as pool pledge/owner/reward wallet! Required files:\n$(printf '%b\n' "$@")"
    elif [[ ${mode} = "reward" ]]; then
      println ERROR "${FG_YELLOW}WARN${NC}: No wallets available that have rewards to withdraw!"
    else
      println ERROR "${FG_YELLOW}WARN${NC}: No wallets available for selection! Required files:\n$(printf '%b\n' "$@")"
    fi
    return 1
  fi
  if ! selectDir "wallet" "${wallet_dirs[@]}"; then return 2; fi # ${dir_name} populated by selectDir function
  wallet_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : selectPool [mode] [file1 file2 ...]
# Description : A helper function to select a CNTools pool
# Parameters  : mode   >  a string containing some of the following: reg|non-reg|encrypted
#             : fileX  >  array of files required to exist in pool folder for it to be selectable
# Return      : populates ${pool_name} variable with pool selection
selectPool() {
  pool_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${POOL_FOLDER}"; then return 1; fi # dirs() array populated with all pool folders
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if pool is missing a required file and if so hide it
      [[ -f "${POOL_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${POOL_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${POOL_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        pool_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        pool_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
      continue
    elif [[ ${mode} = "non-reg" || ${mode} = "reg" ]]; then
      isPoolRegistered "${dir}"
      case $? in
        0) println "ERROR" "KOIOS_API: ${error_msg}" &>/dev/null ;; # log error without printing but show pool
        1) [[ ${mode} = "reg" ]] && continue ;;
        2) [[ ${mode} = "non-reg" ]] && continue ;;
        3) [[ ${mode} = "reg" ]] && continue ;;
      esac
    fi
    pool_dirs+=("${dir}")
  done
  if [[ ${#pool_dirs[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No pools available that can be selected! Required files:\n$(printf '%b\n' "$@")"
    [[ ${enc_req_files} -gt 0 ]] && println DEBUG "\n${FG_YELLOW}* Encrypted pools found but not listed *${NC}"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && println DEBUG "${FG_YELLOW}encrypted pools found but NOT listed, please decrypt to show${NC}"
  if ! selectDir "pool" "${pool_dirs[@]}"; then return 2; fi # ${dir_name} populated by selectDir function
  pool_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : isPoolRegistered [pool_name]
# Description : check if pool is registered on chain
#               existence of POOL_REGCERT_FILENAME checked when KOIOS API is not available
# Parameters  : pool_name   >  the name of the pool to check
# Return      : 0 => error quering KOIOS API (error message saved in ${error_msg})
#               1 => NOT registered
#               2 => registered
#               3 => retiring/retired (only for KOIOS API)
isPoolRegistered() {
  unset error_msg pool_info pool_info_tsv pool_info_arr
  unset p_active_epoch_no p_vrf_key_hash p_margin p_fixed_cost p_pledge p_reward_addr p_owners p_relays p_meta_url p_meta_hash p_meta_json p_pool_status
  unset p_retiring_epoch p_op_cert p_op_cert_counter p_active_stake p_epoch_block_cnt p_live_stake p_live_delegators p_live_saturation
  if [[ ${CNTOOLS_MODE} = "OFFLINE" || -z ${KOIOS_API} ]]; then
    [[ -f "${POOL_FOLDER}/${1}/${POOL_REGCERT_FILENAME}" ]] && return 2 || return 1
  else
    getPoolID "$1"
    println ACTION "curl -sSL -f -X POST -H \"Content-Type: application/json\" -d '{\"_pool_bech32_ids\":[\"${pool_id_bech32}\"]}' ${KOIOS_API}/pool_info"
    ! pool_info=$(curl -sSL -f -X POST -H "Content-Type: application/json" -d '{"_pool_bech32_ids":["'${pool_id_bech32}'"]}' "${KOIOS_API}/pool_info" 2>&1) && error_msg=${pool_info} && return 0
    if [[ ${pool_info} = '[]' ]]; then
      return 1
    fi
    pool_info_tsv=$(jq -r '[
    .[0].active_epoch_no //0,
    .[0].vrf_key_hash //"-",
    .[0].margin //0,
    .[0].fixed_cost //0,
    .[0].pledge //0,
    .[0].reward_addr //"-",
    (.[0].owners|@json),
    (.[0].relays|@json),
    .[0].meta_url //"-",
    .[0].meta_hash //"-",
    (.[0].meta_json|@base64),
    .[0].pool_status //"-",
    .[0].retiring_epoch //"-",
    .[0].op_cert //"-",
    .[0].op_cert_counter //"null",
    .[0].active_stake //0,
    .[0].block_count //0,
    .[0].live_pledge //0,
    .[0].live_stake //0,
    .[0].live_delegators //0,
    .[0].live_saturation //0
    ] | @tsv' <<< "${pool_info}")

    read -ra pool_info_arr <<< ${pool_info_tsv}

    p_active_epoch_no=${pool_info_arr[0]}
    p_vrf_key_hash=${pool_info_arr[1]}
    p_margin=${pool_info_arr[2]}
    p_fixed_cost=${pool_info_arr[3]}
    p_pledge=${pool_info_arr[4]}
    p_reward_addr=${pool_info_arr[5]}
    p_owners=${pool_info_arr[6]}
    p_relays=${pool_info_arr[7]}
    p_meta_url=${pool_info_arr[8]}
    p_meta_hash=${pool_info_arr[9]}
    p_meta_json=$(base64 -d <<< ${pool_info_arr[10]})
    p_pool_status=${pool_info_arr[11]}
    p_retiring_epoch=${pool_info_arr[12]}
    p_op_cert=${pool_info_arr[13]}
    p_op_cert_counter=${pool_info_arr[14]}
    p_active_stake=${pool_info_arr[15]}
    p_block_count=${pool_info_arr[16]}
    p_live_pledge=${pool_info_arr[17]}
    p_live_stake=${pool_info_arr[18]}
    p_live_delegators=${pool_info_arr[19]}
    p_live_saturation=${pool_info_arr[20]}

    [[ ${p_pool_status} = 'registered' ]] && return 2 || return 3
  fi
}

# Command     : getAssetInfo [policy_id] [asset_name_hex]
# Description : Query Koios for asset information.
# Return      : 0: data saved in asset_<koios_field>
#               1: on error ($error_msg contains error message)
#               2: offline/disabled/no result
getAssetInfo() {
  unset
  if [[ ${CNTOOLS_MODE} = "OFFLINE" || -z ${KOIOS_API} || $# -ge 1 ]]; then
    return 2
  else
    println ACTION "curl -sSL -f -d _asset_policy=$1 -d _asset_name=$2  ${KOIOS_API}/asset_info"
    ! asset_info=$(curl -sSL -f -d _asset_policy=$1 -d _asset_name=$2 "${KOIOS_API}/asset_info" 2>&1) && error_msg="${asset_info}" && return 1
    if [[ ${asset_info} = '[]' ]]; then
      return 2
    fi
    asset_info_tsv=$(jq -r '[
    (.[0].asset_name_ascii //"-" | @base64),
    .[0].fingerprint //"-",
    .[0].minting_tx_hash //"-",
    .[0].total_supply //0,
    .[0].mint_cnt //0,
    .[0].burn_cnt //0,
    .[0].creation_time //0,
    (.[0].minting_tx_metadata //"-" | @base64),
    (.[0].token_registry_metadata //"-" | @base64)
    ] | @tsv' <<< "${asset_info}")

    read -ra asset_info_arr <<< ${asset_info_tsv}

    a_asset_name_ascii=$(base64 -d <<< ${asset_info_arr[0]})
    a_fingerprint=${asset_info_arr[1]}
    a_minting_tx_hash=${asset_info_arr[2]}
    a_total_supply=${asset_info_arr[3]}
    a_mint_cnt=${asset_info_arr[4]}
    a_burn_cnt=${asset_info_arr[5]}
    a_creation_time=${asset_info_arr[6]}
    a_minting_tx_metadata=$(base64 -d <<< ${asset_info_arr[7]})
    a_token_registry_metadata=$(base64 -d <<< ${asset_info_arr[8]})
  fi
}

# Command     : selectPolicy [mode] [file1 file2 ...]
# Description : A helper function to select a Multi-Asset policy
# Parameters  : fileX  >  array of files required to exist in policy folder for it to be selectable
# Return      : populates ${policy_name} variable with selected policy
selectPolicy() {
  policy_dirs=()
  mode=$1 && shift
  enc_req_files=0
  if ! getDirs "${ASSET_FOLDER}"; then return 1; fi
  for dir in "${dirs[@]}"; do
    for req_file in "$@"; do # check if policy folder contain required files
      [[ -f "${ASSET_FOLDER}/${dir}/${req_file}.gpg" ]] && ((enc_req_files++))
      [[ ! -f "${ASSET_FOLDER}/${dir}/${req_file}" ]] && continue 2
    done
    if [[ ${mode} = "encrypted" ]]; then
      enc_files=$(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.gpg' -print0 | wc -c)
      if [[ ${enc_files} -gt 0 ]]; then
        policy_dirs+=("${dir} (${FG_GREEN}encrypted${NC})")
      else
        policy_dirs+=("${dir} (${FG_YELLOW}unprotected${NC})")
      fi
      continue
    fi
    policy_dirs+=("${dir}")
  done
  if [[ ${#policy_dirs[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No policies available that can be selected! Required files:\n$(printf '%b\n' "$@")"
    [[ ${enc_req_files} -gt 0 ]] && println DEBUG "\n${FG_YELLOW}* Encrypted policies found but not listed *${NC}"
    return 1
  fi
  [[ ${enc_req_files} -gt 0 ]] && println DEBUG "${FG_YELLOW}encrypted policies found but NOT listed, please decrypt to show${NC}"
  if ! selectDir "policy" "${policy_dirs[@]}"; then return 2; fi # ${dir_name} populated by selectDir function
  policy_name="$(echo ${dir_name} | cut -d' ' -f1)"
}

# Command     : selectAsset
# Description : A helper function to select a Multi-Asset minted on device
# Return      : populates ${policy_dir}, ${asset_name} & ${asset_file} variables
selectAsset() {
  asset_list=() # <policy_id>.<asset_name>
  if ! getDirs "${ASSET_FOLDER}"; then return 1; fi
  for dir in "${dirs[@]}"; do
    if [[ $(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.asset' -print0 | wc -c) -gt 0 ]]; then
      while IFS= read -r -d '' asset; do
        asset_file=${asset##*/}
        asset_list+=("${dir}/${asset_file%%.*}")
      done < <(find "${ASSET_FOLDER}/${dir}" -mindepth 1 -maxdepth 1 -type f -name '*.asset' -print0 | sort -z)
    fi
  done
  if [[ ${#asset_list[@]} -eq 0 ]]; then
    println ERROR "${FG_YELLOW}WARN${NC}: No assets found on disk!"
    return 1
  fi
  if ! selectDir "asset" "${asset_list[@]}"; then return 2; fi # ${dir_name} populated by selected value
  policy_dir="${dir_name%%/*}"
  asset_name="${dir_name##*/}"
  asset_file="${ASSET_FOLDER}/${policy_dir}/${asset_name}.asset"
}

# Command     : getPasswordCust [optional: confirm]
# Description : Get password from user on STDIN
# Parameters  : confirm  >  [optional] force user to provide password twice for confirmation
# Return      : populates ${password} variable, make sure to unset variable when done
getPasswordCust() {
  exec >&6 2>&7 # normal stdout/stderr
  sleep 0.1
  getPassword 8 $1
  return_code=$?
  exec >&8 2>&9 # custom stdout/stderr
  return ${return_code}
}

# Command     : encryptFile [file] [password]
# Description : Encrypt file with GPG
# Parameters  : file      >  Path for file to encrypt, will get a new .gpg file extention added to filename
#             : password  >  Password to encrypt file with
encryptFile() {
  exec >&6 2>&7 # normal stdout/stderr
  sleep 0.1
  echo "${2}" | gpg --symmetric --yes --batch --cipher-algo AES256 --passphrase-fd 0 --output "${1}.gpg" "${1}" &>/dev/null && \
  safeDel "${1}" >/dev/null || {
    exec >&8 2>&9 # custom stdout/stderr
    println ERROR "${FG_RED}ERROR${NC}: failed to encrypt ${1}"
    return 1
  }
  exec >&8 2>&9 # custom stdout/stderr
  println DEBUG "${1} successfully encrypted"
}


# Command     : decryptFile [file] [password]
# Description : Decrypt file with GPG
# Parameters  : file      >  Path for file to decrypt, file extension .gpg required
#             : password  >  Password to decrypt file with
decryptFile() {
  exec >&6 2>&7 # normal stdout/stderr
  sleep 0.1
  echo "${2}" | gpg --decrypt --batch --yes --passphrase-fd 0 --output "${1%.*}" "${1}" &>/dev/null && \
  rm -f "${1}" || {
    exec >&8 2>&9 # custom stdout/stderr
    println ERROR "${FG_RED}ERROR${NC}: failed to decrypt ${1}"
    return 1
  }
  exec >&8 2>&9 # custom stdout/stderr
  println DEBUG "${1} successfully decrypted"
}

# Command     : unlockFile [file]
# Description : Unlock/remove write protection from file
# Parameters  : file      >  Path for file to unlock
unlockFile() {
  if [[ ${ENABLE_CHATTR} = true && $(lsattr -R "$1") =~ -i- ]]; then
    sudo chattr -i "${1}"
  fi
  chmod 600 "${1}"
}

# Command     : lockFile [file]
# Description : Lock/write protect file with chattr if enabled and Linux file permissions
# Parameters  : file      >  Path for file to lock
lockFile() {
  chmod 400 "$1"
  if [[ ${ENABLE_CHATTR} = true && ! $(lsattr -R "$1") =~ -i- ]]; then
    sudo chattr +i "$1"
  fi
}

# Command     : waitNewBlockCreated [optional: silent]
# Description : Wait for a new block to be created
# Parameters  : silent  >  any argument to function will prevent DEBUG output to tty
waitNewBlockCreated() {
  counter=${TIMEOUT_NO_OF_SLOTS}
  [[ $# -eq 0 ]] && println DEBUG "Waiting for new block to be created (timeout = ${counter} slots, $(( counter * SLOT_LENGTH ))s)"
  [[ $# -eq 0 ]] && println DEBUG "${FG_BLUE}INFO${NC}: press any key to cancel and return (won't stop transaction)"
  getNodeMetrics
  initialTip=${slotnum}
  actualTip=${slotnum}

  while [[ ${actualTip} -eq ${initialTip} ]]; do
    read -r -n 1 -s -t 5 abort
    if [[ $? -eq 0 ]]; then
      println "${FG_YELLOW}WARN${NC}: aborted!! transaction still in queue!"
      return 1
    fi
    getNodeMetrics
    actualTip=${slotnum}
    counter=$((counter - SLOT_LENGTH))
    if [ ${counter} -lt ${SLOT_LENGTH} ]; then
      println "${FG_YELLOW}WARN${NC}: waited $(( TIMEOUT_NO_OF_SLOTS * SLOT_LENGTH )) secs and no new block created"
      return 1
    fi
  done
  println LOG "New block was created - ${actualTip}"
}

# Command     : verifyTx [address]
# Description : Verify that the transaction was successfully registered by checking address balance against $newBalance
# Parameters  : address  >  the address to compare with
verifyTx() {
  if ! waitNewBlockCreated; then return 1; fi
  getBalance ${1}
  while [[ ${assets[lovelace]} -ne ${newBalance} ]]; do
    println DEBUG "${FG_YELLOW}WARN${NC}: Balance mismatch, transaction not included in latest block... waiting for next block!"
    println LOG "$(formatLovelace ${assets[lovelace]}) != $(formatLovelace ${newBalance})"
    if ! waitNewBlockCreated "silent"; then return 1; fi
    getBalance ${1}
  done
  return 0
}

# Command     : getPoolID [pool name]
# Description : create and save pool id in hex & bech32 encoded format
# Parameters  : pool name  >  the name of the pool
# Return      : populates ${pool_id} & ${pool_id_bech32}
getPoolID() {
  pool_id_file="${POOL_FOLDER}/${1}/${POOL_ID_FILENAME}"
  pool_id_bech32_file="${POOL_FOLDER}/${1}/${POOL_ID_FILENAME}-bech32"
  [[ -f ${pool_id_file} && -f ${pool_id_bech32_file} ]] && pool_id=$(cat ${pool_id_file}) && pool_id_bech32=$(cat ${pool_id_bech32_file}) && return 0
  pool_id=""
  pool_id_bech32=""
  pool_coldkey_vk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}"
  if [[ -f ${pool_coldkey_vk_file} ]]; then
    println ACTION "${CCLI} stake-pool id --cold-verification-key-file ${pool_coldkey_vk_file} --output-format hex"
    println ACTION "${CCLI} stake-pool id --cold-verification-key-file ${pool_coldkey_vk_file}"
    if ! pool_id=$(${CCLI} stake-pool id --cold-verification-key-file "${pool_coldkey_vk_file}" --output-format hex 2>/dev/null) || \
       ! pool_id_bech32=$(${CCLI} stake-pool id --cold-verification-key-file "${pool_coldkey_vk_file}" 2>/dev/null); then
      return 1
    fi
    echo ${pool_id} > "${pool_id_file}"
    echo ${pool_id_bech32} > "${pool_id_bech32_file}"
    return 0
  fi
  return 1
}

# Command     : getPayAddress [wallet name]
# Description : create and save payment address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${pay_addr}
getPayAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_addr_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_ADDR_FILENAME}"
  [[ -f ${payment_addr_file} ]] && pay_addr=$(cat "${payment_addr_file}") && return 0
  pay_addr=""
  if [[ -f "${payment_vk_file}" ]]; then
    println ACTION "${CCLI} address build --payment-verification-key-file ${payment_vk_file} --out-file ${payment_addr_file} ${NETWORK_IDENTIFIER}"
    if ${CCLI} address build --payment-verification-key-file "${payment_vk_file}" --out-file "${payment_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      pay_addr=$(cat "${payment_addr_file}")
      return 0
    fi
  fi
  return 1
}

# Command     : getBaseAddress [wallet name] | [payment.vkey] [stake.vkey]
# Description : create, store and save base address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${base_addr}
getBaseAddress() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  base_addr_file="${WALLET_FOLDER}/${1}/${WALLET_BASE_ADDR_FILENAME}"
  [[ -f ${base_addr_file} ]] && base_addr=$(cat "${base_addr_file}") && return 0
  base_addr=""
  if [[ -f "${payment_vk_file}" && -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} address build --payment-verification-key-file ${payment_vk_file} --stake-verification-key-file ${stake_vk_file} --out-file ${base_addr_file} ${NETWORK_IDENTIFIER}"
    if ${CCLI} address build --payment-verification-key-file "${payment_vk_file}" --stake-verification-key-file "${stake_vk_file}" --out-file "${base_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      base_addr=$(cat "${base_addr_file}")
      return 0
    fi
  elif [[ $# -eq 2 && -f "${1}" && -f "${2}" ]]; then
    println ACTION "${CCLI} address build --payment-verification-key-file ${1} --stake-verification-key-file ${2} ${NETWORK_IDENTIFIER}"
    base_addr=$(${CCLI} address build --payment-verification-key-file "${1}" --stake-verification-key-file "${2}" ${NETWORK_IDENTIFIER} 2>/dev/null)
  fi
  return 1
}

# Command     : getRewardAddress [wallet name]
# Description : create, store and save reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_addr}
getRewardAddress() {
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_addr_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_ADDR_FILENAME}"
  [[ -f ${stake_addr_file} ]] && reward_addr=$(cat "${stake_addr_file}") && return 0
  reward_addr=""
  if [[ -f "${stake_vk_file}" ]]; then
    println ACTION "${CCLI} stake-address build --stake-verification-key-file ${stake_vk_file} --out-file ${stake_addr_file} ${NETWORK_IDENTIFIER}"
    if ${CCLI} stake-address build --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_addr_file}" ${NETWORK_IDENTIFIER} 2>/dev/null; then
      reward_addr=$(cat "${stake_addr_file}")
      return 0
    fi
  elif [[ -f "${1}" ]]; then
    println ACTION "${CCLI} stake-address build --stake-verification-key-file ${1} ${NETWORK_IDENTIFIER}"
    reward_addr=$(${CCLI} stake-address build --stake-verification-key-file "${1}" ${NETWORK_IDENTIFIER} 2>/dev/null)
  fi
  return 1
}

# Command     : getRewardAddressFromKey [stake vkey]
# Description : get reward address from a stake key
# Parameters  : stake key  >  path to stake.vkey file
# Return      : populates ${reward_addr}
getRewardAddressFromKey() {
  println ACTION "${CCLI} stake-address build --stake-verification-key-file ${1} ${NETWORK_IDENTIFIER}"
  reward_addr=$(${CCLI} stake-address build --stake-verification-key-file "${1}" ${NETWORK_IDENTIFIER} 2>/dev/null)
}

# Command     : getAddressInfo [address]
# Description : get address info from from node
# Parameters  : address  >  the wallet address to query
# Return      : populates ${address_info}
getAddressInfo() {
  println ACTION "${CCLI} address info --address $1"
  address_info=$(${CCLI} address info --address $1)
}

# Command     : getBalance [address]
# Description : check balance for provided address
# Parameters  : address  >  the wallet address to query
# Return      : populates associative arrays ${assets[]} & ${policyIDs[]}
getBalance() {
  declare -gA utxos=(); declare -gA assets=(); declare -gA policyIDs=()
  assets["lovelace"]=0; utxo_cnt=0
  asset_name_maxlen=5; asset_amount_maxlen=12
  tx_in=""
  
  if [[ -z ${1} ]] || ! utxo_raw=$(${CCLI} query utxo ${NETWORK_IDENTIFIER} --address "${1}"); then return 1; fi
  [[ -z ${utxo_raw} ]] && return
  
  while IFS= read -r line; do
    IFS=' ' read -ra utxo_entry <<< "${line}"
    [[ ${#utxo_entry[@]} -lt 4 ]] && continue
    ((utxo_cnt++))
    tx_in+=" --tx-in ${utxo_entry[0]}#${utxo_entry[1]}"
    if [[ ${utxo_entry[3]} = "lovelace" ]]; then
      utxos["${utxo_entry[0]}#${utxo_entry[1]}. Ada"]=${utxo_entry[2]} # Space added before 'Ada' for sort to place it first
      assets["lovelace"]=$(( ${assets["lovelace"]:-0} + utxo_entry[2] ))
      idx=5
    else
      utxos["${utxo_entry[0]}#${utxo_entry[1]}. Ada"]=0 # Space added before 'Ada' for sort to place it first
      assets["lovelace"]=0
      idx=2
    fi
    if [[ ${#utxo_entry[@]} -gt "${idx}" ]]; then
      while [[ ${#utxo_entry[@]} -gt ${idx} ]]; do
        asset_amount=${utxo_entry[${idx}]}
        if ! isNumber "${asset_amount}"; then break; fi
        asset_hash_name="${utxo_entry[$((idx+1))]}"
        IFS='.' read -ra asset <<< "${asset_hash_name}"
        policyIDs["${asset[0]}"]=1
        [[ ${#asset[@]} -eq 2 && ${#asset[1]} -gt ${asset_name_maxlen} ]] && asset_name_maxlen=${#asset[1]}
        asset_amount_fmt="$(formatAsset ${asset_amount})"
        [[ ${#asset_amount_fmt} -gt ${asset_amount_maxlen} ]] && asset_amount_maxlen=${#asset_amount_fmt}
        assets["${asset_hash_name}"]=$(( ${assets["${asset_hash_name}"]:-0} + asset_amount ))
        utxos["${utxo_entry[0]}#${utxo_entry[1]}.${asset_hash_name}"]=${asset_amount}
        idx=$(( idx + 3 ))
      done
    fi
  done <<< "${utxo_raw}"

  [[ ${asset_name_maxlen} -ne 5 ]] && asset_name_maxlen=$(( asset_name_maxlen / 2 ))
  lovelace_fmt="$(formatLovelace ${assets["lovelace"]})"
  [[ ${#lovelace_fmt} -gt ${asset_amount_maxlen} ]] && asset_amount_maxlen=${#lovelace_fmt}
}

# Command     : getAssetsTxOut [PolicyID.AssetName] [Amount]
# Description : generate tx out string for multi-assets in wallet
#               getBalance assumed to be run before calling this function
# Parameters  : PolicyID.AssetName  >  optional: Adjust balance for this asset before generating output
#               Amount              >  optional: The amount to adjust balance
# Return      : populates ${assets_tx_out}
getAssetsTxOut() {
  assets_tx_out=""
  if [[ $# -eq 2 ]]; then
    old_value=assets[$1]
    assets[$1]=$(( old_value + $2 ))
  fi
  for idx in "${!assets[@]}"; do
    [[ ${idx} = "lovelace" ]] && continue
    [[ ${assets[${idx}]} -gt 0 ]] && assets_tx_out+="+${assets[${idx}]} ${idx}"
  done
}

# Command     : getMinUTxO [--tx-out string]
# Description : calculate minimum balance needed in source wallet UTxOs for transaction to be valid
#               getBalance assumed to be run before
#               based on calculations from https://github.com/input-output-hk/cardano-ledger-specs/blob/master/doc/explanations/min-utxo.rst
# Return      : populates ${min_utxo_out}
getMinUTxO() {
  [[ -z ${utxoCostPerWord} ]] && utxoCostPerWord=$(jq -r '.utxoCostPerWord' <<< "${PROT_PARAMS}")

  # chain constants, based on: https://hydra.iohk.io/build/5949624/download/1/shelley-ma.pdf
  local k0=2				                # coinSize=0 in mary-era, 2 in alonzo-era
  local k1=6
  local k2=12				                # assetSize=12
  local k3=28				                # pidSize=28
  local k4=8				                # word=8 bytes
  local utxoEntrySizeWithoutVal=27 	# 6 + txOutLenNoVal(14) + txInLen(7)
  local adaOnlyUTxOSize=$(( utxoEntrySizeWithoutVal + k0 ))

  # New calculation for alonzo-era, static minUTxOValue replaced with utxoCostPerWord calculation
  minUTxOValue=$(( utxoCostPerWord * adaOnlyUTxOSize ))
  
  min_utxo_out=${minUTxOValue}
  
  # split the tx-out string into the assets
  IFS='+' read -ra asset_entry <<< "${1}"
  
  if [[ ${#asset_entry[@]} -gt 2 ]]; then # contains assets, do calculations.
    local idx=2
    declare -A pidCollector=()    # holds the list of individual policyIDs
    declare -A assetsCollector=() # holds the list of individual assetNumbers
    declare -A nameCollector=()   # holde the list of individual assetNames(hex format)
    
    while [[ ${#asset_entry[@]} -gt ${idx} ]]; do
      # separate asset amount from hash(policyID.assetName)
      IFS=' ' read -ra asset <<< "${asset_entry[${idx}]}"
      local asset_hash=${asset[1]}

      # split asset_hash_name into policy ID and asset name(hex)
      IFS='.' read -ra asset_split <<< "${asset_hash}"
      local asset_hash_policy=${asset_split[0]}
      local asset_hash_name=${asset_split[1]}

      # collect the entries in individual lists to sort them later
      pidCollector[${asset_hash_policy}]=1
      assetsCollector[${asset_hash_policy}${asset_hash_name}]=1
      [[ -n ${asset_hash_name} ]] && nameCollector[${asset_hash_name}]=1
      
      ((idx++))
    done
    
    local sumAssetNameLengths=$(_len=0;for K in "${!nameCollector[@]}";do ((_len+=$(printf "%s" "$K" | wc -c)));done;echo ${_len})
    local roundupBytesToWords=$(bc <<< "scale=0; ( ${#assetsCollector[@]}*${k2} + ${sumAssetNameLengths} + ${#pidCollector[@]}*${k3} + (${k4}-1) ) / ${k4}")
    local tokenBundleSize=$(( k1 + roundupBytesToWords ))
    local minAda=$(( $(bc <<< "scale=0; ${minUTxOValue} / ${adaOnlyUTxOSize}") * ( utxoEntrySizeWithoutVal + tokenBundleSize ) ))
    [[ ${minAda} -gt ${minUTxOValue} ]] && min_utxo_out=${minAda}
  fi
}

# Command     : getRewards [wallet name]
# Description : check balance of reward address
# Parameters  : wallet name  >  the name of the wallet
# Return      : populates ${reward_lovelace}
getRewards() {
  reward_lovelace=-1
  if isWalletRegistered $1; then
    reward_lovelace=0
    for reward_entry in $(jq -r '.[] | @base64' <<< "${stake_address_info}"); do
      _jq() { base64 -d <<< ${reward_entry} | jq -r "${1}"; }
      reward_lovelace=$(( reward_lovelace + $(_jq '.rewardAccountBalance //0') ))
    done
  fi
}
# Command     : getRewardsFromAddr [stake address]
# Description : check balance of reward address
# Parameters  : stake address  >  the address from stake.vkey
# Return      : populates ${reward_lovelace}
getRewardsFromAddr() {
  println ACTION "${CCLI} query stake-address-info ${NETWORK_IDENTIFIER} --address ${1}"
  stake_address_info=$(${CCLI} query stake-address-info ${NETWORK_IDENTIFIER} --address ${1})
  reward_lovelace=0
  for reward_entry in $(jq -r '.[] | @base64' <<< "${stake_address_info}"); do
    _jq() { base64 -d <<< ${reward_entry} | jq -r "${1}"; }
    reward_lovelace=$(( reward_lovelace + $(_jq '.rewardAccountBalance //0') ))
  done
}

# Command     : isWalletRegistered [wallet name]
# Description : check if wallet is registered on chain
# Parameters  : wallet name  >  the name of the wallet
isWalletRegistered() {
  if getRewardAddress $1; then
    println ACTION "${CCLI} query stake-address-info ${NETWORK_IDENTIFIER} --address ${reward_addr}"
    stake_address_info=$(${CCLI} query stake-address-info ${NETWORK_IDENTIFIER} --address ${reward_addr})
    [[ -n "${stake_address_info}" && $(jq -r 'length' <<< ${stake_address_info}) -gt 0 ]] && return 0
  fi
  return 1
}

# Command     : getWalletType [wallet name]
# Description : check if wallet is a hardware wallet, 0=yes, 1=cli, 2=cli & encrypted, 3=signing keys missing, 4=verification keys missing
# Parameters  : wallet name  >  the name of the wallet
getWalletType() {
  payment_vk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}"
  payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}"
  stake_vk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}"
  stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}"
  if [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_VK_FILENAME}" && -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_VK_FILENAME}" ]]; then # CNTools wallet
    if [[ $(jq -r '.description' "${payment_vk_file}") = *"Hardware"* ]]; then
      payment_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_PAY_SK_FILENAME}"
      stake_sk_file="${WALLET_FOLDER}/${1}/${WALLET_HW_STAKE_SK_FILENAME}"
      ([[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]]) && return 3 || return 0
    elif [[ -f "${WALLET_FOLDER}/${1}/${WALLET_PAY_SK_FILENAME}.gpg" || -f "${WALLET_FOLDER}/${1}/${WALLET_STAKE_SK_FILENAME}.gpg" ]]; then
      return 2
    else
      ([[ ${op_mode} = "online" && ( ! -f ${payment_sk_file} || ! -f ${stake_sk_file} ) ]]) && return 3 || return 1
    fi
  else
    return 4
  fi
}

# Command     : getPoolType [pool name]
# Description : check if pool is a hardware pool, 0=yes, 1=cli, 2=cli & encrypted, 3=signing keys missing, 4=verification keys missing
# Parameters  : pool name  >  the name of the pool
getPoolType() {
  pool_coldkey_vk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}"
  pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}"
  if [[ -f "${POOL_FOLDER}/${1}/${POOL_COLDKEY_VK_FILENAME}" ]]; then # CNTools pool
    if [[ $(jq -r '.description' "${pool_coldkey_vk_file}") = *"Hardware"* ]]; then
      pool_coldkey_sk_file="${POOL_FOLDER}/${1}/${POOL_HW_COLDKEY_SK_FILENAME}"
      ([[ ${op_mode} = "online" && ( ! -f ${pool_coldkey_sk_file} ) ]]) && return 3 || return 0
    elif [[ -f "${POOL_FOLDER}/${1}/${POOL_COLDKEY_SK_FILENAME}.gpg" ]]; then
      return 2
    else
      ([[ ${op_mode} = "online" && ( ! -f ${pool_coldkey_sk_file} ) ]]) && return 3 || return 1
    fi
  else
    return 4
  fi
}

# Command     : getTTL
# Description : query node for slot tip and calculate/get TTL from input depending on op_mode
getTTL() {
  tip_ref=$(getSlotTipRef)
  if [[ ${op_mode} = "hybrid" ]]; then
    println DEBUG "\nHow long do you want the transaction to be valid?"
    getAnswerAnyCust ttl_enter "TTL (in seconds, default: 1800/30min)"
    ttl_enter=${ttl_enter:-1800}
    if ! isNumber ${ttl_enter}; then
      println ERROR "\n${FG_RED}ERROR${NC}: invalid TTL number, non digit characters found: ${ttl_enter}"
      return 1
    fi
    ttl=$(( tip_ref + (ttl_enter/SLOT_LENGTH) ))
  else
    ttl=$(( tip_ref + (TX_TTL/SLOT_LENGTH) ))
  fi
  println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl}"
}

# Command     : buildOfflineJSON [type]
# Description : construct a json containing all data for offline signing
# Parameters  : type  >  type of transaction, e.g 'payment'
buildOfflineJSON() {
  offlineJSON="{}"
  if ! offlineJSON=$(jq ". += { id: \"$(date +%s)\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { type: \"${1}\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-created\": \"$(date --iso-8601=s)\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { \"date-expire\": \"$(date --iso-8601=s --date="@$(($(date +%s)+ttl_enter))")\" }" <<< ${offlineJSON}); then return 1; fi
  if ! offlineJSON=$(jq ". += { ttl: \"${ttl}\" }" <<< ${offlineJSON}); then return 1; fi
}

# Command     : registerStakeWallet [wallet name] [optional: skip validation]
# Description : Register stake keys on chain and move funds from payment address to payment base address
# Parameters  : wallet name      >  the name of the wallet
# Parameters  : skip validation  >  [optional] [true|false] if true, skip wallet registration check
registerStakeWallet() {

  wallet_name=$1
  wallet_source="base"

  if [[ -z $2 || $2 = "false" ]]; then
    println DEBUG "Wallet ${FG_GREEN}${wallet_name}${NC} not registered on chain"
    waitForInput "press any key to continue with registration"
  fi

  stake_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_VK_FILENAME}"
  stake_cert_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_CERT_FILENAME}"
  
  getBaseAddress "${wallet_name}"
  getBalance ${base_addr}
  
  println ACTION "${CCLI} stake-address registration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_cert_file}"
  if ! ${CCLI} stake-address registration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_cert_file}"; then return 1; fi

  if ! getTTL; then return 1; fi
  stakeAddressDeposit=$(jq -r '.stakeAddressDeposit' <<< "${PROT_PARAMS}")
  println LOG "Key Deposit is ${stakeAddressDeposit}"

  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${stake_cert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi
  
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee - stakeAddressDeposit ))
  println LOG "New balance after tx fee and key deposit is $(formatLovelace ${newBalance}) Ada ($(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${stakeAddressDeposit}))"

  if [[ ${assets[lovelace]} -lt $(( min_fee + stakeAddressDeposit )) ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in base address for tx fee and key deposit!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee + stakeAddressDeposit )))${NC} Ada"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee and key deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${stake_cert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"$(( min_fee + stakeAddressDeposit ))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
  echo
  if ! verifyTx ${base_addr}; then return 1; fi
  echo

  reward_lovelace=0
}

# Command     : deregisterStakeWallet
# Description : Deregister stake keys/wallet from chain, key deposit fee returned to wallets base address
deregisterStakeWallet() {

  wallet_source="base"

  stake_dereg_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_STAKE_DEREG_FILENAME}"
  println ACTION "${CCLI} stake-address deregistration-certificate --stake-verification-key-file ${stake_vk_file} --out-file ${stake_dereg_file}"
  if ! ${CCLI} stake-address deregistration-certificate --stake-verification-key-file "${stake_vk_file}" --out-file "${stake_dereg_file}"; then return 1; fi

  if ! getTTL; then return 1; fi
  
  stakeAddressDeposit=$(jq -r '.stakeAddressDeposit' <<< "${PROT_PARAMS}")
  println LOG "Key Deposit is ${stakeAddressDeposit}"

  getAssetsTxOut

  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${stake_dereg_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} + stakeAddressDeposit - min_fee ))
  println LOG "New balance after returned key deposit and subtracted tx fee is $(formatLovelace ${newBalance}) Ada ($(formatLovelace ${assets[lovelace]}) + $(formatLovelace ${stakeAddressDeposit}) - $(formatLovelace ${min_fee}))"
  
  if [[ $(( ${assets[lovelace]} + stakeAddressDeposit )) -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee - stakeAddressDeposit )))${NC} Ada"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee and returned key deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${stake_dereg_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"amount-returned\": \"${stakeAddressDeposit}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : sendAssets
# Description : send Assets from source to destination
#             : can also be used to defrag address by sending all to self
#             : supports fee to be payed by sender(default) or receiver by reducing amount to send
sendAssets() {

  [[ $(cat "${WALLET_FOLDER}/${s_wallet}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${s_addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  if ! getTTL; then return 1; fi

  if [[ -n ${metafile} && -f ${metafile} ]]; then
    metafile_param="--json-metadata-no-schema --metadata-json-file ${metafile}"
  else
    metafile_param=""
  fi
  
  getBalance ${s_addr}

  [[ ${#assets_left[@]} -eq 0 ]] && outCount=1 || outCount=2
  
  assets_tx_out_s=""
  assets_tx_out_d=""
  for idx in "${!assets_left[@]}"; do
    [[ ${idx} = "lovelace" ]] && continue
    [[ ${assets_left[${idx}]} -gt 0 ]] && assets_tx_out_s+="+${assets_left[${idx}]} ${idx}"
  done
  for idx in "${!assets_to_send[@]}"; do
    [[ ${idx} = "lovelace" ]] && continue
    [[ ${assets_to_send[${idx}]} -gt 0 ]] && assets_tx_out_d+="+${assets_to_send[${idx}]} ${idx}"
  done

  build_args=(
    ${tx_in}
    --invalid-hereafter ${ttl}
    --fee 0
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx0.tmp
  )
  if [[ ${outCount} -eq 1 ]]; then
    build_args+=( --tx-out "${d_addr}+0${assets_tx_out_d}" )
  else
    build_args+=( --tx-out "${s_addr}+0${assets_tx_out_s}" --tx-out "${d_addr}+0${assets_tx_out_d}" )
  fi

  if ! buildTx; then return 1; fi
  
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count ${outCount}
    ${NETWORK_IDENTIFIER}
    --witness-count 1
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"
  
  build_args=(
    ${tx_in}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx.raw
  )
  
  if [[ ${outCount} -eq 1 ]]; then # all assets to destination, nothing to return
    newBalance=0
    tx_out="${d_addr}+$(( ${assets_to_send[lovelace]} - min_fee ))${assets_tx_out_d}"
    getMinUTxO "${tx_out}"
    if [[ ${assets_to_send[lovelace]} -lt ${min_utxo_out} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in address ( $(formatLovelace ${assets_to_send[lovelace]}) < $(formatLovelace ${min_utxo_out}) )"
      println ERROR "Top up wallet with enough Ada to cover minimum UTxO balance"
      return 1
    fi
    build_args+=( --tx-out "${tx_out}" )
  else
    if [[ ${include_fee} = "no" ]]; then
      newBalance=$(( ${assets[lovelace]} - ${assets_to_send[lovelace]} - min_fee ))
      tx_out_d="${d_addr}+${assets_to_send[lovelace]}${assets_tx_out_d}"
    else
      newBalance=$(( ${assets[lovelace]} - ${assets_to_send[lovelace]} ))
      tx_out_d="${d_addr}+$(( ${assets_to_send[lovelace]} - min_fee ))${assets_tx_out_d}"
    fi
    getMinUTxO "${tx_out_d}"
    min_utxo_out_d=${min_utxo_out}
    build_args+=( --tx-out "${tx_out_d}" )
    
    tx_out_s="${s_addr}+${newBalance}${assets_tx_out_s}"
    getMinUTxO "${tx_out_s}"
    min_utxo_out_s=${min_utxo_out}
    build_args+=( --tx-out "${tx_out_s}" )
    
    if [[ ${newBalance} -lt ${min_utxo_out_s} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada left in source address ( $(formatLovelace ${newBalance}) < $(formatLovelace ${min_utxo_out_s}) )"
      println ERROR "Send all Ada or top up wallet with enough Ada to cover minimum UTxO balance"
      return 1
    elif [[ ${assets_to_send[lovelace]} -lt ${min_utxo_out_d} ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, requires ${FG_LBLUE}$(formatLovelace ${min_utxo_out_d})${NC} Ada to be sent along!"
      return 1
    fi
  fi
  
  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Payment"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${s_wallet}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"source-address\": \"${s_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"destination-address\": \"${d_addr}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { "assets": [] }" <<< ${offlineJSON}); then return 1; fi
    for idx in "${!assets_to_send[@]}"; do
      [[ ${assets_to_send[${idx}]} -gt 0 ]] && if ! offlineJSON=$(jq "."assets" += [{ asset: \"${idx}\", amount: \"${assets_to_send[${idx}]}\" }]" <<< ${offlineJSON}); then return 1; fi
    done
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${s_wallet}' payment signing key\", vkey: $(jq -c . "${s_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Source Wallet ${FG_GREEN}${s_wallet} ${FG_LGRAY}$(basename ${s_payment_sk_file})${NC}"  
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${s_payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : Delegate
# Description : Register pool with pledge on chain
delegate() {

  wallet_source="base"

  if ! getTTL; then return 1; fi
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_delegcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"
  
  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} Ada"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_delegcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Delegation"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-id\": \"${pool_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ ${pool_name} != "${pool_id}" ]]; then
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : withdrawRewards
# Description : withdraw rewards earned and send to wallet base address
withdrawRewards() {

  wallet_source="base"

  if ! getTTL; then return 1; fi
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee + reward_lovelace ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"

  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $((min_fee - reward_lovelace)))${NC} Ada"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee and withdrawal, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --withdrawal ${reward_addr}+${reward_lovelace}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Wallet Rewards Withdrawal"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { rewards: \"${reward_lovelace}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${stake_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${stake_sk_file}" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : registerPool
# Description : Register pool with pledge on chain
registerPool() {

  getBaseAddress ${owner_wallets[0]}
  getBalance ${base_addr}
  
  if ! getTTL; then return 1; fi
  
  stakePoolDeposit=$(jq -r '.stakePoolDeposit' <<< "${PROT_PARAMS}")
  println LOG "Pool Deposit is ${stakePoolDeposit}"
  
  owner_delegation_cert=""
  [[ ${delegate_owner_wallet} = 'Y' ]] && owner_delegation_cert="--certificate-file ${owner_delegation_cert_file}"
  
  witness_count=$(( 2 + ${#owner_wallets[@]} )) # owner payment + cold + multi-owners(main owner included)
  
  owner_delegation_cert=""
  if [[ ${delegate_owner_wallet} = 'Y' ]]; then
    owner_delegation_cert="${owner_delegation_cert_file}"
  fi
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )
  [[ -n ${owner_delegation_cert} ]] && build_args+=( --certificate-file "${owner_delegation_cert}" )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count ${witness_count}
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee - stakePoolDeposit ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) - $(formatLovelace ${stakePoolDeposit}) )"
  
  if [[ ${assets[lovelace]} -lt $(( min_fee + stakePoolDeposit )) ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in base address for tx fee and pool registration deposit!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace $(( min_fee + stakePoolDeposit )))${NC} Ada"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee and pool registration deposit, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )
  [[ -n ${owner_delegation_cert} ]] && build_args+=( --certificate-file "${owner_delegation_cert}" )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  for index in "${!owner_wallets[@]}"; do
    stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
    [[ $(jq .description "${stake_vk_file}") = *Hardware* ]] && needHWCLI=true && break
  done
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": \"${pledge_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": \"${cost_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"$(( min_fee + stakePoolDeposit ))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      if [[ ${index} -eq 0 ]]; then
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${owner_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
      stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    done
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { witness: [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}${POOL_COLDKEY_SK_FILENAME}${NC}" 
    println DEBUG "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_LGRAY}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}" 
    for index in "${!owner_wallets[@]}"; do
      [[ ${index} -eq 0 ]] && continue # skip main owner
      println DEBUG "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
    done
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  multi_owner_keys=()
  for index in "${!owner_wallets[@]}"; do
    [[ ${index} -eq 0 ]] && continue # skip main owner
    getWalletType ${owner_wallets[${index}]}
    multi_owner_keys+=( "${stake_sk_file}" )
  done
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : modifyPool
# Description : Register pool with pledge on chain
modifyPool() {

  getBaseAddress ${owner_wallets[0]}
  getBalance ${base_addr}
  
  if ! getTTL; then return 1; fi

  witness_count=$(( 2 + ${#owner_wallets[@]} )) # owner payment + cold + multi-owners(main owner included)
  
  getAssetsTxOut
  
  build_args=(
    ${tx_in}
    --tx-out "${base_addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count ${witness_count}
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"

  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in base address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} Ada"
    return 1
  fi
  
  tx_out="${base_addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_regcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  for index in "${!owner_wallets[@]}"; do
    stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
    [[ $(jq .description "${stake_vk_file}") = *Hardware* ]] && needHWCLI=true && break
  done
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool Update"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-metadata\": $(jq -c . "${pool_meta_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-pledge\": \"${pledge_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-margin\": \"${margin}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-cost\": \"${cost_ada}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-reg-cert\": $(jq -c . "${pool_regcert_file}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    for index in "${!owner_wallets[@]}"; do
      if [[ ${index} -eq 0 ]]; then
        if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #1 '${owner_wallets[0]}' payment signing key\", vkey: $(jq -c . "${owner_payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
      fi
      stake_vk_file="${WALLET_FOLDER}/${owner_wallets[${index}]}/${WALLET_STAKE_VK_FILENAME}"
      if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Owner #$((index+1)) '${owner_wallets[${index}]}' stake signing key\", vkey: $(jq -c . "${stake_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    done
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { witness: [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}${POOL_COLDKEY_SK_FILENAME}${NC}"
    println DEBUG "Owner #1 ${FG_GREEN}${owner_wallets[0]} ${FG_LGRAY}${WALLET_PAY_SK_FILENAME}${NC} & ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
    for index in "${!owner_wallets[@]}"; do
      [[ ${index} -eq 0 ]] && continue # skip main owner
      println DEBUG "Owner #$((index+1)) ${FG_GREEN}${owner_wallets[${index}]} ${FG_LGRAY}${WALLET_STAKE_SK_FILENAME}${NC}"
    done
    return 2 # return as failed to stop main processing and return to home menu
  fi

  multi_owner_keys=()
  for index in "${!owner_wallets[@]}"; do
    [[ ${index} -eq 0 ]] && continue # skip main owner
    getWalletType ${owner_wallets[${index}]}
    multi_owner_keys+=( "${stake_sk_file}" )
  done

  if ! witnessTx "${TMP_DIR}/tx.raw" "${owner_payment_sk_file}" "${pool_coldkey_sk_file}" "${owner_stake_sk_file}" "${multi_owner_keys[@]}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}

# Command     : deRegisterPool
# Description : Retire pool
deRegisterPool() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  getBalance ${addr}
  if ! getTTL; then return 1; fi

  getAssetsTxOut

  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    --certificate-file "${pool_deregcert_file}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"

  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} Ada"
    return 1
  fi

  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --certificate-file "${pool_deregcert_file}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  pay_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_VK_FILENAME}"
  [[ $(jq .description "${pay_vk_file}") = *Hardware* ]] && needHWCLI=true
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Pool De-Registration"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -f "${POOL_FOLDER}/${pool_name}/poolmeta.json" ]]; then
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"$(jq -r .name "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"$(jq -r .ticker "${POOL_FOLDER}/${pool_name}/poolmeta.json")\" }" <<< ${offlineJSON}); then return 1; fi
    else
      if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
      if ! offlineJSON=$(jq ". += { \"pool-ticker\": \"\" }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { \"retire-epoch\": \"${epoch_enter}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}$(basename ${pool_coldkey_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi

  getWalletType ${wallet_name}

  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${pool_coldkey_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi

}

# Command     : rotatePoolKeys
# Description : Rotate pool's KES keys
# parameters  : $1 = cold counter (offline mode)
rotatePoolKeys() {

  # cold keys
  if getPoolType ${pool_name} ; then needHWCLI="true" ;fi

  # generated files
  pool_hotkey_vk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_VK_FILENAME}"
  pool_hotkey_sk_file="${POOL_FOLDER}/${pool_name}/${POOL_HOTKEY_SK_FILENAME}"
  pool_opcert_counter_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_COUNTER_FILENAME}"
  pool_saved_kes_start="${POOL_FOLDER}/${pool_name}/${POOL_CURRENT_KES_START}"
  pool_opcert_file="${POOL_FOLDER}/${pool_name}/${POOL_OPCERT_FILENAME}"

  if [[ ! -f ${pool_coldkey_vk_file} ]]; then # lets re-generate it from cold signing key
    println ACTION "${CCLI} key verification-key --signing-key-file ${pool_coldkey_sk_file} --verification-key-file ${pool_coldkey_vk_file}"
    ! ${CCLI} key verification-key --signing-key-file "${pool_coldkey_sk_file}" --verification-key-file "${pool_coldkey_vk_file}" && return 1
    output=$(jq '.description = "Stake Pool Operator Verification Key"' "${pool_coldkey_vk_file}") && jq <<< ${output} > "${pool_coldkey_vk_file}"
  fi

  current_kes_period=$(getCurrentKESperiod)
  echo "${current_kes_period}" > ${pool_saved_kes_start}

  println ACTION "${CCLI} node key-gen-KES --verification-key-file ${pool_hotkey_vk_file} --signing-key-file ${pool_hotkey_sk_file}"
  ! ${CCLI} node key-gen-KES --verification-key-file "${pool_hotkey_vk_file}" --signing-key-file "${pool_hotkey_sk_file}" && return 1

  p_opcert=""
  if [[ $# -eq 1 ]]; then
    println ACTION "${CCLI} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value $1 --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    ! ${CCLI} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value $1 --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" && return 1
  elif [[ -n ${KOIOS_API} ]]; then
    ! getPoolID "${pool_name}" && println "ERROR" "\n${FG_RED}ERROR${NC}: failed to get pool ID!\n" && return 1
    println ACTION "curl -sSL -f -X POST -H \"Content-Type: application/json\" -d '{\"_pool_bech32_ids\":[\"${pool_id_bech32}\"]}' ${KOIOS_API}/pool_info"
    ! pool_info=$(curl -sSL -f -X POST -H "Content-Type: application/json" -d '{"_pool_bech32_ids":["'${pool_id_bech32}'"]}' "${KOIOS_API}/pool_info" 2>&1) && println "ERROR" "\n${FG_RED}KOIOS_API ERROR${NC}: ${pool_info}\n" && p_opcert="" # print error but ignore
    if old_counter_nbr=$(jq -er '.[0].op_cert_counter' <<< "${pool_info}" 2>/dev/null); then
      new_counter_nbr=$(( old_counter_nbr + 1 ))
    else
      new_counter_nbr=0 # null returned = no block on chain for this pool
    fi
    println ACTION "${CCLI} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    ! ${CCLI} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" && return 1
  elif [[ -f ${pool_opcert_file} ]]; then
    println ACTION "${CCLI} query kes-period-info --op-cert-file ${pool_opcert_file} ${NETWORK_IDENTIFIER}"
    if ! kes_period_info=$(${CCLI} query kes-period-info --op-cert-file "${pool_opcert_file}" ${NETWORK_IDENTIFIER}); then
      println "ERROR" "\n${FG_RED}ERROR${NC}: failed to grab counter from node: [${kes_period_info}]\n" && return 1
    fi
    if old_counter_nbr=$(awk '/{/,0' <<< "${kes_period_info}" | jq -er '.qKesNodeStateOperationalCertificateNumber' 2>/dev/null); then
      new_counter_nbr=$(( old_counter_nbr + 1 ))
    else
      new_counter_nbr=0 # null returned = no block on chain for this pool
    fi
    println ACTION "${CCLI} node new-counter --cold-verification-key-file ${pool_coldkey_vk_file} --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file ${pool_opcert_counter_file}"
    ! ${CCLI} node new-counter --cold-verification-key-file "${pool_coldkey_vk_file}" --counter-value ${new_counter_nbr} --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" && return 1
  else
    println "ERROR" "\n${FG_RED}ERROR${NC}: op cert file missing and Koios disabled/unavailable. Unable to get current on-chain counter value!\n" && return 1
  fi

  if [[ ${needHWCLI} = true ]]; then
    if ! unlockHWDevice "issue the opcert"; then return 1; fi
    println ACTION "cardano-hw-cli node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --hw-signing-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}"
    ! cardano-hw-cli node issue-op-cert \
    --kes-verification-key-file "${pool_hotkey_vk_file}" \
    --hw-signing-file "${pool_coldkey_sk_file}" \
    --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" \
    --kes-period "${current_kes_period}" \
    --out-file "${pool_opcert_file}" \
    && return 1

  else
    println ACTION "${CCLI} node issue-op-cert --kes-verification-key-file ${pool_hotkey_vk_file} --cold-signing-key-file ${pool_coldkey_sk_file} --operational-certificate-issue-counter-file ${pool_opcert_counter_file} --kes-period ${current_kes_period} --out-file ${pool_opcert_file}"
    ! ${CCLI} node issue-op-cert --kes-verification-key-file "${pool_hotkey_vk_file}" --cold-signing-key-file "${pool_coldkey_sk_file}" --operational-certificate-issue-counter-file "${pool_opcert_counter_file}" --kes-period "${current_kes_period}" --out-file "${pool_opcert_file}" && return 1
  fi

  chmod 700 ${POOL_FOLDER}/${pool_name}/*

  unset remaining_kes_periods
  kesExpiration ${current_kes_period}
}

# Command     : sendMetadata
# Description : post metadata file on chain using specified wallet to pay for the transaction fee
sendMetadata() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  if [[ ${metatype} = "no-schema" ]]; then
    metafile_param="--json-metadata-no-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "detailed-schema" ]]; then
    metafile_param="--json-metadata-detailed-schema --metadata-json-file ${metafile}"
  elif [[ ${metatype} = "cbor" ]]; then
    metafile_param="--metadata-cbor-file ${metafile}"
  else
    println ERROR "${FG_RED}ERROR${NC}: unknown metadata type '${metatype}'"
    return 1
  fi

  getBalance ${addr}
  if ! getTTL; then return 1; fi

  getAssetsTxOut

  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    ${metafile_param}
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 1
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"

  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} Ada"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Metadata"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}" 
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : mintAsset
# Description : mint a custom asset using specified wallet to pay for the transaction fee
mintAsset() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"

  getBalance ${addr}
  if [[ ${policy_ttl} -eq 0 ]]; then 
    if ! getTTL; then return 1; fi
  else
    ttl=${policy_ttl}
    tip_ref=$(getSlotTipRef)
    println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl} based on policy expiration"
  fi
  
  [[ -z ${asset_name} ]] && asset_name_out="" || asset_name_out=".$(asciiToHex "${asset_name}")"
  getAssetsTxOut "${policy_id}${asset_name_out}" "${assets_to_mint}"
  
  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --mint "${assets_to_mint} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee 0
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi
  
  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"

  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} Ada"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --mint "${assets_to_mint} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Asset Minting"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-name\": \"${policy_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-id\": \"${policy_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-name\": \"$(asciiToHex "${asset_name}") (${asset_name})\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-amount\": \"${assets_to_mint}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-minted\": \"${asset_minted}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Asset '${policy_sk_file}' policy signing key\", vkey: $(jq -c . "${policy_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Policy ${FG_GREEN}${policy_name} ${FG_LGRAY}$(basename ${policy_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${policy_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : burnAsset
# Description : burn custom assets on specified wallet
burnAsset() {

  getBalance ${addr}
  if [[ ${policy_ttl} -eq 0 ]]; then 
    if ! getTTL; then return 1; fi
  else
    ttl=${policy_ttl}
    tip_ref=$(getSlotTipRef)
    println LOG "Current slot is ${tip_ref}, setting ttl to ${ttl} based on policy expiration"
  fi
  
  [[ -z ${asset_name} ]] && asset_name_out="" || asset_name_out=".${asset_name}"
  getAssetsTxOut "${policy_id}${asset_name_out}" "-${assets_to_burn}"
  
  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --mint "-${assets_to_burn} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee 0
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"
  
  newBalance=$(( ${assets[lovelace]} - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"
  
  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} Ada"
    return 1
  fi
  
  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi
  
  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --mint "-${assets_to_burn} ${policy_id}${asset_name_out}"
    --mint-script-file "${policy_script_file}"
    ${metafile_param}
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi
  
  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Asset Burning"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-name\": \"${policy_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"policy-id\": \"${policy_id}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-name\": \"${asset_name} ($(hexToAscii ${asset_name}))\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-amount\": \"${assets_to_burn}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"asset-minted\": \"${asset_minted}\" }" <<< ${offlineJSON}); then return 1; fi
    if [[ -n ${metafile_param} ]]; then
      if ! offlineJSON=$(jq ". += { metadata: $(jq -c . "${metafile}") }" <<< ${offlineJSON}); then return 1; fi
    fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Asset '${policy_sk_file}' policy signing key\", vkey: $(jq -c . "${policy_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}" 
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:" 
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Policy ${FG_GREEN}${policy_name} ${FG_LGRAY}$(basename ${policy_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi
  
  if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${policy_sk_file}"; then return 1; fi
  if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
  if ! submitTx "${tx_signed}"; then return 1; fi
}


# Command     : buildTx [build_args]
# Description : Helper function to build a raw transaction
#             : populate an array variable called 'build_args' with all data
# Parameters  : build_args  >  an array with all the arguments to assemble the transaction
buildTx() {
  println ACTION "${CCLI} transaction build-raw ${ERA_IDENTIFIER} --cddl-format ${build_args[*]}"
  ${CCLI} transaction build-raw ${ERA_IDENTIFIER} --cddl-format "${build_args[@]}"
}

# Command     : witnessTx [raw tx file] [signing keys ...]
# Description : Helper function to witness a raw transaction
# Parameters  : raw tx file   >  the transaction file to sign
#             : signing keys  >  list of signing keys to use when witnessing the transaction
witnessTx() {
  tx_raw="$1"
  shift
  tx_witness_files=()
  unset isHW
  for skey in "$@"; do
    [[ -z ${skey//[[:blank:]]/} ]] && continue
    if [[ ! -f "${skey}" ]]; then
      println ERROR "\n${FG_RED}ERROR${NC}: file not found: ${skey}"
      return 1
    elif [[ $(jq -r '.description' "${skey}") = *"Hardware"* ]]; then # HW signing key
      if [[ ${isHW} = 'Y' ]]; then
        # just add key and output to witness_command()
        tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
        hw_witness_command+=(
          --hw-signing-file "${skey}"
          --change-output-key-file "${skey}"
          --out-file "${tx_witness}"
        )
      else
        isHW=Y
        tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
        hw_witness_command=(
          cardano-hw-cli transaction witness
          --tx-file "${tx_raw}"
          --hw-signing-file "${skey}"
          --change-output-key-file "${skey}"
          --out-file "${tx_witness}"
          ${NETWORK_IDENTIFIER}
        )
      fi
    else
      tx_witness="$(mktemp "${TMP_DIR}/tx.witness_XXXXXXXXXX")"
      witness_command=(
        ${CCLI} transaction witness
        --tx-body-file "${tx_raw}"
        --signing-key-file "${skey}"
        ${NETWORK_IDENTIFIER}
        --out-file "${tx_witness}"
      )
      println ACTION "${witness_command[@]}"
      if ! "${witness_command[@]}"; then println ERROR "\n${FG_RED}ERROR${NC}: during transaction signing !!" && return 1; fi
    fi
    tx_witness_files+=( "${tx_witness}" )
  done

  # Special case for HW
  if [[ ${isHW} = 'Y' ]]; then
    if ! unlockHWDevice "witness the transaction"; then return 1; fi
    println ACTION "${hw_witness_command[@]}"
    if ! "${hw_witness_command[@]}"; then println ERROR "\n${FG_RED}ERROR${NC}: during hardware wallet signing !!" && return 1; fi
  fi
}

# Command     : assembleTx [raw tx file]
# Description : Helper function to witnessTx for assembling a signed tx using witnesses from tx_witness_files[] array
assembleTx() {
  tx_raw="$1"
  tx_signed="${TMP_DIR}/tx.signed_$(date +%s)"
  if [[ ${#tx_witness_files[@]} -gt 0 ]]; then # assemble witness files and sign
    tx_witness_out=()
    for witness in "${tx_witness_files[@]}"; do
      [[ -z ${witness//[[:blank:]]/} || ! -s "${witness}" ]] && continue
      if [[ -f "${witness}" ]]; then
        tx_witness_out+=( "--witness-file ${witness}" )
      else
        println ERROR "\n${FG_RED}ERROR${NC}: witness file not found: ${witness}"
        return 1
      fi
    done
    sign_command=(
      ${CCLI} transaction assemble
      --tx-body-file "${tx_raw}"
      ${tx_witness_out[@]}
      --out-file "${tx_signed}"
    )
    println ACTION "${sign_command[@]}"
    "${sign_command[@]}"
  else
    println ERROR "\n${FG_RED}ERROR${NC}: no witness files provided, unable to assemble tx!"
    return 1
  fi
}

# Command     : submitTx [signed tx file]
# Description : Helper function to submit signed transaction file
# Parameters  : signed tx file   >  the signed transaction file to submit
submitTx() {
  tx_signed="$1"

  submit_command=(
    ${CCLI} transaction submit
    --tx-file "${tx_signed}"
    ${NETWORK_IDENTIFIER}
  )
  
  println ACTION "${submit_command[@]}"
  "${submit_command[@]}"
}

# Command     : transformRawTx [raw tx file]
# Description : Transform raw tx to be in canonical order for HW wallets 
# Parameters  : raw tx file  >  path to raw tx to correct
transformRawTx() {
  tx_raw="$1"
  tx_raw_tmp="$(mktemp "${TMP_DIR}/tx.raw_XXXXXXXXXX")"
  println ACTION "cardano-hw-cli transaction transform --tx-file ${tx_raw} --out-file ${tx_raw_tmp}"
  if ! cardano-hw-cli transaction transform --tx-file "${tx_raw}" --out-file "${tx_raw_tmp}" >/dev/null; then return 1; fi
  println ACTION "mv ${tx_raw_tmp} ${tx_raw}"
  if ! mv "${tx_raw_tmp}" "${tx_raw}" >/dev/null; then return 1; fi
}

# Command     : unlockHWDevice [action]
# Description : Directions to unlock and open HW device
# Parameters  : action  >  message for action to be taken
unlockHWDevice() {
  if ! HWCLIversionCheck; then waitForInput && return 1; fi
  waitForInput "${FG_BLUE}INFO${NC}: please connect and unlock hardware device" "\n  ${FG_YELLOW}Ledger${NC} - Unlock with pin and open Cardano app" "\n  ${FG_YELLOW}Trezor${NC} - Make sure trezor bridge is installed (https://wallet.trezor.io/#/bridge) " "\n\nwhen done, press any key to continue"
  println ACTION "cardano-hw-cli device version"
  device_app="$(cardano-hw-cli device version)"
  device_app_vendor="$(cut -d' ' -f1 <<< "${device_app}")"
  device_app_version="$(cut -d' ' -f4 <<< "${device_app}")"
  println LOG "hardware device: vendor=${device_app_vendor} version=${device_app_version}"
  if [[ ! ${device_app_version} =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    println ERROR "${FG_RED}ERROR${NC}: unable to identify connected hardware device, is the device plugged in and unlocked?"
    println ERROR "Make sure device is seen by OS using tools like lsusb etc and is working correctly"
    waitForInput && return 1
  elif [[ ${device_app_vendor} = Ledger ]]; then
    if ! versionCheck "3.0.0" "${device_app_version}"; then
      println ERROR "${FG_RED}ERROR${NC}: Cardano app version installed on Ledger is ${FG_LGRAY}v${device_app_version}${NC}, minimum required app version is ${FG_GREEN}v3.0.0${NC} !!"
      return 1
    fi
  elif [[ ${device_app_vendor} = Trezor ]]; then
    if ! versionCheck "2.4.3" "${device_app_version}"; then
      println ERROR "${FG_RED}ERROR${NC}: Trezor firmware installed on device is ${FG_LGRAY}v${device_app_version}${NC}, minimum required version is ${FG_GREEN}v2.4.3${NC} !!"
      return 1
    fi
  else
    println ERROR "${FG_RED}ERROR${NC}: Unknown vendor: ${FG_LGRAY}${device_app_vendor}${NC} !!"
    return 1
  fi
  println DEBUG "\n${FG_BLUE}INFO${NC}: follow directions on hardware device to $1"
}

HWCLIversionCheck() {
  ! command -v "cardano-hw-cli" &>/dev/null && echo "cardano-hw-cli not found, please install using guild-deploy.sh with '-s w' option" && return 1
  println ACTION "cardano-hw-cli version"
  HWCLI_version="$(cardano-hw-cli version 2>/dev/null | head -n 1 | cut -d' ' -f6)"
  println LOG "cardano-hw-cli version: ${HWCLI_version}"
  if ! versionCheck "1.10.0" "${HWCLI_version}"; then
    println ERROR "${FG_RED}ERROR${NC}: Vacuumlabs cardano-hw-cli ${FG_LGRAY}v${HWCLI_version}${NC} installed on system, minimum required version is ${FG_GREEN}v1.10.0${NC} !!"
    println ERROR "Please run ${FG_LGRAY}guild-deploy.sh -s w${NC} to upgrade to the latest version."
    return 1
  fi
  return 0
}

# Command     : selectOpMode
# Description : Helper function to choose operational mode
selectOpMode() {
  println OFF "\nOnline mode  -  The default mode to use if all keys are available\n"\
		"Hybrid mode  -  1) Go through steps to build a transaction file"\
		"                2) Copy built tx file to offline computer"\
		"                3) Sign it using 'Sign Tx' with keys on offline computer"\
		"                   (CNTools started in offline mode '-o' without node connection)"\
		"                4) Copy the signed tx file back to online computer and submit using 'Submit Tx'\n"
  select_opt "[o] Online" "[h] Hybrid" "[Esc] Cancel"
  case $? in
    0) op_mode="online" ;;
    1) op_mode="hybrid" ;;
    2) return 1 ;;
  esac
}

# Command     : to_cbor
# Description : converts different majortypes and there values into a cborHexString
# Original src: SPO Scripts (https://github.com/gitmachtl/scripts/blob/master/cardano/testnet/00_common.sh#L979) 
to_cbor() {

  # ${1} type: unsigned, negative, bytes, string, array, map, tag
  # ${2} value: unsigned int value or hexstring for bytes

  local type=${1}
  local value="${2}"

  # majortypes
  #  unsigned      000x|xxxx       majortype 0     not limited, but above 18446744073709551615 (2^64), the numbers are represented via tag2 + bytearray
  #  bytes         010x|xxxx       majortype 2     limited to max. 65535 here
  #  array         100x|xxxx       majortype 4     limited to max. 65535 here
  #  map           101x|xxxx       majortype 5     limited to max. 65535 here
  # extras - not used yet but implemented for the future
  #  negative    001x|xxxx    majortype 1    not limited, but below -18446744073709551616 (-2^64 -1), the numbers are represented via tag3 + bytearray
  #  string    011x|xxxx    majortype 3    limited to max. 65535 chars
  #  tag           110x|xxxx       majortype 6     limited to max. 65535 here

  case ${type} in
    #unsigned - input is an unsigned integer, range is selected via a bc query because bash can't handle big numbers
    unsigned )
      if [[ $(bc <<< "${value} < 24") -eq 1 ]]; then printf -v cbor "%02x" $((10#${value})) #1byte total value below 24
      elif [[ $(bc <<< "${value} < 256") -eq 1 ]]; then printf -v cbor "%04x" $((0x1800 + 10#${value})) #2bytes total: first 0x1800 + 1 lower byte value
      elif [[ $(bc <<< "${value} < 65536") -eq 1 ]]; then printf -v cbor "%06x" $((0x190000 + 10#${value})) #3bytes total: first 0x190000 + 2 lowerbytes value
      elif [[ $(bc <<< "${value} < 4294967296") -eq 1 ]]; then printf -v cbor "%10x" $((0x1A00000000 + 10#${value})) #5bytes total: 0x1A00000000 + 4 lower bytes value
      elif [[ $(bc <<< "${value} < 18446744073709551616") -eq 1 ]]; then local tmp="00$(bc <<< "obase=16;ibase=10;${value}+498062089990157893632")"; cbor="${tmp: -18}" #9bytes total: first 0x1B0000000000000000 + 8 lower bytes value
      #if value does not fit into an 8byte unsigned integer, the cbor representation is tag2(pos.bignum)+bytearray of the value
      else local cbor=$(to_cbor "tag" 2); local tmp="00$(bc <<< "obase=16;ibase=10;${value}")"; tmp=${tmp: -$(( (${#tmp}-1)/2*2 ))}; local cbor+=$(to_cbor "bytes" ${tmp}) #fancy calc to get a leading zero in the hex array if needed
      fi
      ;;
    #bytestring - input is a hexstring
    bytes )
      local bytesLength=$(( ${#value} / 2 ))  #bytesLength is length of value /2 because of hex encoding (2chars -> 1byte)
      if [[ ${bytesLength} -lt 24 ]]; then printf -v cbor "%02x${value}" $((0x40 + 10#${bytesLength})) #1byte total 0x40 + lower part value & bytearrayitself
      elif [[ ${bytesLength} -lt 256 ]]; then printf -v cbor "%04x${value}" $((0x5800 + 10#${bytesLength})) #2bytes total: first 0x4000 + 0x1800 + 1 lower byte value & bytearrayitself
      elif [[ ${bytesLength} -lt 65536 ]]; then printf -v cbor "%06x${value}" $((0x590000 + 10#${bytesLength})) #3bytes total: first 0x400000 + 0x190000 + 2 lower bytes value & bytearrayitself
      fi
      ;;
    #array - input is an unsigned integer
    array )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0x80 + 10#${value})) #1byte total 0x80 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0x9800 + 10#${value})) #2bytes total: first 0x8000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0x990000 + 10#${value})) #3bytes total: first 0x800000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    #map - input is an unsigned integer
    map )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0xA0 + 10#${value})) #1byte total 0xA0 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0xB800 + 10#${value})) #2bytes total: first 0xA000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0xB90000 + 10#${value})) #3bytes total: first 0xA00000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    ###
    ### the following types are not used in these scripts yet, but added to have a more complete function for the future
    ###
    #negative - input is a negative unsigned integer, range is selected via a bc query because bash can't handle big numbers
    negative )
      local value=$(bc <<< "${value//-/} -1") #negative representation in cbor is the neg. number as a pos. number minus 1, so a -500 will be represented as a 499
      if [[ $(bc <<< "${value} < 24") -eq 1 ]]; then printf -v cbor "%02x" $((0x20 + 10#${value})) #1byte total 0x20 value below 24
      elif [[ $(bc <<< "${value} < 256") -eq 1 ]]; then printf -v cbor "%04x" $((0x3800 + 10#${value})) #2bytes total: first 0x2000 + 0x1800 + 1 lower byte value
      elif [[ $(bc <<< "${value} < 65536") -eq 1 ]]; then printf -v cbor "%06x" $((0x390000 + 10#${value})) #3bytes total: first 0x200000 + 0x190000 + 2 lowerbytes value
      elif [[ $(bc <<< "${value} < 4294967296") -eq 1 ]]; then printf -v cbor "%10x" $((0x3A00000000 + 10#${value})) #5bytes total: 0x2000000000 + 0x1A00000000 + 4 lower bytes value
      elif [[ $(bc <<< "${value} < 18446744073709551616") -eq 1 ]]; then local tmp="00$(bc <<< "obase=16;ibase=10;${value}+1088357900348863545344")"; cbor="${tmp: -18}" #9bytes total: first 0x3B0000000000000000 + 8 lower bytes value
      #if value does not fit into an 8byte unsigned integer, the cbor representation is tag3(neg.bignum)+bytearray of the value
      else local cbor=$(to_cbor "tag" 3); local tmp="00$(bc <<< "obase=16;ibase=10;${value}")"; tmp=${tmp: -$(( (${#tmp}-1)/2*2 ))}; local cbor+=$(to_cbor "bytes" ${tmp}) #fancy calc to get a leading zero in the hex array if needed
      fi
      ;;
    #tag - input is an unsigned integer
    tag )
      if [[ ${value} -lt 24 ]]; then printf -v cbor "%02x" $((0xC0 + 10#${value})) #1byte total 0xC0 + lower part value
      elif [[ ${value} -lt 256 ]]; then printf -v cbor "%04x" $((0xD800 + 10#${value})) #2bytes total: first 0xC000 + 0x1800 & 1 lower byte value
      elif [[ ${value} -lt 65536 ]]; then printf -v cbor "%06x" $((0xD90000 + 10#${value})) #3bytes total: first 0xC00000 + 0x190000 & 2 lower bytes value
      fi
      ;;
    #textstring - input is a utf8-string
    string )
      local value=$(echo -ne "${value}" | xxd -p -c 65536 | tr -d '\n') #convert the given string into a hexstring and process it further like a bytearray
      local bytesLength=$(( ${#value} / 2 ))  #bytesLength is length of value /2 because of hex encoding (2chars -> 1byte)
      if [[ ${bytesLength} -lt 24 ]]; then printf -v cbor "%02x${value}" $((0x60 + 10#${bytesLength})) #1byte total 0x60 + lower part value & bytearrayitself
      elif [[ ${bytesLength} -lt 256 ]]; then printf -v cbor "%04x${value}" $((0x7800 + 10#${bytesLength})) #2bytes total: first 0x6000 + 0x1800 + 1 lower byte value & bytearrayitself
      elif [[ ${bytesLength} -lt 65536 ]]; then printf -v cbor "%06x${value}" $((0x790000 + 10#${bytesLength})) #3bytes total: first 0x600000 + 0x190000 + 2 lower bytes value & bytearrayitself
      fi
      ;;
  esac
  echo -n "${cbor^^}" #return the cbor in uppercase
}

# Command     : submitPoll
# Description : sign and submit a CIP-0094 poll answer
submitPoll() {

  [[ $(cat "${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_ADDR_FILENAME}" 2>/dev/null) = "${addr}" ]] && wallet_source="enterprise" || wallet_source="base"
  POOL_ID_HASH=$(cat ${POOL_FOLDER}/${pool_name}/${POOL_ID_FILENAME})

  getBalance ${addr}
  if ! getTTL; then return 1; fi
  getAssetsTxOut
  metafile_param="--metadata-cbor-file ${cborFile}"
  if [[ -n ${metafile} && -f ${metafile} ]]; then
    metafile_param+=" --json-metadata-no-schema --metadata-json-file ${metafile}"
  fi

  build_args=(
    ${tx_in}
    --tx-out "${addr}+0${assets_tx_out}"
    --invalid-hereafter ${ttl}
    --fee 0
    ${metafile_param}
    --required-signer-hash "${POOL_ID_HASH}"
    --out-file "${TMP_DIR}"/tx0.tmp
  )

  if ! buildTx; then return 1; fi

  min_fee_args=(
    transaction calculate-min-fee
    --tx-body-file "${TMP_DIR}"/tx0.tmp
    --tx-in-count ${utxo_cnt}
    --tx-out-count 1
    ${NETWORK_IDENTIFIER}
    --witness-count 2
    --byron-witness-count 0
    --protocol-params-file "${TMP_DIR}"/protparams.json
  )
  println ACTION "${CCLI} ${min_fee_args[*]}"
  min_fee=$([[ "$(${CCLI} ${min_fee_args[*]})" =~ ([0-9]+) ]] && echo ${BASH_REMATCH[1]})
  println LOG "fee is $(formatLovelace ${min_fee}) Ada"

  newBalance=$(( ${assets[lovelace]} - min_fee ))
  println LOG "Balance left to be returned in used UTxO is $(formatLovelace ${newBalance}) Ada ( $(formatLovelace ${assets[lovelace]}) - $(formatLovelace ${min_fee}) )"

  if [[ ${assets[lovelace]} -lt ${min_fee} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: Not enough Ada in ${wallet_source} address for tx fee!"\
			"Funds in address: ${FG_LBLUE}$(formatLovelace ${assets[lovelace]})${NC} Ada"\
			"Minimum required: ${FG_LBLUE}$(formatLovelace ${min_fee})${NC} Ada"
    return 1
  fi

  tx_out="${addr}+${newBalance}${assets_tx_out}"
  getMinUTxO "${tx_out}"
  if [[ ${newBalance} -lt ${min_utxo_out} ]]; then
    println ERROR "\n${FG_RED}ERROR${NC}: minimum UTxO value not fulfilled, only ${FG_LBLUE}$(formatLovelace ${newBalance})${NC} Ada left in address after tx fee, at least ${FG_LBLUE}$(formatLovelace ${min_utxo_out})${NC} Ada required!"
    return 1
  fi

  build_args=(
    ${tx_in}
    --tx-out "${tx_out}"
    --invalid-hereafter ${ttl}
    --fee ${min_fee}
    ${metafile_param}
    --required-signer-hash "${POOL_ID_HASH}"
    --out-file "${TMP_DIR}"/tx.raw
  )

  if ! buildTx; then return 1; fi

  needHWCLI=false
  pay_vk_file="${WALLET_FOLDER}/${wallet_name}/${WALLET_PAY_VK_FILENAME}"
  [[ $(jq .description "${pay_vk_file}") = *Hardware* ]] && needHWCLI=true
  if [[ ${needHWCLI} = true ]]; then
    if ! HWCLIversionCheck; then return 1; fi
    if ! transformRawTx "${TMP_DIR}"/tx.raw; then return 1; fi
  fi

  if [[ ${op_mode} = "hybrid" ]]; then
    if ! buildOfflineJSON "Poll Cast"; then return 1; fi
    if ! offlineJSON=$(jq ". += { \"wallet-name\": \"${wallet_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txFee: \"${min_fee}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-title\": \"${poll_title}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-txId\": \"${poll_txId}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-question\": \"${questionString}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"poll-answer\": \"${optionString[${answer}]}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"pool-name\": \"${pool_name}\" }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { txBody: $(jq -c . "${TMP_DIR}"/tx.raw) }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signing-file\": [] }" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Wallet '${wallet_name}' payment signing key\", vkey: $(jq -c . "${payment_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ".\"signing-file\" += [{ name: \"Pool '${pool_name}' cold signing key\", vkey: $(jq -c . "${pool_coldkey_vk_file}") }]" <<< ${offlineJSON}); then return 1; fi
    if ! offlineJSON=$(jq ". += { \"signed-txBody\": {} }" <<< ${offlineJSON}); then return 1; fi
    offline_tx="${TMP_DIR}/offline_tx_$(jq -r .id <<< ${offlineJSON}).json"
    jq -r . <<< "${offlineJSON}" > "${offline_tx}"
    echo
    println "Offline transaction successfully built and saved to: ${FG_LGRAY}${offline_tx}${NC}"
    println DEBUG "move file to offline computer and sign it using CNTools in offline mode '-o' [Transaction >> Sign] with:"
    println DEBUG "Wallet ${FG_GREEN}${wallet_name} ${FG_LGRAY}$(basename ${payment_sk_file})${NC}"
    println DEBUG "Pool ${FG_GREEN}${pool_name} ${FG_LGRAY}$(basename ${pool_coldkey_sk_file})${NC}"
    return 2 # return as failed to stop main processing and return to home menu
  fi

  getWalletType ${wallet_name}
  echo "Transaction Fee: $(formatLovelace ${min_fee}) Ada"
  println "\n# Do you want to publish this answer for pool ${pool_name} on ${NETWORK_NAME}?"
  select_opt "[n] No" "[y] Yes"
  case $? in
   1) if ! witnessTx "${TMP_DIR}/tx.raw" "${payment_sk_file}" "${pool_coldkey_sk_file}"; then return 1; fi
      if ! assembleTx "${TMP_DIR}/tx.raw"; then return 1; fi
      if ! submitTx "${tx_signed}"; then return 1; fi
      println "Poll ${FG_GREEN}${poll_txId}${NC} ballot casted to the network"
      waitForInput && continue
  esac
}
