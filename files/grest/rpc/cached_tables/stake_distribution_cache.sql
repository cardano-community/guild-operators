CREATE TABLE IF NOT EXISTS GREST.STAKE_DISTRIBUTION_CACHE (
  STAKE_ADDRESS varchar PRIMARY KEY,
  POOL_ID varchar, -- Index added after data is inserted
  TOTAL_BALANCE numeric,
  UTXO numeric,
  REWARDS numeric,
  WITHDRAWALS numeric,
  REWARDS_AVAILABLE numeric,
  RESERVES numeric,
  TREASURY numeric
);

CREATE TABLE IF NOT EXISTS GREST.CONTROL_TABLE (
  key text PRIMARY KEY,
  last_value text NOT NULL,
  artifacts text
);

DROP PROCEDURE IF EXISTS GREST.UPDATE_STAKE_DISTRIBUTION_CACHE ();

DROP FUNCTION IF EXISTS GREST.UPDATE_STAKE_DISTRIBUTION_CACHE ();

CREATE PROCEDURE GREST.UPDATE_STAKE_DISTRIBUTION_CACHE ()
LANGUAGE PLPGSQL
AS $$
DECLARE
  -- Last block height to control future re-runs of the query
  _last_accounted_block_height bigint;
  _last_accounted_block_id bigint;
BEGIN
  SELECT
    block_no,
    id
  FROM
    PUBLIC.BLOCK
  WHERE
    block_no IS NOT NULL
    AND block_no = (
      SELECT
        MAX(BLOCK_NO) - 5
      FROM
        PUBLIC.BLOCK) INTO _last_accounted_block_height,
  _last_accounted_block_id;
  INSERT INTO GREST.STAKE_DISTRIBUTION_CACHE
  SELECT
    STAKE_ADDRESS,
    POOL_ID,
    CASE WHEN (COALESCE(REWARDS_T.REWARDS, 0) - COALESCE(WITHDRAWALS_T.WITHDRAWALS, 0)) < 0 THEN
      COALESCE(UTXO_T.UTXO, 0) + COALESCE(REWARDS_T.REWARDS, 0) - COALESCE(WITHDRAWALS_T.WITHDRAWALS, 0) + COALESCE(RESERVES_T.RESERVES, 0) + COALESCE(TREASURY_T.TREASURY, 0) - (COALESCE(REWARDS_T.REWARDS, 0) - COALESCE(WITHDRAWALS_T.WITHDRAWALS, 0))
    ELSE
      COALESCE(UTXO_T.UTXO, 0) + COALESCE(REWARDS_T.REWARDS, 0) - COALESCE(WITHDRAWALS_T.WITHDRAWALS, 0) + COALESCE(RESERVES_T.RESERVES, 0) + COALESCE(TREASURY_T.TREASURY, 0)
    END AS TOTAL_BALANCE,
    COALESCE(UTXO_T.UTXO, 0) AS UTXO,
    COALESCE(REWARDS_T.REWARDS, 0) AS REWARDS,
    COALESCE(WITHDRAWALS_T.WITHDRAWALS, 0) AS WITHDRAWALS,
    CASE WHEN (COALESCE(REWARDS_T.REWARDS, 0) - COALESCE(WITHDRAWALS_T.WITHDRAWALS, 0)) <= 0 THEN
      0
    ELSE
      COALESCE(REWARDS_T.REWARDS, 0) - COALESCE(WITHDRAWALS_T.WITHDRAWALS, 0)
    END AS REWARDS_AVAILABLE,
    COALESCE(RESERVES_T.RESERVES, 0) AS RESERVES,
    COALESCE(TREASURY_T.TREASURY, 0) AS TREASURY
  FROM ( SELECT DISTINCT ON (STAKE_ADDRESS.ID)
      STAKE_ADDRESS.ID,
      STAKE_ADDRESS.VIEW AS STAKE_ADDRESS,
      POOL_HASH.VIEW AS POOL_ID,
      BLOCK.EPOCH_NO AS LATEST_WITHDRAWAL_EPOCH
    FROM
      STAKE_ADDRESS
      INNER JOIN DELEGATION ON DELEGATION.ADDR_ID = STAKE_ADDRESS.ID
      INNER JOIN POOL_HASH ON POOL_HASH.ID = DELEGATION.POOL_HASH_ID
      LEFT JOIN WITHDRAWAL ON WITHDRAWAL.ADDR_ID = STAKE_ADDRESS.ID
      LEFT JOIN TX ON TX.ID = WITHDRAWAL.TX_ID
      LEFT JOIN BLOCK ON BLOCK.ID = TX.BLOCK_ID
    WHERE
      NOT EXISTS (
        SELECT
          TRUE
        FROM
          DELEGATION D
        WHERE
          D.ADDR_ID = DELEGATION.ADDR_ID
          AND D.ID > DELEGATION.ID)
        AND NOT EXISTS (
          SELECT
            TRUE
          FROM
            STAKE_DEREGISTRATION
          WHERE
            STAKE_DEREGISTRATION.ADDR_ID = DELEGATION.ADDR_ID
            AND STAKE_DEREGISTRATION.TX_ID > DELEGATION.TX_ID)
        ORDER BY
          STAKE_ADDRESS.ID,
          BLOCK.EPOCH_NO DESC) T1
  LEFT JOIN LATERAL (
    SELECT
      COALESCE(SUM(TX_OUT.VALUE), 0) AS UTXO
    FROM
      TX_OUT
      INNER JOIN TX ON TX_OUT.TX_ID = TX.ID
        AND TX_OUT.STAKE_ADDRESS_ID = T1.ID
    LEFT JOIN TX_IN ON TX_OUT.TX_ID = TX_IN.TX_OUT_ID
      AND TX_OUT.INDEX::smallint = TX_IN.TX_OUT_INDEX::smallint
  WHERE
    TX.BLOCK_ID <= _last_accounted_block_id
    AND TX_IN.TX_IN_ID IS NULL
  GROUP BY
    T1.ID) UTXO_T ON TRUE
  LEFT JOIN LATERAL (
    SELECT
      COALESCE(SUM(REWARD.AMOUNT), 0) AS REWARDS
    FROM
      REWARD
    WHERE
      REWARD.ADDR_ID = T1.ID
      AND REWARD.SPENDABLE_EPOCH <= (
        SELECT
          MAX(NO)
        FROM
          EPOCH)
      GROUP BY
        T1.ID) REWARDS_T ON TRUE
  LEFT JOIN LATERAL (
    SELECT
      COALESCE(SUM(WITHDRAWAL.AMOUNT), 0) AS WITHDRAWALS
    FROM
      WITHDRAWAL
    WHERE
      WITHDRAWAL.ADDR_ID = T1.ID
    GROUP BY
      T1.ID) WITHDRAWALS_T ON TRUE
  LEFT JOIN LATERAL (
    SELECT
      COALESCE(SUM(RESERVE.AMOUNT), 0) AS RESERVES
    FROM
      RESERVE
      INNER JOIN TX ON TX.ID = RESERVE.TX_ID
      INNER JOIN BLOCK ON BLOCK.ID = TX.BLOCK_ID
    WHERE
      RESERVE.ADDR_ID = T1.ID
      AND BLOCK.EPOCH_NO >= T1.LATEST_WITHDRAWAL_EPOCH
    GROUP BY
      T1.ID) RESERVES_T ON TRUE
  LEFT JOIN LATERAL (
    SELECT
      COALESCE(SUM(TREASURY.AMOUNT), 0) AS TREASURY
    FROM
      TREASURY
      INNER JOIN TX ON TX.ID = TREASURY.TX_ID
      INNER JOIN BLOCK ON BLOCK.ID = TX.BLOCK_ID
    WHERE
      TREASURY.ADDR_ID = T1.ID
      AND BLOCK.EPOCH_NO >= T1.LATEST_WITHDRAWAL_EPOCH
    GROUP BY
      T1.ID) TREASURY_T ON TRUE
ON CONFLICT (STAKE_ADDRESS)
  DO UPDATE SET
    POOL_ID = EXCLUDED.POOL_ID,
    TOTAL_BALANCE = EXCLUDED.TOTAL_BALANCE,
    UTXO = EXCLUDED.UTXO,
    REWARDS = EXCLUDED.REWARDS,
    WITHDRAWALS = EXCLUDED.WITHDRAWALS,
    REWARDS_AVAILABLE = EXCLUDED.REWARDS_AVAILABLE,
    RESERVES = EXCLUDED.RESERVES,
    TREASURY = EXCLUDED.TREASURY
  WHERE
    STAKE_DISTRIBUTION_CACHE.POOL_ID IS DISTINCT FROM EXCLUDED.POOL_ID
    OR STAKE_DISTRIBUTION_CACHE.TOTAL_BALANCE IS DISTINCT FROM EXCLUDED.TOTAL_BALANCE
    OR STAKE_DISTRIBUTION_CACHE.UTXO IS DISTINCT FROM EXCLUDED.UTXO
    OR STAKE_DISTRIBUTION_CACHE.REWARDS IS DISTINCT FROM EXCLUDED.REWARDS
    OR STAKE_DISTRIBUTION_CACHE.WITHDRAWALS IS DISTINCT FROM EXCLUDED.WITHDRAWALS
    OR STAKE_DISTRIBUTION_CACHE.REWARDS_AVAILABLE IS DISTINCT FROM EXCLUDED.REWARDS_AVAILABLE
    OR STAKE_DISTRIBUTION_CACHE.RESERVES IS DISTINCT FROM EXCLUDED.RESERVES
    OR STAKE_DISTRIBUTION_CACHE.TREASURY IS DISTINCT FROM EXCLUDED.TREASURY;
  -- Store last block height in the control table
  INSERT INTO GREST.CONTROL_TABLE (key, last_value)
    VALUES ('stake_distribution_lbh', _last_accounted_block_height)
  ON CONFLICT (key)
    DO UPDATE SET
      last_value = _last_accounted_block_height;
END;
$$;

DROP FUNCTION IF EXISTS GREST.UPDATE_STAKE_DISTRIBUTION_CACHE_CHECK;

CREATE FUNCTION GREST.UPDATE_STAKE_DISTRIBUTION_CACHE_CHECK ()
  RETURNS VOID
  LANGUAGE PLPGSQL
  AS $$
DECLARE
  _last_update_block_height integer DEFAULT NULL;
  _current_block_height integer DEFAULT NULL;
  _last_update_block_diff integer DEFAULT NULL;
  StartTime timestamptz;
  EndTime timestamptz;
  -- In minutes
  Delta numeric;
BEGIN
  IF (
    SELECT
      COUNT(pid) > 1
    FROM
      pg_stat_activity
    WHERE
      query != '<IDLE>' AND query ILIKE 'SELECT GREST.UPDATE_STAKE_DISTRIBUTION_CACHE_CHECK();') THEN
    RAISE EXCEPTION 'Previous query still running but should have completed! Exiting...';
  END IF;
  -- QUERY START --
  SELECT
    last_value
  FROM
    GREST.control_table
  WHERE
    key = 'stake_distribution_lbh' INTO _last_update_block_height;
  SELECT
    MAX(block_no)
  FROM
    PUBLIC.BLOCK
  WHERE
    BLOCK_NO IS NOT NULL INTO _current_block_height;
  SELECT
    (_current_block_height - _last_update_block_height) INTO _last_update_block_diff;
  -- Do nothing until there is a 180 blocks difference in height - 60 minutes theoretical time
  -- 185 in check because last block height considered is 5 blocks behind tip
  Raise NOTICE 'Last stake distribution update was % blocks ago...', _last_update_block_diff;
  IF (_last_update_block_diff >= 185
    -- Special case for db-sync restart rollback to epoch start
    OR _last_update_block_diff < 0) THEN
    RAISE NOTICE 'Re-running...';
    CALL GREST.UPDATE_STAKE_DISTRIBUTION_CACHE ();
    -- Time recording
    EndTime := CLOCK_TIMESTAMP();
    Delta := 1000 * (EXTRACT(epoch from EndTime) - EXTRACT(epoch from StartTime)) / 60000;
    RAISE NOTICE 'Job completed in % minutes', Delta;
  END IF;
  RAISE NOTICE 'Minimum block height difference(180) for update not reached, skipping...';
  RETURN;
END;
$$;

-- Run the first time update if needed
SELECT
  GREST.UPDATE_STAKE_DISTRIBUTION_CACHE_CHECK ();

CREATE INDEX IF NOT EXISTS idx_pool_id ON GREST.STAKE_DISTRIBUTION_CACHE (POOL_ID);

